diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/AEAudioFormat.h xbmc/xbmc/cores/AudioEngine/AEAudioFormat.h
--- xbmcfrodo/xbmc/cores/AudioEngine/AEAudioFormat.h	2013-04-05 17:19:12.269433079 +0000
+++ xbmc/xbmc/cores/AudioEngine/AEAudioFormat.h	2013-03-08 08:56:41.614490175 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -70,7 +70,7 @@
 /**
  * The audio format structure that fully defines a stream's audio information
  */
-typedef struct {
+typedef struct AEAudioFormat{
   /**
    * The stream's data format (eg, AE_FMT_S16LE)
    */
@@ -105,5 +105,16 @@
    * The size of one frame in bytes
    */
   unsigned int m_frameSize;
+ 
+  AEAudioFormat()
+  {
+    m_dataFormat = AE_FMT_INVALID;
+    m_sampleRate = 0;
+    m_encodedRate = 0;
+    m_frames = 0;
+    m_frameSamples = 0;
+    m_frameSize = 0;
+  }
+ 
 } AEAudioFormat;
 
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/AEFactory.cpp xbmc/xbmc/cores/AudioEngine/AEFactory.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/AEFactory.cpp	2013-02-16 18:48:35.044459720 +0000
+++ xbmc/xbmc/cores/AudioEngine/AEFactory.cpp	2013-03-17 12:41:38.017315550 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -48,9 +48,8 @@
 
   bool loaded = false;
 
-  std::string engine;
-
 #if defined(TARGET_LINUX)
+  std::string engine;
   if (getenv("AE_ENGINE"))
   {
     engine = (std::string)getenv("AE_ENGINE");
@@ -203,9 +202,8 @@
   EnumerateOutputDevices(devices, passthrough);
   std::string firstDevice;
 
-  for (AEDeviceList::const_iterator deviceIt = devices.begin(); deviceIt != devices.end(); deviceIt++)
+  for (AEDeviceList::const_iterator deviceIt = devices.begin(); deviceIt != devices.end(); ++deviceIt)
   {
-    std::string currentDevice = deviceIt->second;
     /* remember the first device so we can default to it if required */
     if (firstDevice.empty())
       firstDevice = deviceIt->second;
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/AEFactory.h xbmc/xbmc/cores/AudioEngine/AEFactory.h
--- xbmcfrodo/xbmc/cores/AudioEngine/AEFactory.h	2013-02-16 18:48:35.044459720 +0000
+++ xbmc/xbmc/cores/AudioEngine/AEFactory.h	2013-02-10 14:23:18.136522590 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/AESinkFactory.cpp xbmc/xbmc/cores/AudioEngine/AESinkFactory.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/AESinkFactory.cpp	2013-02-19 17:48:55.411700780 +0000
+++ xbmc/xbmc/cores/AudioEngine/AESinkFactory.cpp	2013-02-10 14:23:18.136522590 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/AESinkFactory.h xbmc/xbmc/cores/AudioEngine/AESinkFactory.h
--- xbmcfrodo/xbmc/cores/AudioEngine/AESinkFactory.h	2013-02-19 17:48:55.411700780 +0000
+++ xbmc/xbmc/cores/AudioEngine/AESinkFactory.h	2013-02-10 14:23:18.136522590 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp xbmc/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp	2013-03-17 17:48:06.456776003 +0000
+++ xbmc/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp	2013-03-30 23:02:37.009522450 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -29,8 +29,8 @@
 #include <string.h>
 
 CAEEncoderFFmpeg::CAEEncoderFFmpeg():
-  m_CodecCtx      (NULL ),
   m_BitRate       (0    ),
+  m_CodecCtx      (NULL ),
   m_BufferSize    (0    ),
   m_OutputSize    (0    ),
   m_OutputRatio   (0.0  ),
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h xbmc/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h	2013-02-16 18:48:35.044459720 +0000
+++ xbmc/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h	2013-02-10 14:23:18.136522590 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp	2013-02-19 17:48:55.421700589 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp	2013-03-18 23:19:17.897266485 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -51,8 +51,11 @@
                           void*                               inClientData)
 {
   CCoreAudioAE *pEngine = (CCoreAudioAE *)inClientData;
+  if (pEngine->GetHAL())
+  {
   pEngine->AudioDevicesChanged();
   CLog::Log(LOGDEBUG, "CCoreAudioAE - audiodevicelist changed!");
+  }
   return noErr;
 }
 
@@ -102,8 +105,8 @@
 
 CCoreAudioAE::~CCoreAudioAE()
 {
-  RegisterDeviceChangedCB(false, this);
   Shutdown();
+  RegisterDeviceChangedCB(false, this);
 }
 
 void CCoreAudioAE::Shutdown()
@@ -138,6 +141,9 @@
 
 void CCoreAudioAE::AudioDevicesChanged()
 {
+  if (!m_Initialized)
+    return;
+
   // give CA a bit time to realise that maybe the 
   // default device might have changed now - else
   // OpenCoreAudio might open the old default device
@@ -488,7 +494,11 @@
   // if we are suspended we don't
   // want anyone to mess with us
   if (m_isSuspended && !m_softSuspend)
+#if defined(TARGET_DARWIN_IOS) && !defined(TARGET_DARWIN_IOS_ATV)
+    Resume();
+#else
     return NULL;
+#endif
 
   CAEChannelInfo channelInfo(channelLayout);
   CLog::Log(LOGINFO, "CCoreAudioAE::MakeStream - %s, %u, %u, %s",
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.h xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.h	2013-02-19 17:48:55.421700589 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.h	2013-02-10 14:23:18.146522395 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHAL.cpp xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHAL.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHAL.cpp	2013-02-16 18:48:35.054459522 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHAL.cpp	2013-02-10 14:23:18.146522395 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHAL.h xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHAL.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHAL.h	2013-02-16 18:48:35.054459522 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHAL.h	2013-02-10 14:23:18.146522395 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALIOS.cpp xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALIOS.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALIOS.cpp	2013-03-17 17:48:06.456776003 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALIOS.cpp	2013-03-17 12:41:38.017315550 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -32,7 +32,8 @@
 
 #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 
-#define BUFFERED_FRAMES 1024
+// use the maximum frames per slice allows audio play when the screen is locked
+#define BUFFERED_FRAMES 4096
 
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 // CIOSCoreAudioHardware
@@ -634,9 +635,13 @@
   if (!m_audioUnit->Open(m_audioGraph, kAudioUnitType_Output, kAudioUnitSubType_RemoteIO, kAudioUnitManufacturer_Apple))
     return false;
 
+  UInt32 bufferFrames = m_audioUnit->GetBufferFrameSize();
+
   if (!m_audioUnit->EnableInputOuput())
     return false;
 
+  m_audioUnit->SetMaxFramesPerSlice(bufferFrames);
+
   m_audioUnit->GetFormatDesc(format, &inputFormat);
 
   //if(!allowMixing)
@@ -662,6 +667,8 @@
     if (!m_mixerUnit->Open(m_audioGraph, kAudioUnitType_Mixer, kAudioUnitSubType_MultiChannelMixer, kAudioUnitManufacturer_Apple))
       return false;
 
+    m_mixerUnit->SetMaxFramesPerSlice(bufferFrames);
+
     // set number of input buses
     if (!m_mixerUnit->SetInputBusCount(MAX_CONNECTION_LIMIT))
       return false;
@@ -698,6 +705,8 @@
     if (!m_inputUnit->Open(m_audioGraph, kAudioUnitType_FormatConverter, kAudioUnitSubType_AUConverter, kAudioUnitManufacturer_Apple))
       return false;
 
+    m_inputUnit->SetMaxFramesPerSlice(bufferFrames);
+
     if (!m_inputUnit->SetFormat(&inputFormat, kAudioUnitScope_Input, kOutputBus))
       return false;
 
@@ -773,12 +782,6 @@
 
   SetCurrentVolume(initVolume);
 
-  UInt32 bufferFrames = m_audioUnit->GetBufferFrameSize();
-
-  m_audioUnit->SetMaxFramesPerSlice(bufferFrames);
-  if (m_inputUnit)
-    m_inputUnit->SetMaxFramesPerSlice(bufferFrames);
-
   SetInputSource(pSource);
 
   ShowGraph();
@@ -986,6 +989,8 @@
   if (!outputUnit->Open(m_audioGraph, kAudioUnitType_FormatConverter, kAudioUnitSubType_AUConverter, kAudioUnitManufacturer_Apple))
     goto error;
 
+  outputUnit->SetMaxFramesPerSlice(m_audioUnit->GetBufferFrameSize());
+
   m_audioUnit->GetFormatDesc(format, &inputFormat);
 
   // get the format frm the mixer
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALIOS.h xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALIOS.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALIOS.h	2013-02-16 18:48:35.054459522 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALIOS.h	2013-02-10 14:23:18.156522201 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALOSX.cpp xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALOSX.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALOSX.cpp	2013-03-17 17:48:06.466775815 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALOSX.cpp	2013-03-17 12:41:38.027315356 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALOSX.h xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALOSX.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALOSX.h	2013-02-16 18:48:35.064459324 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALOSX.h	2013-02-10 14:23:18.156522201 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAESound.cpp xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAESound.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAESound.cpp	2013-02-16 18:48:35.064459324 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAESound.cpp	2013-02-10 14:23:18.156522201 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAESound.h xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAESound.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAESound.h	2013-02-16 18:48:35.064459324 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAESound.h	2013-02-10 14:23:18.156522201 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.cpp xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.cpp	2013-02-16 18:48:35.064459324 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.cpp	2013-03-13 13:48:12.821148662 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -148,6 +148,7 @@
   //_aligned_free(m_resampleBuffer); m_resampleBuffer = NULL;
   _aligned_free(m_remapBuffer); m_remapBuffer = NULL;
   _aligned_free(m_vizRemapBuffer); m_vizRemapBuffer = NULL;
+  _aligned_free(m_upmixBuffer); m_upmixBuffer = NULL;
 
   delete m_Buffer; m_Buffer = NULL;
 
@@ -596,6 +597,10 @@
 
 void CCoreAudioAEStream::Resume()
 {
+#if defined(TARGET_DARWIN_IOS) && !defined(TARGET_DARWIN_IOS_ATV)
+  if (CAEFactory::IsSuspended())
+    CAEFactory::Resume();
+#endif
   m_paused = false;
 }
 
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.h xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.h	2013-02-16 18:48:35.074459125 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.h	2013-02-10 14:23:18.166522008 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioChannelLayout.cpp xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioChannelLayout.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioChannelLayout.cpp	2013-02-16 18:48:35.074459125 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioChannelLayout.cpp	2013-02-10 14:23:18.166522008 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioChannelLayout.h xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioChannelLayout.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioChannelLayout.h	2013-02-16 18:48:35.074459125 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioChannelLayout.h	2013-02-10 14:23:18.166522008 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioDevice.cpp xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioDevice.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioDevice.cpp	2013-02-16 18:48:35.074459125 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioDevice.cpp	2013-02-10 14:23:18.166522008 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -361,6 +361,10 @@
       // even if setting hogmode was successfull our PID might not get written
       // into m_HogPid (so it stays -1). Readback hogstatus for judging if we
       // had success on getting hog status
+      // We do this only when AudioObjectSetPropertyData didn't set m_HogPid because
+      // it seems that in the other cases the GetHogStatus could return -1
+      // which would overwrite our valid m_HogPid again
+      // Man we should never touch this shit again ;)
       if (m_HogPid == -1)
         m_HogPid = GetHogStatus();
 
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioDevice.h xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioDevice.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioDevice.h	2013-02-16 18:48:35.074459125 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioDevice.h	2013-02-10 14:23:18.166522008 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioGraph.cpp xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioGraph.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioGraph.cpp	2013-02-16 18:48:35.074459125 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioGraph.cpp	2013-03-17 21:46:53.854323365 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -104,7 +104,7 @@
     delete m_mixMap;
     m_mixMap = CCoreAudioMixMap::CreateMixMap(m_audioUnit, format, layoutTag);
 
-    if (m_mixMap || m_mixMap->IsValid())
+    if (m_mixMap && m_mixMap->IsValid())
     {
       // maximum input channel ber input bus
       //fmt.mChannelsPerFrame = MAXIMUM_MIXER_CHANNELS;
@@ -152,7 +152,12 @@
       if (!m_mixerUnit->SetInputBusFormat(MAX_CONNECTION_LIMIT, &fmt))
         return false;
 
-      if (!m_mixerUnit->SetFormat(&fmt, kAudioUnitScope_Output, kOutputBus))
+      // Update format structure to reflect the desired format from the mixer
+      // The output format of the mixer is identical to the input format, except for the channel count
+      AudioStreamBasicDescription mixOutput(fmt);
+      mixOutput.mChannelsPerFrame = m_mixMap->GetOutputChannels();
+
+      if (!m_mixerUnit->SetFormat(&mixOutput, kAudioUnitScope_Output, kOutputBus))
         return false;
 
       ret =  AUGraphConnectNodeInput(m_audioGraph, m_mixerUnit->GetNode(), 0, m_audioUnit->GetNode(), 0);
@@ -193,17 +198,13 @@
         return false;
       }
 
-      // Update format structure to reflect the desired format from the mixer
-      // The output format of the mixer is identical to the input format, except for the channel count
-      fmt.mChannelsPerFrame = m_mixMap->GetOutputChannels();
-
       UInt32 inputNumber = m_inputUnit->GetBus();
       int channelOffset = GetMixerChannelOffset(inputNumber);
-      if (!CCoreAudioMixMap::SetMixingMatrix(m_mixerUnit, m_mixMap, &inputFormat, &fmt, channelOffset))
+      if (!CCoreAudioMixMap::SetMixingMatrix(m_mixerUnit, m_mixMap, &fmt, &mixOutput, channelOffset))
         return false;
 
       // Regenerate audio format and copy format for the Output AU
-      outputFormat = fmt;
+      outputFormat = mixOutput;
     }
     else
     {
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioGraph.h xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioGraph.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioGraph.h	2013-02-16 18:48:35.074459125 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioGraph.h	2013-04-05 11:38:43.776817146 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -46,7 +46,7 @@
   bool             Close();
   bool             Start();
   bool             Stop();
-  AudioChannelLayoutTag GetChannelLayoutTag(int layout);
+  static AudioChannelLayoutTag GetChannelLayoutTag(int layout);
   bool             SetInputSource(ICoreAudioSource *pSource);
   bool             SetCurrentVolume(Float32 vol);
   CAUOutputDevice* DestroyUnit(CAUOutputDevice *outputUnit);
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioHardware.cpp xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioHardware.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioHardware.cpp	2013-02-19 17:48:55.421700589 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioHardware.cpp	2013-04-05 11:38:43.786816965 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -22,6 +22,7 @@
 
 #include "CoreAudioAEHAL.h"
 #include "utils/log.h"
+#include "osx/DarwinUtils.h"
 
 bool CCoreAudioHardware::GetAutoHogMode()
 {
@@ -94,7 +95,7 @@
   }
 
   // Add a terminating ID:
-  list[listSize/sizeof(AudioStreamID)].mFormatID = 0;
+  list[listSize/sizeof(AudioStreamBasicDescription)].mFormatID = 0;
 
   return list;
 }
@@ -339,9 +340,8 @@
     if (ret != noErr)
       return;
 
-    const char *cstr = CFStringGetCStringPtr(theDeviceName, CFStringGetSystemEncoding());
-    if (cstr)
-      name = cstr;
+    DarwinCFStringRefToUTF8String(theDeviceName, name);
+
     CFRelease(theDeviceName);
   }
 }
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioHardware.h xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioHardware.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioHardware.h	2013-02-16 18:48:35.084458926 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioHardware.h	2013-02-10 14:23:18.176521814 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioMixMap.cpp xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioMixMap.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioMixMap.cpp	2013-03-05 19:37:56.572328882 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioMixMap.cpp	2013-03-17 12:41:38.027315356 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -58,12 +58,12 @@
   // Try to find a 'well-known' matrix
   const AudioChannelLayout* layouts[] = {&inLayout, &outLayout};
   UInt32 propSize = 0;
-  OSStatus ret = AudioFormatGetPropertyInfo(kAudioFormatProperty_MatrixMixMap,
+  AudioFormatGetPropertyInfo(kAudioFormatProperty_MatrixMixMap,
     sizeof(layouts), layouts, &propSize);
   m_pMap = (Float32*)calloc(1,propSize);
 
   // Try and get a predefined mixmap
-  ret = AudioFormatGetProperty(kAudioFormatProperty_MatrixMixMap,
+  OSStatus ret = AudioFormatGetProperty(kAudioFormatProperty_MatrixMixMap,
     sizeof(layouts), layouts, &propSize, m_pMap);
   if (!ret)
   {
@@ -221,14 +221,14 @@
   if(fmt->mChannelsPerFrame > dims[1])
   {
     CLog::Log(LOGERROR, "CCoreAudioMixMap::SetMixingMatrix - ouput format doesn't fit mixer size %u > %u"
-              , fmt->mChannelsPerFrame, dims[0]);
+              , fmt->mChannelsPerFrame, dims[1]);
     return false;
   }
 
   if(fmt->mChannelsPerFrame < dims[1])
   {
     CLog::Log(LOGWARNING, "CCoreAudioMixMap::SetMixingMatrix - ouput format doesn't specify all outputs %u < %u"
-              , fmt->mChannelsPerFrame, dims[0]);
+              , fmt->mChannelsPerFrame, dims[1]);
   }
 
   // Configure the mixing matrix
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioMixMap.h xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioMixMap.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioMixMap.h	2013-03-05 19:37:56.572328882 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioMixMap.h	2013-02-26 21:41:56.027959600 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioRingBuffer.h xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioRingBuffer.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioRingBuffer.h	2013-02-16 18:48:35.084458926 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioRingBuffer.h	2013-03-17 12:41:38.027315356 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -156,7 +156,7 @@
     unsigned int space = GetReadSize();
 
     //want to read more than we have written?
-    if( space <= 0 )
+    if( space == 0 )
     {
 #ifdef RING_BUFFER_DEBUG
       CLog::Log(LOGDEBUG, "CoereAudioRingBuffer: Can't read from empty buffer.");
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioStream.cpp xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioStream.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioStream.cpp	2013-02-16 18:48:35.084458926 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioStream.cpp	2013-02-10 14:23:18.186521619 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioStream.h xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioStream.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioStream.h	2013-02-16 18:48:35.084458926 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioStream.h	2013-02-10 14:23:18.186521619 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioUnit.cpp xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioUnit.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioUnit.cpp	2013-02-16 18:48:35.094458728 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioUnit.cpp	2013-02-10 14:23:18.186521619 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioUnit.h xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioUnit.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioUnit.h	2013-02-16 18:48:35.094458728 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioUnit.h	2013-02-10 14:23:18.186521619 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/ICoreAudioAEHAL.h xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/ICoreAudioAEHAL.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/ICoreAudioAEHAL.h	2013-02-16 18:48:35.094458728 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/ICoreAudioAEHAL.h	2013-02-10 14:23:18.186521619 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/ICoreAudioSource.h xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/ICoreAudioSource.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/CoreAudio/ICoreAudioSource.h	2013-02-16 18:48:35.094458728 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/CoreAudio/ICoreAudioSource.h	2013-02-10 14:23:18.186521619 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAE.cpp xbmc/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAE.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAE.cpp	2013-03-17 17:48:06.466775815 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAE.cpp	2013-03-17 12:41:38.027315356 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAE.h xbmc/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAE.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAE.h	2013-02-16 18:48:35.094458728 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAE.h	2013-02-10 14:23:18.196521424 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAESound.cpp xbmc/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAESound.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAESound.cpp	2013-03-17 17:48:06.466775815 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAESound.cpp	2013-03-17 12:41:38.027315356 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAESound.h xbmc/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAESound.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAESound.h	2013-02-16 18:48:35.094458728 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAESound.h	2013-02-10 14:23:18.196521424 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.cpp xbmc/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.cpp	2013-03-11 02:09:46.430994170 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.cpp	2013-04-05 17:09:10.500436679 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -203,7 +203,9 @@
     return /*false*/;
   }
 
-  m_cacheSize = pa_stream_writable_size(m_Stream);
+  const pa_buffer_attr *streamBuffer;
+  streamBuffer = pa_stream_get_buffer_attr(m_Stream);
+  m_cacheSize = streamBuffer->maxlength;
 
   pa_threaded_mainloop_unlock(m_MainLoop);
 
@@ -252,6 +254,10 @@
 
   if (m_Stream)
   {
+    pa_stream_set_state_callback(m_Stream, NULL, NULL);
+    pa_stream_set_write_callback(m_Stream, NULL, NULL);
+    pa_stream_set_latency_update_callback(m_Stream, NULL, NULL);
+    pa_stream_set_underflow_callback(m_Stream, NULL, NULL);
     pa_stream_disconnect(m_Stream);
     pa_stream_unref(m_Stream);
     m_Stream = NULL;
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.h xbmc/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.h	2013-02-19 17:48:55.431700398 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.h	2013-02-11 10:42:50.772893810 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.cpp xbmc/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.cpp	2013-02-25 18:48:14.197719386 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.cpp	2013-04-01 20:35:56.161582879 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -63,6 +63,7 @@
   m_isSuspended        (false       ),
   m_softSuspend        (false       ),
   m_softSuspendTimer   (0           ),
+  m_volume             (1.0         ),
   m_sink               (NULL        ),
   m_transcode          (false       ),
   m_rawPassthrough     (false       ),
@@ -974,8 +975,10 @@
 {
   CLog::Log(LOGDEBUG, "CSoftAE::Suspend - Suspending AE processing");
   m_isSuspended = true;
-  CSingleLock streamLock(m_streamLock);
   
+  StopAllSounds();
+
+  CSingleLock streamLock(m_streamLock);
   for (StreamList::iterator itt = m_playingStreams.begin(); itt != m_playingStreams.end(); ++itt)
   {
     CSoftAEStream *stream = *itt;
@@ -984,7 +987,6 @@
   streamLock.Leave();
   #if defined(TARGET_LINUX)
   /*workaround sinks not playing sound after resume */
-    StopAllSounds();
     bool ret = true;
     if(m_sink)
     {
@@ -1535,7 +1537,8 @@
      */
     if (!m_isSuspended && (!m_playingStreams.empty() || !m_playing_sounds.empty()))
     {
-      m_reOpen = !m_sink->SoftResume() || m_reOpen; // sink returns false if it requires reinit (worthless with current implementation)
+      // the sink might still be not initialized after Resume of real suspend
+      m_reOpen = m_sink && (!m_sink->SoftResume() || m_reOpen); // sink returns false if it requires reinit (worthless with current implementation)
       m_sinkIsSuspended = false; //sink processing data
       m_softSuspend   = false; //break suspend loop (under some conditions)
       CLog::Log(LOGDEBUG, "Resumed the Sink");
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.h xbmc/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.h	2013-02-19 17:48:55.431700398 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.h	2013-02-14 20:17:20.569850691 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAESound.cpp xbmc/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAESound.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAESound.cpp	2013-02-16 18:48:35.104458530 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAESound.cpp	2013-03-17 12:41:38.027315356 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -34,12 +34,6 @@
 /* typecast AE to CSoftAE */
 #define AE (*((CSoftAE*)CAEFactory::GetEngine()))
 
-typedef struct
-{
-  char     chunk_id[4];
-  uint32_t chunksize;
-} WAVE_CHUNK;
-
 CSoftAESound::CSoftAESound(const std::string &filename) :
   IAESound         (filename),
   m_filename       (filename),
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAESound.h xbmc/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAESound.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAESound.h	2013-02-16 18:48:35.114458332 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAESound.h	2013-02-10 14:23:18.206521230 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.cpp xbmc/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.cpp	2013-03-11 02:09:46.430994170 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.cpp	2013-03-06 15:52:58.705221605 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.h xbmc/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.h	2013-02-16 18:48:35.114458332 +0000
+++ xbmc/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.h	2013-02-10 14:23:18.216521036 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Interfaces/AE.h xbmc/xbmc/cores/AudioEngine/Interfaces/AE.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Interfaces/AE.h	2013-02-16 18:48:35.114458332 +0000
+++ xbmc/xbmc/cores/AudioEngine/Interfaces/AE.h	2013-02-10 14:23:18.216521036 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Interfaces/AEEncoder.h xbmc/xbmc/cores/AudioEngine/Interfaces/AEEncoder.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Interfaces/AEEncoder.h	2013-02-16 18:48:35.114458332 +0000
+++ xbmc/xbmc/cores/AudioEngine/Interfaces/AEEncoder.h	2013-02-10 14:23:18.216521036 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Interfaces/AESink.h xbmc/xbmc/cores/AudioEngine/Interfaces/AESink.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Interfaces/AESink.h	2013-02-16 18:48:35.114458332 +0000
+++ xbmc/xbmc/cores/AudioEngine/Interfaces/AESink.h	2013-03-08 08:56:42.114480825 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -49,7 +49,7 @@
   /*
     Return true if the supplied format and device are compatible with the current open sink
   */
-  virtual bool IsCompatible(const AEAudioFormat format, const std::string device) = 0;
+  virtual bool IsCompatible(const AEAudioFormat format, const std::string &device) = 0;
 
   /*
     This method returns the time in seconds that it will take
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Interfaces/AESound.h xbmc/xbmc/cores/AudioEngine/Interfaces/AESound.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Interfaces/AESound.h	2013-02-16 18:48:35.114458332 +0000
+++ xbmc/xbmc/cores/AudioEngine/Interfaces/AESound.h	2013-02-10 14:23:18.216521036 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Interfaces/AEStream.h xbmc/xbmc/cores/AudioEngine/Interfaces/AEStream.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Interfaces/AEStream.h	2013-02-16 18:48:35.114458332 +0000
+++ xbmc/xbmc/cores/AudioEngine/Interfaces/AEStream.h	2013-02-10 14:23:18.216521036 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Interfaces/ThreadedAE.h xbmc/xbmc/cores/AudioEngine/Interfaces/ThreadedAE.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Interfaces/ThreadedAE.h	2013-02-16 18:48:35.114458332 +0000
+++ xbmc/xbmc/cores/AudioEngine/Interfaces/ThreadedAE.h	2013-02-10 14:23:18.216521036 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp xbmc/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp	2013-02-19 17:48:55.441700206 +0000
+++ xbmc/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp	2013-04-05 17:09:10.500436679 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -38,7 +38,6 @@
 #endif
 
 #define ALSA_OPTIONS (SND_PCM_NONBLOCK | SND_PCM_NO_AUTO_FORMAT | SND_PCM_NO_AUTO_CHANNELS | SND_PCM_NO_AUTO_RESAMPLE)
-#define ALSA_PERIODS 16
 
 #define ALSA_MAX_CHANNELS 16
 static enum AEChannel ALSAChannelMap[ALSA_MAX_CHANNELS + 1] = {
@@ -67,7 +66,11 @@
 };
 
 CAESinkALSA::CAESinkALSA() :
-  m_pcm(NULL)
+  m_bufferSize(0),
+  m_formatSampleRateMul(0.0),
+  m_passthrough(false),
+  m_pcm(NULL),
+  m_timeout(0)
 {
   /* ensure that ALSA has been initialized */
   if (!snd_config)
@@ -174,16 +177,7 @@
   snd_config_t *config;
   snd_config_copy(&config, snd_config);
 
-  snd_config_t *dmixRateConf;
-  long dmixRate;
-
-  if (snd_config_search(config, "defaults.pcm.dmix.rate", &dmixRateConf) < 0
-      || snd_config_get_integer(dmixRateConf, &dmixRate) < 0)
-    dmixRate = 48000; /* assume default */
-
-
-  /* Prefer dmix for non-passthrough stereo when sample rate matches */
-  if (!OpenPCMDevice(device, AESParams, m_channelLayout.Count(), &m_pcm, config, format.m_sampleRate == (unsigned int) dmixRate && !m_passthrough))
+  if (!OpenPCMDevice(device, AESParams, m_channelLayout.Count(), &m_pcm, config))
   {
     CLog::Log(LOGERROR, "CAESinkALSA::Initialize - failed to initialize device \"%s\"", device.c_str());
     snd_config_delete(config);
@@ -211,7 +205,7 @@
   return true;
 }
 
-bool CAESinkALSA::IsCompatible(const AEAudioFormat format, const std::string device)
+bool CAESinkALSA::IsCompatible(const AEAudioFormat format, const std::string &device)
 {
   return (
       /* compare against the requested format and the real format */
@@ -328,59 +322,79 @@
     }
   }
 
-  unsigned int periods;
-
   snd_pcm_uframes_t periodSize, bufferSize;
   snd_pcm_hw_params_get_buffer_size_max(hw_params, &bufferSize);
+  snd_pcm_hw_params_get_period_size_max(hw_params, &periodSize, NULL);
+
+  /* 
+   We want to make sure, that we have max 200 ms Buffer with 
+   a periodSize of approx 50 ms. Choosing a higher bufferSize
+   will cause problems with menu sounds. Buffer will be increased
+   after those are fixed.
+  */
+  periodSize  = std::min(periodSize, (snd_pcm_uframes_t) sampleRate / 20);
+  bufferSize  = std::min(bufferSize, (snd_pcm_uframes_t) sampleRate / 5);
 
-  bufferSize  = std::min(bufferSize, (snd_pcm_uframes_t)8192);
-  periodSize  = bufferSize / ALSA_PERIODS;
-  periods     = ALSA_PERIODS;
+  /* 
+   According to upstream we should set buffer size first - so make sure it is always at least
+   4x period size to not get underruns (some systems seem to have issues with only 2 periods)
+  */
+  periodSize = std::min(periodSize, bufferSize / 4);
 
-  CLog::Log(LOGDEBUG, "CAESinkALSA::InitializeHW - Request: periodSize %lu, periods %u, bufferSize %lu", periodSize, periods, bufferSize);
+  CLog::Log(LOGDEBUG, "CAESinkALSA::InitializeHW - Request: periodSize %lu, bufferSize %lu", periodSize, bufferSize);
 
-  /* work on a copy of the hw params */
   snd_pcm_hw_params_t *hw_params_copy;
   snd_pcm_hw_params_alloca(&hw_params_copy);
+  snd_pcm_hw_params_copy(hw_params_copy, hw_params); // copy what we have and is already working
 
-  /* try to set the buffer size then the period size */
-  snd_pcm_hw_params_copy(hw_params_copy, hw_params);
-  snd_pcm_hw_params_set_buffer_size_near(m_pcm, hw_params_copy, &bufferSize);
-  snd_pcm_hw_params_set_period_size_near(m_pcm, hw_params_copy, &periodSize, NULL);
-  snd_pcm_hw_params_set_periods_near    (m_pcm, hw_params_copy, &periods   , NULL);
-  if (snd_pcm_hw_params(m_pcm, hw_params_copy) != 0)
-  {
-    /* try to set the period size then the buffer size */
-    snd_pcm_hw_params_copy(hw_params_copy, hw_params);
-    snd_pcm_hw_params_set_period_size_near(m_pcm, hw_params_copy, &periodSize, NULL);
-    snd_pcm_hw_params_set_buffer_size_near(m_pcm, hw_params_copy, &bufferSize);
-    snd_pcm_hw_params_set_periods_near    (m_pcm, hw_params_copy, &periods   , NULL);
-    if (snd_pcm_hw_params(m_pcm, hw_params_copy) != 0)
-    {
-      /* try to just set the buffer size */
-      snd_pcm_hw_params_copy(hw_params_copy, hw_params);
-      snd_pcm_hw_params_set_buffer_size_near(m_pcm, hw_params_copy, &bufferSize);
-      snd_pcm_hw_params_set_periods_near    (m_pcm, hw_params_copy, &periods   , NULL);
-      if (snd_pcm_hw_params(m_pcm, hw_params_copy) != 0)
-      {
-        /* try to just set the period size */
-        snd_pcm_hw_params_copy(hw_params_copy, hw_params);
-        snd_pcm_hw_params_set_period_size_near(m_pcm, hw_params_copy, &periodSize, NULL);
-        snd_pcm_hw_params_set_periods_near    (m_pcm, hw_params_copy, &periods   , NULL);
-        if (snd_pcm_hw_params(m_pcm, hw_params_copy) != 0)
+  // first trying bufferSize, PeriodSize
+  // for more info see here:
+  // http://mailman.alsa-project.org/pipermail/alsa-devel/2009-September/021069.html
+  // the last three tries are done as within pulseaudio
+
+  // backup periodSize and bufferSize first. Restore them after every failed try
+  snd_pcm_uframes_t periodSizeTemp, bufferSizeTemp;
+  periodSizeTemp = periodSize;
+  bufferSizeTemp = bufferSize;
+  if (snd_pcm_hw_params_set_buffer_size_near(m_pcm, hw_params_copy, &bufferSize) != 0
+    || snd_pcm_hw_params_set_period_size_near(m_pcm, hw_params_copy, &periodSize, NULL) != 0
+    || snd_pcm_hw_params(m_pcm, hw_params_copy) != 0)
+  {
+    bufferSize = bufferSizeTemp;
+    periodSize = periodSizeTemp;
+    // retry with PeriodSize, bufferSize
+    snd_pcm_hw_params_copy(hw_params_copy, hw_params); // restore working copy
+    if (snd_pcm_hw_params_set_period_size_near(m_pcm, hw_params_copy, &periodSize, NULL) != 0
+      || snd_pcm_hw_params_set_buffer_size_near(m_pcm, hw_params_copy, &bufferSize) != 0
+      || snd_pcm_hw_params(m_pcm, hw_params_copy) != 0)
+    {
+      // try only periodSize
+      periodSize = periodSizeTemp;
+      snd_pcm_hw_params_copy(hw_params_copy, hw_params); // restore working copy
+      if(snd_pcm_hw_params_set_period_size_near(m_pcm, hw_params_copy, &periodSize, NULL) != 0 
+        || snd_pcm_hw_params(m_pcm, hw_params_copy) != 0)
+      {
+        // try only BufferSize
+        bufferSize = bufferSizeTemp;
+        snd_pcm_hw_params_copy(hw_params_copy, hw_params); // restory working copy
+        if (snd_pcm_hw_params_set_buffer_size_near(m_pcm, hw_params_copy, &bufferSize) != 0
+          || snd_pcm_hw_params(m_pcm, hw_params_copy) != 0)
+        {
+          // set default that Alsa would choose
+          CLog::Log(LOGWARNING, "CAESinkAlsa::IntializeHW - Using default alsa values - set failed");
+          if (snd_pcm_hw_params(m_pcm, hw_params) != 0)
         {
-          CLog::Log(LOGERROR, "CAESinkALSA::InitializeHW - Failed to set the parameters");
+            CLog::Log(LOGDEBUG, "CAESinkALSA::InitializeHW - Could not init a valid sink");
           return false;
         }
       }
     }
+      // reread values when alsa default was kept
+      snd_pcm_get_params(m_pcm, &bufferSize, &periodSize);
+    }
   }
 
-  snd_pcm_hw_params_get_period_size(hw_params_copy, &periodSize, NULL);
-  snd_pcm_hw_params_get_buffer_size(hw_params_copy, &bufferSize);
-  
-
-  CLog::Log(LOGDEBUG, "CAESinkALSA::InitializeHW - Got: periodSize %lu, periods %u, bufferSize %lu", periodSize, periods, bufferSize);
+  CLog::Log(LOGDEBUG, "CAESinkALSA::InitializeHW - Got: periodSize %lu, bufferSize %lu", periodSize, bufferSize);
 
   /* set the format parameters */
   format.m_sampleRate   = sampleRate;
@@ -614,7 +628,7 @@
   return TryDevice(name, pcmp, lconf);
 }
 
-bool CAESinkALSA::OpenPCMDevice(const std::string &name, const std::string &params, int channels, snd_pcm_t **pcmp, snd_config_t *lconf, bool preferDmixStereo)
+bool CAESinkALSA::OpenPCMDevice(const std::string &name, const std::string &params, int channels, snd_pcm_t **pcmp, snd_config_t *lconf)
 {
  /* Special name denoting surroundXX mangling. This is needed for some
    * devices for multichannel to work. */
@@ -642,12 +656,8 @@
           return true;
     }
 
-    /* If preferDmix is false, try non-dmix configuration first.
-     * This allows output with non-48000 sample rate if device is free */
-    if (!preferDmixStereo && TryDeviceWithParams("front" + openName, params, pcmp, lconf))
-      return true;
-
-    /* Try "sysdefault" and "default" (they provide dmix),
+    /* Try "sysdefault" and "default" (they provide dmix if needed, and route
+     * audio to all extra channels on subdeviced cards),
      * unless the selected devices is not DEV=0 of the card, in which case
      * "sysdefault" and "default" would point to another device.
      * "sysdefault" is a newish device name that won't be overwritten in case
@@ -666,8 +676,8 @@
         return true;
     }
 
-    /* Try non-dmix "front" */
-    if (preferDmixStereo && TryDeviceWithParams("front" + openName, params, pcmp, lconf))
+    /* Try "front" (no dmix, no audio in other channels on subdeviced cards) */
+    if (TryDeviceWithParams("front" + openName, params, pcmp, lconf))
       return true;
 
   }
@@ -886,7 +896,7 @@
 void CAESinkALSA::EnumerateDevice(AEDeviceInfoList &list, const std::string &device, const std::string &description, snd_config_t *config)
 {
   snd_pcm_t *pcmhandle = NULL;
-  if (!OpenPCMDevice(device, "", ALSA_MAX_CHANNELS, &pcmhandle, config, false))
+  if (!OpenPCMDevice(device, "", ALSA_MAX_CHANNELS, &pcmhandle, config))
     return;
 
   snd_pcm_info_t *pcminfo;
@@ -1036,7 +1046,7 @@
   {
     /* Reopen the device if needed on the special "surroundXX" cases */
     if (info.m_deviceType == AE_DEVTYPE_PCM && (i == 8 || i == 6 || i == 4))
-      OpenPCMDevice(device, "", i, &pcmhandle, config, false);
+      OpenPCMDevice(device, "", i, &pcmhandle, config);
 
     if (snd_pcm_hw_params_test_channels(pcmhandle, hwparams, i) >= 0)
     {
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h xbmc/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h	2013-02-19 17:48:55.441700206 +0000
+++ xbmc/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h	2013-04-05 17:09:10.500436679 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -41,7 +41,7 @@
 
   virtual bool Initialize  (AEAudioFormat &format, std::string &device);
   virtual void Deinitialize();
-  virtual bool IsCompatible(const AEAudioFormat format, const std::string device);
+  virtual bool IsCompatible(const AEAudioFormat format, const std::string &device);
 
   virtual void         Stop            ();
   virtual double       GetDelay        ();
@@ -77,7 +77,7 @@
   static void AppendParams(std::string &device, const std::string &params);
   static bool TryDevice(const std::string &name, snd_pcm_t **pcmp, snd_config_t *lconf);
   static bool TryDeviceWithParams(const std::string &name, const std::string &params, snd_pcm_t **pcmp, snd_config_t *lconf);
-  static bool OpenPCMDevice(const std::string &name, const std::string &params, int channels, snd_pcm_t **pcmp, snd_config_t *lconf, bool preferDmixStereo = false);
+  static bool OpenPCMDevice(const std::string &name, const std::string &params, int channels, snd_pcm_t **pcmp, snd_config_t *lconf);
 
   static AEDeviceType AEDeviceTypeFromName(const std::string &name);
   static std::string GetParamFromName(const std::string &name, const std::string &param);
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp xbmc/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp	2013-02-19 17:48:55.441700206 +0000
+++ xbmc/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp	2013-03-08 08:56:42.124480638 +0000
@@ -1,5 +1,5 @@
  /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -32,6 +32,8 @@
 #if defined(__ARM_NEON__)
 #include <arm_neon.h>
 #include "utils/CPUInfo.h"
+#include "android/activity/JNIThreading.h"
+
 // LGPLv2 from PulseAudio
 // float values from AE are pre-clamped so we do not need to clamp again here
 static void pa_sconv_s16le_from_f32ne_neon(unsigned n, const float32_t *a, int16_t *b)
@@ -72,6 +74,15 @@
 {
   m_sinkbuffer = NULL;
   m_alignedS16LE = NULL;
+  m_volume_changed = false;
+  m_min_frames = 0;
+  m_sink_frameSize = 0;
+  m_sinkbuffer_sec = 0.0;
+  m_sinkbuffer_sec_per_byte = 0.0;
+  m_draining = false;
+  m_audiotrackbuffer_sec = 0.0;
+  m_audiotrack_empty_sec = 0.0;
+  m_volume = 0.0;
 #if defined(HAS_AMLPLAYER)
   aml_cpufreq_limit(true);
 #endif
@@ -149,7 +160,7 @@
     _aligned_free(m_alignedS16LE), m_alignedS16LE = NULL;
 }
 
-bool CAESinkAUDIOTRACK::IsCompatible(const AEAudioFormat format, const std::string device)
+bool CAESinkAUDIOTRACK::IsCompatible(const AEAudioFormat format, const std::string &device)
 {
   return ((m_format.m_sampleRate    == format.m_sampleRate) &&
           (m_format.m_dataFormat    == format.m_dataFormat) &&
@@ -263,8 +274,7 @@
 {
   CLog::Log(LOGDEBUG, "CAESinkAUDIOTRACK::Process");
 
-  JNIEnv *jenv = NULL;
-  CXBMCApp::AttachCurrentThread(&jenv, NULL);
+  JNIEnv *jenv = xbmc_jnienv();
 
   jclass jcAudioTrack = jenv->FindClass("android/media/AudioTrack");
 
@@ -397,6 +407,4 @@
   jenv->DeleteLocalRef(jbuffer);
   jenv->DeleteLocalRef(joAudioTrack);
   jenv->DeleteLocalRef(jcAudioTrack);
-
-  CXBMCApp::DetachCurrentThread();
 }
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.h xbmc/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.h	2013-02-19 17:48:55.451700014 +0000
+++ xbmc/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.h	2013-03-08 08:56:42.134480452 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -34,7 +34,7 @@
 
   virtual bool Initialize(AEAudioFormat &format, std::string &device);
   virtual void Deinitialize();
-  virtual bool IsCompatible(const AEAudioFormat format, const std::string device);
+  virtual bool IsCompatible(const AEAudioFormat format, const std::string &device);
 
   virtual double       GetDelay        ();
   virtual double       GetCacheTime    ();
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.cpp xbmc/xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.cpp	2013-02-19 17:48:55.451700014 +0000
+++ xbmc/xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.cpp	2013-04-05 11:38:43.786816965 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -113,15 +113,19 @@
 }
 
 CAESinkDirectSound::CAESinkDirectSound() :
-  m_initialized   (false),
-  m_isDirtyDS     (false),
   m_pBuffer       (NULL ),
   m_pDSound       (NULL ),
-  m_BufferOffset  (0    ),
-  m_CacheLen      (0    ),
+  m_AvgBytesPerSec(0    ),
   m_dwChunkSize   (0    ),
+  m_dwFrameSize   (0    ),
   m_dwBufferLen   (0    ),
-  m_BufferTimeouts(0    )
+  m_BufferOffset  (0    ),
+  m_CacheLen      (0    ),
+  m_LastCacheCheck(0    ),
+  m_BufferTimeouts(0    ),
+  m_running       (false),
+  m_initialized   (false),
+  m_isDirtyDS     (false)
 {
   m_channelLayout.Reset();
 }
@@ -143,7 +147,7 @@
   std::string deviceFriendlyName;
   DirectSoundEnumerate(DSEnumCallback, &DSDeviceList);
 
-  for (std::list<DSDevice>::iterator itt = DSDeviceList.begin(); itt != DSDeviceList.end(); itt++)
+  for (std::list<DSDevice>::iterator itt = DSDeviceList.begin(); itt != DSDeviceList.end(); ++itt)
   {
     if ((*itt).lpGuid)
     {
@@ -322,7 +326,7 @@
   m_dwBufferLen = 0;
 }
 
-bool CAESinkDirectSound::IsCompatible(const AEAudioFormat format, const std::string device)
+bool CAESinkDirectSound::IsCompatible(const AEAudioFormat format, const std::string &device)
 {
   if (!m_initialized || m_isDirtyDS)
     return false;
@@ -471,7 +475,6 @@
   IMMDeviceEnumerator* pEnumerator = NULL;
   IMMDeviceCollection* pEnumDevices = NULL;
 
-  WAVEFORMATEX*          pwfxex = NULL;
   HRESULT                hr;
 
   /* See if we are on Windows XP */
@@ -484,7 +487,7 @@
     std::list<DSDevice> DSDeviceList;
     DirectSoundEnumerate(DSEnumCallback, &DSDeviceList);
 
-    for(std::list<DSDevice>::iterator itt = DSDeviceList.begin(); itt != DSDeviceList.end(); itt++)
+    for(std::list<DSDevice>::iterator itt = DSDeviceList.begin(); itt != DSDeviceList.end(); ++itt)
     {
       if (UuidToString((*itt).lpGuid, &cszGUID) != RPC_S_OK)
         continue;  /* could not convert GUID to string - skip device */
@@ -637,6 +640,7 @@
       {
         deviceInfoList.erase(itt);
         deviceInfoList.insert(deviceInfoList.begin(), devInfo);
+        break;
       }
     }
   }
@@ -749,8 +753,6 @@
 
 void CAESinkDirectSound::AEChannelsFromSpeakerMask(DWORD speakers)
 {
-  int j = 0;
-
   m_channelLayout.Reset();
 
   for (int i = 0; i < DS_SPEAKER_COUNT; i++)
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.h xbmc/xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.h	2013-02-19 17:48:55.451700014 +0000
+++ xbmc/xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.h	2013-03-08 08:56:42.524473160 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -36,7 +36,7 @@
 
   virtual bool Initialize  (AEAudioFormat &format, std::string &device);
   virtual void Deinitialize();
-  virtual bool IsCompatible(const AEAudioFormat format, const std::string device);
+  virtual bool IsCompatible(const AEAudioFormat format, const std::string &device);
 
   virtual void         Stop               ();
   virtual double       GetDelay           ();
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkNULL.cpp xbmc/xbmc/cores/AudioEngine/Sinks/AESinkNULL.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkNULL.cpp	2013-02-16 18:48:35.134457935 +0000
+++ xbmc/xbmc/cores/AudioEngine/Sinks/AESinkNULL.cpp	2013-03-08 08:56:42.524473160 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -20,21 +20,21 @@
 
 #include "system.h"
 
-#include "AESinkNULL.h"
 #include <stdint.h>
 #include <limits.h>
 
-#include "guilib/LocalizeStrings.h"
-#include "dialogs/GUIDialogKaiToast.h"
-
-#include "Utils/AEUtil.h"
-#include "utils/StdString.h"
+#include "AESinkNULL.h"
+#include "cores/AudioEngine/Utils/AEUtil.h"
 #include "utils/log.h"
-#include "utils/MathUtils.h"
-#include "utils/TimeUtils.h"
-#include "settings/GUISettings.h"
 
-CAESinkNULL::CAESinkNULL() {
+CAESinkNULL::CAESinkNULL()
+  : CThread("nullsink"),
+    m_draining(false),
+    m_sink_frameSize(0),
+    m_sinkbuffer_size(0),
+    m_sinkbuffer_level(0),
+    m_sinkbuffer_sec_per_byte(0)
+{
 }
 
 CAESinkNULL::~CAESinkNULL()
@@ -43,56 +43,138 @@
 
 bool CAESinkNULL::Initialize(AEAudioFormat &format, std::string &device)
 {
-  m_msPerFrame           = 1000.0f / format.m_sampleRate;
-  m_ts                   = 0;
-
+  // setup for a 250ms sink feed from SoftAE 
   format.m_dataFormat    = AE_IS_RAW(format.m_dataFormat) ? AE_FMT_S16NE : AE_FMT_FLOAT;
-  format.m_frames        = format.m_sampleRate / 1000 * 500; /* 500ms */
+  format.m_frames        = format.m_sampleRate / 1000 * 250;
   format.m_frameSamples  = format.m_channelLayout.Count();
   format.m_frameSize     = format.m_frameSamples * (CAEUtil::DataFormatToBits(format.m_dataFormat) >> 3);
+  m_format = format;
 
-#if 0
-  /* FIXME, CAUSES A DEADLOCK */
-  /* display failure notification */
-  CGUIDialogKaiToast::QueueNotification(
-    CGUIDialogKaiToast::Error,
-    g_localizeStrings.Get(34402),
-    g_localizeStrings.Get(34403),
-    TOAST_DISPLAY_TIME,
-    false
-  );
-#endif
+  // setup a pretend 500ms internal buffer
+  m_sink_frameSize = format.m_channelLayout.Count() * CAEUtil::DataFormatToBits(format.m_dataFormat) >> 3;
+  m_sinkbuffer_size = m_sink_frameSize * format.m_sampleRate / 2;
+  m_sinkbuffer_sec_per_byte = 1.0 / (double)(m_sink_frameSize * format.m_sampleRate);
+
+  m_draining = false;
+  m_wake.Reset();
+  m_inited.Reset();
+  Create();
+  if (!m_inited.WaitMSec(100))
+  {
+    while(!m_inited.WaitMSec(1))
+      Sleep(10);
+  }
 
   return true;
 }
 
 void CAESinkNULL::Deinitialize()
 {
+  // force m_bStop and set m_wake, if might be sleeping.
+  m_bStop = true;
+  StopThread();
 }
 
-bool CAESinkNULL::IsCompatible(const AEAudioFormat format, const std::string device)
+bool CAESinkNULL::IsCompatible(const AEAudioFormat format, const std::string &device)
 {
-  return false;
+  return ((m_format.m_sampleRate    == format.m_sampleRate) &&
+          (m_format.m_dataFormat    == format.m_dataFormat) &&
+          (m_format.m_channelLayout == format.m_channelLayout));
 }
 
 double CAESinkNULL::GetDelay()
 {
-  return std::max(0.0, (double)(m_ts - CurrentHostCounter()) / 1000000.0f);
+  double sinkbuffer_seconds_to_empty = m_sinkbuffer_sec_per_byte * (double)m_sinkbuffer_level;
+  return sinkbuffer_seconds_to_empty;
+}
+
+double CAESinkNULL::GetCacheTime()
+{
+  double sinkbuffer_seconds_to_empty = m_sinkbuffer_sec_per_byte * (double)m_sinkbuffer_level;
+  return sinkbuffer_seconds_to_empty;
+}
+
+double CAESinkNULL::GetCacheTotal()
+{
+  return m_sinkbuffer_sec_per_byte * (double)m_sinkbuffer_size;
 }
 
 unsigned int CAESinkNULL::AddPackets(uint8_t *data, unsigned int frames, bool hasAudio)
 {
-  float timeout = m_msPerFrame * frames;
-  m_ts = CurrentHostCounter() + MathUtils::round_int(timeout * 1000000.0f);
-  Sleep(MathUtils::round_int(timeout));
+  unsigned int max_frames = (m_sinkbuffer_size - m_sinkbuffer_level) / m_sink_frameSize;
+  if (frames > max_frames)
+    frames = max_frames;
+
+  if (hasAudio && frames)
+  {
+    m_sinkbuffer_level += frames * m_sink_frameSize;
+    m_wake.Set();
+  }
+  // AddPackets runs under a non-idled AE thread we must block or sleep.
+  // Trying to calc the optimal sleep is tricky so just a minimal sleep.
+  Sleep(10);
+
   return frames;
 }
 
 void CAESinkNULL::Drain()
 {
+  m_draining = true;
+  m_wake.Set();
 }
 
 void CAESinkNULL::EnumerateDevices (AEDeviceList &devices, bool passthrough)
 {
-  /* we never return any devices */
+  // we never return any devices
+}
+
+void CAESinkNULL::Process()
+{
+  CLog::Log(LOGDEBUG, "CAESinkNULL::Process");
+
+  // The object has been created and waiting to play,
+  m_inited.Set();
+  // yield to give other threads a chance to do some work.
+  Sleep(0);
+
+  SetPriority(THREAD_PRIORITY_ABOVE_NORMAL);
+  while (!m_bStop)
+  {
+    if (m_draining)
+    {
+      // TODO: is it correct to not take data at the appropriate rate while draining?
+      m_sinkbuffer_level = 0;
+      m_draining = false;
+    }
+
+    // pretend we have a 64k audio buffer
+    unsigned int min_buffer_size = 64 * 1024;
+    unsigned int read_bytes = m_sinkbuffer_level;
+    if (read_bytes > min_buffer_size)
+      read_bytes = min_buffer_size;
+
+    if (read_bytes > 0)
+    {
+      // drain it
+      m_sinkbuffer_level -= read_bytes;
+
+      // we MUST drain at the correct audio sample rate
+      // or the NULL sink will not work right. So calc
+      // an approximate sleep time.
+      int frames_written = read_bytes / m_sink_frameSize;
+      double empty_ms = 1000.0 * (double)frames_written / m_format.m_sampleRate;
+      #if defined(_LINUX)
+        usleep(empty_ms * 1000.0);
+      #else
+        Sleep((int)empty_ms);
+      #endif
+    }
+
+    if (m_sinkbuffer_level == 0)
+    {
+      // sleep this audio thread, we will get woken when we have audio data.
+      m_wake.WaitMSec(250);
+    }
+  }
+  SetPriority(THREAD_PRIORITY_NORMAL);
 }
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkNULL.h xbmc/xbmc/cores/AudioEngine/Sinks/AESinkNULL.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkNULL.h	2013-02-16 18:48:35.134457935 +0000
+++ xbmc/xbmc/cores/AudioEngine/Sinks/AESinkNULL.h	2013-03-08 08:56:42.524473160 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -21,10 +21,9 @@
 
 #include "system.h"
 
-#include "Interfaces/AESink.h"
-#include <stdint.h>
+#include "cores/AudioEngine/Interfaces/AESink.h"
 
-class CAESinkNULL : public IAESink
+class CAESinkNULL : public CThread, public IAESink
 {
 public:
   virtual const char *GetName() { return "NULL"; }
@@ -34,16 +33,24 @@
 
   virtual bool Initialize  (AEAudioFormat &format, std::string &device);
   virtual void Deinitialize();
-  virtual bool IsCompatible(const AEAudioFormat format, const std::string device);
+  virtual bool IsCompatible(const AEAudioFormat format, const std::string &device);
 
   virtual double       GetDelay        ();
-  virtual double       GetCacheTime    () { return 0.0; }
-  virtual double       GetCacheTotal   () { return 0.0; }
+  virtual double       GetCacheTime    ();
+  virtual double       GetCacheTotal   ();
   virtual unsigned int AddPackets      (uint8_t *data, unsigned int frames, bool hasAudio);
   virtual void         Drain           ();
 
   static void          EnumerateDevices(AEDeviceList &devices, bool passthrough);
 private:
-  int64_t m_ts;
-  float   m_msPerFrame;
+  virtual void         Process();
+
+  CEvent               m_wake;
+  CEvent               m_inited;
+  volatile bool        m_draining;
+  AEAudioFormat        m_format;
+  unsigned int         m_sink_frameSize;
+  unsigned int         m_sinkbuffer_size;  ///< total size of the buffer
+  unsigned int         m_sinkbuffer_level; ///< current level in the buffer
+  double               m_sinkbuffer_sec_per_byte;
 };
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkOSS.cpp xbmc/xbmc/cores/AudioEngine/Sinks/AESinkOSS.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkOSS.cpp	2013-02-19 17:48:55.451700014 +0000
+++ xbmc/xbmc/cores/AudioEngine/Sinks/AESinkOSS.cpp	2013-03-08 08:56:42.534472973 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -64,6 +64,7 @@
 
 CAESinkOSS::CAESinkOSS()
 {
+  m_fd = 0;
 }
 
 CAESinkOSS::~CAESinkOSS()
@@ -71,7 +72,7 @@
   Deinitialize();
 }
 
-std::string CAESinkOSS::GetDeviceUse(const AEAudioFormat format, const std::string device)
+std::string CAESinkOSS::GetDeviceUse(const AEAudioFormat format, const std::string &device)
 {
 #ifdef OSS4
   if (AE_IS_RAW(format.m_dataFormat))
@@ -287,7 +288,6 @@
     if (ioctl(m_fd, SNDCTL_DSP_GET_CHNORDER, &order) == -1)
     {
       CLog::Log(LOGWARNING, "CAESinkOSS::Initialize - Failed to get the channel order, assuming CHNORDER_NORMAL");
-      order = CHNORDER_NORMAL;
     }
   }
 #endif
@@ -367,7 +367,7 @@
   return info;
 }
 
-bool CAESinkOSS::IsCompatible(const AEAudioFormat format, const std::string device)
+bool CAESinkOSS::IsCompatible(const AEAudioFormat format, const std::string &device)
 {
   AEAudioFormat tmp  = format;
   tmp.m_channelLayout = GetChannelLayout(format);
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkOSS.h xbmc/xbmc/cores/AudioEngine/Sinks/AESinkOSS.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkOSS.h	2013-02-19 17:48:55.451700014 +0000
+++ xbmc/xbmc/cores/AudioEngine/Sinks/AESinkOSS.h	2013-03-08 08:56:42.534472973 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -35,7 +35,7 @@
 
   virtual bool Initialize  (AEAudioFormat &format, std::string &device);
   virtual void Deinitialize();
-  virtual bool IsCompatible(const AEAudioFormat format, const std::string device);
+  virtual bool IsCompatible(const AEAudioFormat format, const std::string &device);
 
   virtual void         Stop            ();
   virtual double       GetDelay        ();
@@ -51,6 +51,6 @@
   AEAudioFormat   m_format;
 
   CAEChannelInfo  GetChannelLayout(AEAudioFormat format);
-  std::string      GetDeviceUse(const AEAudioFormat format, const std::string device);
+  std::string      GetDeviceUse(const AEAudioFormat format, const std::string &device);
 };
 
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkProfiler.cpp xbmc/xbmc/cores/AudioEngine/Sinks/AESinkProfiler.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkProfiler.cpp	2013-02-16 18:48:35.134457935 +0000
+++ xbmc/xbmc/cores/AudioEngine/Sinks/AESinkProfiler.cpp	2013-03-08 08:56:42.534472973 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -56,7 +56,7 @@
 {
 }
 
-bool CAESinkProfiler::IsCompatible(const AEAudioFormat format, const std::string device)
+bool CAESinkProfiler::IsCompatible(const AEAudioFormat format, const std::string &device)
 {
   if (AE_IS_RAW(format.m_dataFormat))
     return false;
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkProfiler.h xbmc/xbmc/cores/AudioEngine/Sinks/AESinkProfiler.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkProfiler.h	2013-02-16 18:48:35.134457935 +0000
+++ xbmc/xbmc/cores/AudioEngine/Sinks/AESinkProfiler.h	2013-03-08 08:56:42.534472973 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -34,7 +34,7 @@
 
   virtual bool Initialize  (AEAudioFormat &format, std::string &device);
   virtual void Deinitialize();
-  virtual bool IsCompatible(const AEAudioFormat format, const std::string device);
+  virtual bool IsCompatible(const AEAudioFormat format, const std::string &device);
 
   virtual double       GetDelay        ();
   virtual double       GetCacheTime    () { return 0.0; }
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp xbmc/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp	2013-02-19 17:48:55.461699822 +0000
+++ xbmc/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp	2013-04-05 11:38:43.796816784 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -176,18 +176,22 @@
 }
 
 CAESinkWASAPI::CAESinkWASAPI() :
-  m_pAudioClient(NULL),
-  m_pRenderClient(NULL),
   m_needDataEvent(0),
   m_pDevice(NULL),
-  m_initialized(false),
-  m_running(false),
+  m_pAudioClient(NULL),
+  m_pRenderClient(NULL),
   m_encodedFormat(AE_FMT_INVALID),
   m_encodedChannels(0),
   m_encodedSampleRate(0),
+  sinkReqFormat(AE_FMT_INVALID),
+  sinkRetFormat(AE_FMT_INVALID),
+  m_running(false),
+  m_initialized(false),
+  m_isSuspended(false),
+  m_isDirty(false),
   m_uiBufferLen(0),
   m_avgTimeWaiting(50),
-  m_isDirty(false)
+  m_sinkLatency(0.0)
 {
   m_channelLayout.Reset();
 }
@@ -350,7 +354,7 @@
   m_initialized = false;
 }
 
-bool CAESinkWASAPI::IsCompatible(const AEAudioFormat format, const std::string device)
+bool CAESinkWASAPI::IsCompatible(const AEAudioFormat format, const std::string &device)
 {
   if (!m_initialized || m_isDirty)
     return false;
@@ -472,7 +476,7 @@
       return INT_MAX;
     }
     hr = m_pAudioClient->Start(); //start the audio driver running
-    if FAILED(hr)
+    if (FAILED(hr))
       CLog::Log(LOGERROR, __FUNCTION__": AudioClient Start Failed");
     m_running = true; //signal that we're processing frames
     return g_advancedSettings.m_streamSilence ? NumFramesRequested : 0U;
@@ -567,7 +571,6 @@
   CAEChannelInfo       deviceChannels;
 
   WAVEFORMATEXTENSIBLE wfxex = {0};
-  WAVEFORMATEX*        pwfxex = NULL;
   HRESULT              hr;
 
   hr = CoCreateInstance(CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL, IID_IMMDeviceEnumerator, (void**)&pEnumerator);
@@ -891,16 +894,7 @@
     if (format.m_dataFormat == AE_FMT_AC3 || format.m_dataFormat == AE_FMT_DTS)
     {
       wfxex.dwChannelMask          = bool (format.m_channelLayout.Count() == 2) ? KSAUDIO_SPEAKER_STEREO : KSAUDIO_SPEAKER_5POINT1;
-
-      if (format.m_dataFormat == AE_FMT_AC3)
-      {
         wfxex.SubFormat            = KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL;
-      }
-      else
-      {
-        wfxex.SubFormat            = KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL;
-       }
-
       wfxex.Format.wBitsPerSample       = 16;
       wfxex.Samples.wValidBitsPerSample = 16;
       wfxex.Format.nChannels            = (WORD)format.m_channelLayout.Count();
@@ -1168,6 +1162,12 @@
   /* second buffer is filled. Multiplying the returned 100ns intervals by 0.0000002 */
   /* is handles both the unit conversion and twin buffers.                          */
   hr = m_pAudioClient->GetStreamLatency(&hnsLatency);
+  if (FAILED(hr))
+  {
+    CLog::Log(LOGERROR, __FUNCTION__": GetStreamLatency Failed : %s", WASAPIErrToStr(hr));
+    return false;
+  }
+
   m_sinkLatency = hnsLatency * 0.0000002;
 
   CLog::Log(LOGINFO, __FUNCTION__": WASAPI Exclusive Mode Sink Initialized using: %s, %d, %d",
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.h xbmc/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.h	2013-02-19 17:48:55.461699822 +0000
+++ xbmc/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.h	2013-04-05 11:38:43.796816784 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
-*      Copyright (C) 2010-2012 Team XBMC
+*      Copyright (C) 2010-2013 Team XBMC
 *      http://www.xbmc.org
 *
 *  This Program is free software; you can redistribute it and/or modify
@@ -37,7 +37,7 @@
 
     virtual bool Initialize  (AEAudioFormat &format, std::string &device);
     virtual void Deinitialize();
-    virtual bool IsCompatible(const AEAudioFormat format, const std::string device);
+    virtual bool IsCompatible(const AEAudioFormat format, const std::string &device);
 
     virtual double       GetDelay                    ();
     virtual double       GetCacheTime                ();
@@ -49,9 +49,9 @@
 private:
     bool         InitializeExclusive(AEAudioFormat &format);
     void         AEChannelsFromSpeakerMask(DWORD speakers);
-    DWORD        SpeakerMaskFromAEChannels(const CAEChannelInfo &channels);
-    void         BuildWaveFormatExtensible(AEAudioFormat &format, WAVEFORMATEXTENSIBLE &wfxex);
-    void         BuildWaveFormatExtensibleIEC61397(AEAudioFormat &format, WAVEFORMATEXTENSIBLE_IEC61937 &wfxex);
+    static DWORD        SpeakerMaskFromAEChannels(const CAEChannelInfo &channels);
+    static void         BuildWaveFormatExtensible(AEAudioFormat &format, WAVEFORMATEXTENSIBLE &wfxex);
+    static void         BuildWaveFormatExtensibleIEC61397(AEAudioFormat &format, WAVEFORMATEXTENSIBLE_IEC61937 &wfxex);
 
     static const char  *WASAPIErrToStr(HRESULT err);
 
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEBitstreamPacker.cpp xbmc/xbmc/cores/AudioEngine/Utils/AEBitstreamPacker.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEBitstreamPacker.cpp	2013-02-16 18:48:35.144457736 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AEBitstreamPacker.cpp	2013-02-10 14:23:18.256520258 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEBitstreamPacker.h xbmc/xbmc/cores/AudioEngine/Utils/AEBitstreamPacker.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEBitstreamPacker.h	2013-02-16 18:48:35.144457736 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AEBitstreamPacker.h	2013-02-10 14:23:18.256520258 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEBuffer.cpp xbmc/xbmc/cores/AudioEngine/Utils/AEBuffer.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEBuffer.cpp	2013-02-16 18:48:35.144457736 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AEBuffer.cpp	2013-02-10 14:23:18.256520258 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEBuffer.h xbmc/xbmc/cores/AudioEngine/Utils/AEBuffer.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEBuffer.h	2013-02-16 18:48:35.144457736 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AEBuffer.h	2013-02-10 14:23:18.256520258 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEChannelInfo.cpp xbmc/xbmc/cores/AudioEngine/Utils/AEChannelInfo.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEChannelInfo.cpp	2013-02-16 18:48:35.144457736 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AEChannelInfo.cpp	2013-03-17 12:41:38.037315162 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -239,6 +239,7 @@
 
 const char* CAEChannelInfo::GetChName(const enum AEChannel ch)
 {
+  // Logical disjunction always evaluates to true: ch >= 0 || ch < 29.
   ASSERT(ch >= 0 || ch < AE_CH_MAX);
 
   static const char* channels[AE_CH_MAX] =
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEChannelInfo.h xbmc/xbmc/cores/AudioEngine/Utils/AEChannelInfo.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEChannelInfo.h	2013-02-16 18:48:35.154457538 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AEChannelInfo.h	2013-02-10 14:23:18.256520258 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEConvert.cpp xbmc/xbmc/cores/AudioEngine/Utils/AEConvert.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEConvert.cpp	2013-02-16 18:48:35.154457538 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AEConvert.cpp	2013-02-19 06:28:46.247532868 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -155,7 +155,7 @@
 {
   static const float mul = 1.0f / (INT16_MAX + 0.5f);
 
-#if defined(__ARM_NEON__) || defined(__VFP_FP__)
+#if defined(__ARM_NEON__) || (defined(__VFP_FP__) && !defined(__SOFTFP__))
   for (unsigned int i = 0; i < samples; i++)
   {
     __asm__ __volatile__ (
@@ -186,7 +186,7 @@
 {
   static const float mul = 1.0f / (INT16_MAX + 0.5f);
 
-#if defined(__ARM_NEON__) || defined(__VFP_FP__)
+#if defined(__ARM_NEON__) || (defined(__VFP_FP__) && !defined(__SOFTFP__))
   for (unsigned int i = 0; i < samples; i++)
   {
     __asm__ __volatile__ (
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEConvert.h xbmc/xbmc/cores/AudioEngine/Utils/AEConvert.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEConvert.h	2013-02-16 18:48:35.154457538 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AEConvert.h	2013-02-10 14:23:18.266520064 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEDeviceInfo.cpp xbmc/xbmc/cores/AudioEngine/Utils/AEDeviceInfo.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEDeviceInfo.cpp	2013-02-16 18:48:35.154457538 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AEDeviceInfo.cpp	2013-02-10 14:23:18.266520064 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2012 Team XBMC
+ *      Copyright (C) 2012-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEDeviceInfo.h xbmc/xbmc/cores/AudioEngine/Utils/AEDeviceInfo.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEDeviceInfo.h	2013-02-16 18:48:35.154457538 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AEDeviceInfo.h	2013-02-10 14:23:18.266520064 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2012 Team XBMC
+ *      Copyright (C) 2012-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEELDParser.cpp xbmc/xbmc/cores/AudioEngine/Utils/AEELDParser.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEELDParser.cpp	2013-02-16 18:48:35.154457538 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AEELDParser.cpp	2013-02-10 14:23:18.266520064 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2012 Team XBMC
+ *      Copyright (C) 2012-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEELDParser.h xbmc/xbmc/cores/AudioEngine/Utils/AEELDParser.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEELDParser.h	2013-02-16 18:48:35.154457538 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AEELDParser.h	2013-02-10 14:23:18.266520064 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2012 Team XBMC
+ *      Copyright (C) 2012-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AELimiter.cpp xbmc/xbmc/cores/AudioEngine/Utils/AELimiter.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AELimiter.cpp	2013-02-16 18:48:35.154457538 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AELimiter.cpp	2013-02-10 14:23:18.266520064 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AELimiter.h xbmc/xbmc/cores/AudioEngine/Utils/AELimiter.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AELimiter.h	2013-02-16 18:48:35.164457340 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AELimiter.h	2013-02-10 14:23:18.266520064 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEPackIEC61937.cpp xbmc/xbmc/cores/AudioEngine/Utils/AEPackIEC61937.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEPackIEC61937.cpp	2013-02-16 18:48:35.164457340 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AEPackIEC61937.cpp	2013-02-10 14:23:18.266520064 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEPackIEC61937.h xbmc/xbmc/cores/AudioEngine/Utils/AEPackIEC61937.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEPackIEC61937.h	2013-02-16 18:48:35.164457340 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AEPackIEC61937.h	2013-02-10 14:23:18.266520064 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AERemap.cpp xbmc/xbmc/cores/AudioEngine/Utils/AERemap.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AERemap.cpp	2013-02-16 18:48:35.164457340 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AERemap.cpp	2013-02-10 14:23:18.276519871 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AERemap.h xbmc/xbmc/cores/AudioEngine/Utils/AERemap.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AERemap.h	2013-02-16 18:48:35.164457340 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AERemap.h	2013-02-10 14:23:18.276519871 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AERingBuffer.h xbmc/xbmc/cores/AudioEngine/Utils/AERingBuffer.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AERingBuffer.h	2013-02-16 18:48:35.164457340 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AERingBuffer.h	2013-02-19 06:28:46.247532868 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -179,6 +179,7 @@
 #ifdef AE_RING_BUFFER_DEBUG
       CLog::Log(LOGDEBUG, "AERingBuffer: Reading from: %u size: %u space before: %u\n", m_iWritePos, size, space);
 #endif
+      if (dest)
       memcpy(dest, &(m_Buffer[m_iReadPos]), size);
       m_iReadPos+=size;
     }
@@ -190,8 +191,11 @@
 #ifdef AE_RING_BUFFER_DEBUG
       CLog::Log(LOGDEBUG, "AERingBuffer: Reading from (split) first: %u second: %u size: %u space before: %u\n", first, second, size, space);
 #endif
+      if (dest)
+      {
       memcpy(dest, &(m_Buffer[m_iReadPos]), first);
       memcpy(&dest[first], &(m_Buffer[0]), second);
+      }
       m_iReadPos = second;
     }
     //we can increase the read count now
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEStreamInfo.cpp xbmc/xbmc/cores/AudioEngine/Utils/AEStreamInfo.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEStreamInfo.cpp	2013-02-16 18:48:35.164457340 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AEStreamInfo.cpp	2013-03-17 12:41:38.037315162 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -102,7 +102,6 @@
     return 0;
   }
 
-  unsigned int consumed = 0;
   if (m_skipBytes)
   {
     unsigned int canSkip = std::min(size, m_skipBytes);
@@ -125,6 +124,7 @@
   }
   else
   {
+    unsigned int consumed = 0;
     unsigned int offset = 0;
     unsigned int room = sizeof(m_buffer) - m_bufferSize;
     while(1)
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEStreamInfo.h xbmc/xbmc/cores/AudioEngine/Utils/AEStreamInfo.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEStreamInfo.h	2013-02-16 18:48:35.174457142 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AEStreamInfo.h	2013-02-10 14:23:18.276519871 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEUtil.cpp xbmc/xbmc/cores/AudioEngine/Utils/AEUtil.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEUtil.cpp	2013-02-16 18:48:35.174457142 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AEUtil.cpp	2013-02-10 14:23:18.286519677 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEUtil.h xbmc/xbmc/cores/AudioEngine/Utils/AEUtil.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEUtil.h	2013-02-19 17:48:55.461699822 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AEUtil.h	2013-02-10 14:23:18.286519677 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEWAVLoader.cpp xbmc/xbmc/cores/AudioEngine/Utils/AEWAVLoader.cpp
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEWAVLoader.cpp	2013-02-16 18:48:35.174457142 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AEWAVLoader.cpp	2013-02-10 14:23:18.286519677 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEWAVLoader.h xbmc/xbmc/cores/AudioEngine/Utils/AEWAVLoader.h
--- xbmcfrodo/xbmc/cores/AudioEngine/Utils/AEWAVLoader.h	2013-02-16 18:48:35.174457142 +0000
+++ xbmc/xbmc/cores/AudioEngine/Utils/AEWAVLoader.h	2013-02-10 14:23:18.286519677 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/DllLoader-linux.cpp xbmc/xbmc/cores/DllLoader/DllLoader-linux.cpp
--- xbmcfrodo/xbmc/cores/DllLoader/DllLoader-linux.cpp	2013-02-16 18:48:35.174457142 +0000
+++ xbmc/xbmc/cores/DllLoader/DllLoader-linux.cpp	2013-04-05 11:38:43.796816784 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -22,7 +22,22 @@
 #include "DllLoader.h"
 #include "DllLoaderContainer.h"
 
-CoffLoader::CoffLoader()
+CoffLoader::CoffLoader() :
+  hModule           (NULL ),
+  CoffFileHeader    (NULL ),
+  OptionHeader      (NULL ),
+  WindowsHeader     (NULL ),
+  Directory         (NULL ),
+  SectionHeader     (NULL ),
+  SymTable          (NULL ),
+  StringTable       (NULL ),
+  SectionData       (NULL ),
+  EntryAddress      (0    ),
+  NumberOfSymbols   (0    ),
+  SizeOfStringTable (0    ),
+  NumOfDirectories  (0    ),
+  NumOfSections     (0    ),
+  FileHeaderOffset  (0    )
 {
 }
 
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/DllLoader.cpp xbmc/xbmc/cores/DllLoader/DllLoader.cpp
--- xbmcfrodo/xbmc/cores/DllLoader/DllLoader.cpp	2013-02-16 18:48:35.184456944 +0000
+++ xbmc/xbmc/cores/DllLoader/DllLoader.cpp	2013-04-05 11:38:43.796816784 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -32,11 +32,6 @@
 #define fopen_utf8 fopen
 #endif
 
-typedef struct _UNICODE_STRING {
-  USHORT  Length;
-  USHORT  MaximumLength;
-  PWSTR  Buffer;
-} UNICODE_STRING, *PUNICODE_STRING;
 #include "commons/Exception.h"
 
 #define DLL_PROCESS_DETACH   0
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/DllLoader.h xbmc/xbmc/cores/DllLoader/DllLoader.h
--- xbmcfrodo/xbmc/cores/DllLoader/DllLoader.h	2013-02-16 18:48:35.184456944 +0000
+++ xbmc/xbmc/cores/DllLoader/DllLoader.h	2013-02-10 14:23:18.296519482 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/DllLoaderContainer.cpp xbmc/xbmc/cores/DllLoader/DllLoaderContainer.cpp
--- xbmcfrodo/xbmc/cores/DllLoader/DllLoaderContainer.cpp	2013-02-19 17:48:55.461699822 +0000
+++ xbmc/xbmc/cores/DllLoader/DllLoaderContainer.cpp	2013-02-10 14:23:18.296519482 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/DllLoaderContainer.h xbmc/xbmc/cores/DllLoader/DllLoaderContainer.h
--- xbmcfrodo/xbmc/cores/DllLoader/DllLoaderContainer.h	2013-02-16 18:48:35.184456944 +0000
+++ xbmc/xbmc/cores/DllLoader/DllLoaderContainer.h	2013-02-10 14:23:18.296519482 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/LibraryLoader.cpp xbmc/xbmc/cores/DllLoader/LibraryLoader.cpp
--- xbmcfrodo/xbmc/cores/DllLoader/LibraryLoader.cpp	2013-02-16 18:48:35.184456944 +0000
+++ xbmc/xbmc/cores/DllLoader/LibraryLoader.cpp	2013-02-10 14:23:18.296519482 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/LibraryLoader.h xbmc/xbmc/cores/DllLoader/LibraryLoader.h
--- xbmcfrodo/xbmc/cores/DllLoader/LibraryLoader.h	2013-02-16 18:48:35.184456944 +0000
+++ xbmc/xbmc/cores/DllLoader/LibraryLoader.h	2013-04-05 11:38:43.796816784 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -50,6 +50,8 @@
   int GetRef();
 
 private:
+  LibraryLoader(const LibraryLoader&);
+  LibraryLoader& operator=(const LibraryLoader&);
   char* m_sFileName;
   char* m_sPath;
   int   m_iRefCount;
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/SoLoader.cpp xbmc/xbmc/cores/DllLoader/SoLoader.cpp
--- xbmcfrodo/xbmc/cores/DllLoader/SoLoader.cpp	2013-02-16 18:48:35.184456944 +0000
+++ xbmc/xbmc/cores/DllLoader/SoLoader.cpp	2013-02-10 14:23:18.296519482 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/SoLoader.h xbmc/xbmc/cores/DllLoader/SoLoader.h
--- xbmcfrodo/xbmc/cores/DllLoader/SoLoader.h	2013-02-16 18:48:35.184456944 +0000
+++ xbmc/xbmc/cores/DllLoader/SoLoader.h	2013-02-10 14:23:18.296519482 +0000
@@ -2,7 +2,7 @@
 #define SO_LOADER
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/Win32DllLoader.cpp xbmc/xbmc/cores/DllLoader/Win32DllLoader.cpp
--- xbmcfrodo/xbmc/cores/DllLoader/Win32DllLoader.cpp	2013-02-16 18:48:35.194456745 +0000
+++ xbmc/xbmc/cores/DllLoader/Win32DllLoader.cpp	2013-04-05 11:38:43.806816604 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -392,7 +392,6 @@
 
 bool Win32DllLoader::ResolveImport(const char *dllName, const char *functionName, void **fixup)
 {
-  char *dll = GetName();
   return FunctionNeedsWrapping(win32_exports, functionName, fixup);
 }
 
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/Win32DllLoader.h xbmc/xbmc/cores/DllLoader/Win32DllLoader.h
--- xbmcfrodo/xbmc/cores/DllLoader/Win32DllLoader.h	2013-02-16 18:48:35.194456745 +0000
+++ xbmc/xbmc/cores/DllLoader/Win32DllLoader.h	2013-02-10 14:23:18.306519287 +0000
@@ -3,7 +3,7 @@
 #define _WIN32DLLLOADER_H_
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/coff.cpp xbmc/xbmc/cores/DllLoader/coff.cpp
--- xbmcfrodo/xbmc/cores/DllLoader/coff.cpp	2013-02-16 18:48:35.194456745 +0000
+++ xbmc/xbmc/cores/DllLoader/coff.cpp	2013-04-05 11:38:43.806816604 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -69,6 +69,7 @@
   NumOfDirectories = 0;
   NumOfSections = 0;
   FileHeaderOffset = 0;
+  EntryAddress = 0;
   hModule = NULL;
 }
 
@@ -486,7 +487,6 @@
 
 char *CoffLoader::GetSymbolName(SymbolTable_t *sym)
 {
-  static char shortname[9];
   __int64 index = sym->Name.Offset;
   int low = (int)(index & 0xFFFFFFFF);
   int high = (int)((index >> 32) & 0xFFFFFFFF);
@@ -497,6 +497,7 @@
   }
   else
   {
+    static char shortname[9];
     memset(shortname, 0, 9);
     strncpy(shortname, (char *)sym->Name.ShortName, 8);
     return shortname;
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/coff.h xbmc/xbmc/cores/DllLoader/coff.h
--- xbmcfrodo/xbmc/cores/DllLoader/coff.h	2013-02-16 18:48:35.194456745 +0000
+++ xbmc/xbmc/cores/DllLoader/coff.h	2013-02-10 14:23:18.306519287 +0000
@@ -5,7 +5,7 @@
 #include "system.h"
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/coffldr.h xbmc/xbmc/cores/DllLoader/coffldr.h
--- xbmcfrodo/xbmc/cores/DllLoader/coffldr.h	2013-02-16 18:48:35.194456745 +0000
+++ xbmc/xbmc/cores/DllLoader/coffldr.h	2013-04-05 11:38:43.806816604 +0000
@@ -2,7 +2,7 @@
 #define __COFFLDR_H_
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -78,10 +78,10 @@
   int FileHeaderOffset;
 
   // Members for printing the structures
-  void PrintFileHeader(COFF_FileHeader_t *FileHeader);
-  void PrintWindowsHeader(WindowsHeader_t *WinHdr);
-  void PrintOptionHeader(OptionHeader_t *OptHdr);
-  void PrintSection(SectionHeader_t *ScnHdr, char *data);
+  static void PrintFileHeader(COFF_FileHeader_t *FileHeader);
+  static void PrintWindowsHeader(WindowsHeader_t *WinHdr);
+  static void PrintOptionHeader(OptionHeader_t *OptHdr);
+  static void PrintSection(SectionHeader_t *ScnHdr, char *data);
   void PrintStringTable(void);
   void PrintSymbolTable(void);
 
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/dll.cpp xbmc/xbmc/cores/DllLoader/dll.cpp
--- xbmcfrodo/xbmc/cores/DllLoader/dll.cpp	2013-02-16 18:48:35.194456745 +0000
+++ xbmc/xbmc/cores/DllLoader/dll.cpp	2013-02-10 14:23:18.306519287 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/dll.h xbmc/xbmc/cores/DllLoader/dll.h
--- xbmcfrodo/xbmc/cores/DllLoader/dll.h	2013-02-16 18:48:35.204456546 +0000
+++ xbmc/xbmc/cores/DllLoader/dll.h	2013-02-10 14:23:18.316519093 +0000
@@ -4,7 +4,7 @@
 #include "system.h"
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/dll_tracker.cpp xbmc/xbmc/cores/DllLoader/dll_tracker.cpp
--- xbmcfrodo/xbmc/cores/DllLoader/dll_tracker.cpp	2013-02-16 18:48:35.204456546 +0000
+++ xbmc/xbmc/cores/DllLoader/dll_tracker.cpp	2013-04-05 11:38:43.806816604 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -65,14 +65,14 @@
       }
       // free all functions which where created at the time we loaded the dll
 	    DummyListIter dit = (*it)->dummyList.begin();
-	    while (dit != (*it)->dummyList.end()) { free((void*)*dit); dit++;	}
+	    while (dit != (*it)->dummyList.end()) { free((void*)*dit); ++dit;	}
 	    (*it)->dummyList.clear();
 	
       delete (*it);
       it = g_trackedDlls.erase(it);
     }
     else
-      it++;
+      ++it;
   }
 }
 
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/dll_tracker.h xbmc/xbmc/cores/DllLoader/dll_tracker.h
--- xbmcfrodo/xbmc/cores/DllLoader/dll_tracker.h	2013-02-16 18:48:35.204456546 +0000
+++ xbmc/xbmc/cores/DllLoader/dll_tracker.h	2013-02-10 14:23:18.316519093 +0000
@@ -2,7 +2,7 @@
 #define _DLL_TRACKER_H_
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/dll_tracker_file.cpp xbmc/xbmc/cores/DllLoader/dll_tracker_file.cpp
--- xbmcfrodo/xbmc/cores/DllLoader/dll_tracker_file.cpp	2013-02-16 18:48:35.204456546 +0000
+++ xbmc/xbmc/cores/DllLoader/dll_tracker_file.cpp	2013-02-10 14:23:18.316519093 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/dll_tracker_file.h xbmc/xbmc/cores/DllLoader/dll_tracker_file.h
--- xbmcfrodo/xbmc/cores/DllLoader/dll_tracker_file.h	2013-02-16 18:48:35.204456546 +0000
+++ xbmc/xbmc/cores/DllLoader/dll_tracker_file.h	2013-02-10 14:23:18.316519093 +0000
@@ -2,7 +2,7 @@
 #define _DLL_TRACKER_FILE
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/dll_tracker_library.cpp xbmc/xbmc/cores/DllLoader/dll_tracker_library.cpp
--- xbmcfrodo/xbmc/cores/DllLoader/dll_tracker_library.cpp	2013-02-16 18:48:35.204456546 +0000
+++ xbmc/xbmc/cores/DllLoader/dll_tracker_library.cpp	2013-02-10 14:23:18.316519093 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/dll_tracker_library.h xbmc/xbmc/cores/DllLoader/dll_tracker_library.h
--- xbmcfrodo/xbmc/cores/DllLoader/dll_tracker_library.h	2013-02-16 18:48:35.204456546 +0000
+++ xbmc/xbmc/cores/DllLoader/dll_tracker_library.h	2013-02-10 14:23:18.316519093 +0000
@@ -2,7 +2,7 @@
 #define _DLL_TRACKER_LIBRARY
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/dll_util.cpp xbmc/xbmc/cores/DllLoader/dll_util.cpp
--- xbmcfrodo/xbmc/cores/DllLoader/dll_util.cpp	2013-02-16 18:48:35.204456546 +0000
+++ xbmc/xbmc/cores/DllLoader/dll_util.cpp	2013-02-10 14:23:18.316519093 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/dll_util.h xbmc/xbmc/cores/DllLoader/dll_util.h
--- xbmcfrodo/xbmc/cores/DllLoader/dll_util.h	2013-02-16 18:48:35.204456546 +0000
+++ xbmc/xbmc/cores/DllLoader/dll_util.h	2013-02-10 14:23:18.326518900 +0000
@@ -4,7 +4,7 @@
 #include <stdint.h>
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/exports/emu_dummy.cpp xbmc/xbmc/cores/DllLoader/exports/emu_dummy.cpp
--- xbmcfrodo/xbmc/cores/DllLoader/exports/emu_dummy.cpp	2013-02-16 18:48:35.214456348 +0000
+++ xbmc/xbmc/cores/DllLoader/exports/emu_dummy.cpp	2013-02-10 14:23:18.326518900 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/exports/emu_dummy.h xbmc/xbmc/cores/DllLoader/exports/emu_dummy.h
--- xbmcfrodo/xbmc/cores/DllLoader/exports/emu_dummy.h	2013-02-16 18:48:35.214456348 +0000
+++ xbmc/xbmc/cores/DllLoader/exports/emu_dummy.h	2013-02-10 14:23:18.326518900 +0000
@@ -2,7 +2,7 @@
 #define _EMU_DUMMY_H
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/exports/emu_kernel32.cpp xbmc/xbmc/cores/DllLoader/exports/emu_kernel32.cpp
--- xbmcfrodo/xbmc/cores/DllLoader/exports/emu_kernel32.cpp	2013-02-16 18:48:35.214456348 +0000
+++ xbmc/xbmc/cores/DllLoader/exports/emu_kernel32.cpp	2013-04-05 11:38:43.806816604 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -218,13 +218,6 @@
 #endif
 }
 
-struct SThreadWrapper
-{
-  LPTHREAD_START_ROUTINE lpStartAddress;
-  LPVOID lpParameter;
-  PCHAR lpDLL;
-};
-
 extern "C" void WINAPI dllSleep(DWORD dwTime)
 {
   return ::Sleep(dwTime);
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/exports/emu_kernel32.h xbmc/xbmc/cores/DllLoader/exports/emu_kernel32.h
--- xbmcfrodo/xbmc/cores/DllLoader/exports/emu_kernel32.h	2013-02-16 18:48:35.214456348 +0000
+++ xbmc/xbmc/cores/DllLoader/exports/emu_kernel32.h	2013-02-10 14:23:18.326518900 +0000
@@ -2,7 +2,7 @@
 #define _EMU_KERNEL32_H_
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/exports/emu_msvcrt.cpp xbmc/xbmc/cores/DllLoader/exports/emu_msvcrt.cpp
--- xbmcfrodo/xbmc/cores/DllLoader/exports/emu_msvcrt.cpp	2013-02-16 18:48:35.224456151 +0000
+++ xbmc/xbmc/cores/DllLoader/exports/emu_msvcrt.cpp	2013-04-05 11:38:43.816816425 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -104,12 +104,6 @@
 extern void update_cache_dialog(const char* tmp);
 #endif
 
-struct _env
-{
-  const char* name;
-  char* value;
-};
-
 #define EMU_MAX_ENVIRONMENT_ITEMS 100
 static char *dll__environ_imp[EMU_MAX_ENVIRONMENT_ITEMS + 1];
 extern "C" char **dll__environ;
@@ -208,7 +202,8 @@
   // Use a proxy, if the GUI was configured as such
   if (g_guiSettings.GetBool("network.usehttpproxy")
       && !g_guiSettings.GetString("network.httpproxyserver").empty()
-      && !g_guiSettings.GetString("network.httpproxyport").empty())
+      && !g_guiSettings.GetString("network.httpproxyport").empty()
+      && g_guiSettings.GetInt("network.httpproxytype") == 0)
   {
     CStdString strProxy;
     if (g_guiSettings.GetString("network.httpproxyusername") &&
@@ -970,7 +965,7 @@
 
     // locate next free directory
     int iDirSlot=0;
-    while ((vecDirsOpen[iDirSlot].curr_index != -1) && (iDirSlot<MAX_OPEN_DIRS)) iDirSlot++;
+    while ((iDirSlot<MAX_OPEN_DIRS) && (vecDirsOpen[iDirSlot].curr_index != -1)) iDirSlot++;
     if (iDirSlot >= MAX_OPEN_DIRS)
     {
       CLog::Log(LOGDEBUG, "Dll: Max open dirs reached");
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/exports/emu_msvcrt.h xbmc/xbmc/cores/DllLoader/exports/emu_msvcrt.h
--- xbmcfrodo/xbmc/cores/DllLoader/exports/emu_msvcrt.h	2013-02-16 18:48:35.224456151 +0000
+++ xbmc/xbmc/cores/DllLoader/exports/emu_msvcrt.h	2013-02-10 14:23:18.336518706 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/exports/emu_socket/emu_socket.h xbmc/xbmc/cores/DllLoader/exports/emu_socket/emu_socket.h
--- xbmcfrodo/xbmc/cores/DllLoader/exports/emu_socket/emu_socket.h	2013-02-16 18:48:35.224456151 +0000
+++ xbmc/xbmc/cores/DllLoader/exports/emu_socket/emu_socket.h	2013-02-10 14:23:18.336518706 +0000
@@ -2,7 +2,7 @@
 #define _EMU_SOCKET_EMU_SOCKET_H_
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/exports/util/EmuFileWrapper.cpp xbmc/xbmc/cores/DllLoader/exports/util/EmuFileWrapper.cpp
--- xbmcfrodo/xbmc/cores/DllLoader/exports/util/EmuFileWrapper.cpp	2013-02-16 18:48:35.244455754 +0000
+++ xbmc/xbmc/cores/DllLoader/exports/util/EmuFileWrapper.cpp	2013-02-10 14:23:18.336518706 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/exports/util/EmuFileWrapper.h xbmc/xbmc/cores/DllLoader/exports/util/EmuFileWrapper.h
--- xbmcfrodo/xbmc/cores/DllLoader/exports/util/EmuFileWrapper.h	2013-02-16 18:48:35.244455754 +0000
+++ xbmc/xbmc/cores/DllLoader/exports/util/EmuFileWrapper.h	2013-04-05 11:38:43.816816425 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -76,7 +76,6 @@
 private:
   EmuFileObject m_files[MAX_EMULATED_FILES];
   CCriticalSection m_criticalSection;
-  bool m_initialized;
 };
 
 extern CEmuFileWrapper g_emuFileWrapper;
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/exports/wrapper.c xbmc/xbmc/cores/DllLoader/exports/wrapper.c
--- xbmcfrodo/xbmc/cores/DllLoader/exports/wrapper.c	2013-02-16 18:48:35.244455754 +0000
+++ xbmc/xbmc/cores/DllLoader/exports/wrapper.c	2013-02-10 14:23:18.346518511 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/ldt_keeper.c xbmc/xbmc/cores/DllLoader/ldt_keeper.c
--- xbmcfrodo/xbmc/cores/DllLoader/ldt_keeper.c	2013-02-16 18:48:35.254455555 +0000
+++ xbmc/xbmc/cores/DllLoader/ldt_keeper.c	2013-04-05 11:38:43.816816425 +0000
@@ -100,7 +100,6 @@
   unsigned int  read_exec_only:1;
   unsigned int  limit_in_pages:1;
   unsigned int  seg_not_present:1;
-  unsigned int  useable:1;
 };
 
 #define MODIFY_LDT_CONTENTS_DATA        0
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/mmap_anon.c xbmc/xbmc/cores/DllLoader/mmap_anon.c
--- xbmcfrodo/xbmc/cores/DllLoader/mmap_anon.c	2013-02-16 18:48:35.254455555 +0000
+++ xbmc/xbmc/cores/DllLoader/mmap_anon.c	2013-02-10 14:23:18.346518511 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DllLoader/mmap_anon.h xbmc/xbmc/cores/DllLoader/mmap_anon.h
--- xbmcfrodo/xbmc/cores/DllLoader/mmap_anon.h	2013-02-16 18:48:35.254455555 +0000
+++ xbmc/xbmc/cores/DllLoader/mmap_anon.h	2013-02-10 14:23:18.346518511 +0000
@@ -2,7 +2,7 @@
 #define _OSDEP_MMAP_ANON_H_
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DummyVideoPlayer.cpp xbmc/xbmc/cores/DummyVideoPlayer.cpp
--- xbmcfrodo/xbmc/cores/DummyVideoPlayer.cpp	2013-02-16 18:48:35.254455555 +0000
+++ xbmc/xbmc/cores/DummyVideoPlayer.cpp	2013-02-10 14:23:18.346518511 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/DummyVideoPlayer.h xbmc/xbmc/cores/DummyVideoPlayer.h
--- xbmcfrodo/xbmc/cores/DummyVideoPlayer.h	2013-02-16 18:48:35.254455555 +0000
+++ xbmc/xbmc/cores/DummyVideoPlayer.h	2013-02-10 14:23:18.346518511 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/ExternalPlayer/ExternalPlayer.cpp xbmc/xbmc/cores/ExternalPlayer/ExternalPlayer.cpp
--- xbmcfrodo/xbmc/cores/ExternalPlayer/ExternalPlayer.cpp	2013-02-16 18:48:35.254455555 +0000
+++ xbmc/xbmc/cores/ExternalPlayer/ExternalPlayer.cpp	2013-04-05 11:38:43.826816245 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -39,6 +39,7 @@
 #include "utils/log.h"
 #include "cores/AudioEngine/AEFactory.h"
 #if defined(_WIN32)
+  #include "utils/CharsetConverter.h"
   #include "Windows.h"
   #ifdef HAS_IRSERVERSUITE
     #include "input/windows/IRServerSuite.h"
@@ -47,6 +48,9 @@
 #if defined(HAS_LIRC)
   #include "input/linux/LIRC.h"
 #endif
+#if defined(TARGET_ANDROID)
+  #include "android/activity/XBMCApp.h"
+#endif
 
 // If the process ends in less than this time (ms), we assume it's a launcher
 // and wait for manual intervention before continuing
@@ -82,6 +86,10 @@
   m_playOneStackItem = false;
 
   m_dialog = NULL;
+  m_hwndXbmc = NULL;
+  m_xPos = 0;
+  m_yPos = 0;
+
 
 #if defined(_WIN32)
   memset(&m_processInfo, 0, sizeof(m_processInfo));
@@ -311,6 +319,8 @@
   BOOL ret = TRUE;
 #if defined(_WIN32)
   ret = ExecuteAppW32(strFName.c_str(),strFArgs.c_str());
+#elif defined(TARGET_ANDROID)
+  ret = ExecuteAppAndroid(m_filename.c_str(), mainFile.c_str());
 #elif defined(_LINUX) || defined(TARGET_DARWIN_OSX)
   ret = ExecuteAppLinux(strFArgs.c_str());
 #endif
@@ -443,7 +453,7 @@
 }
 #endif
 
-#if defined(_LINUX) || defined(TARGET_DARWIN_OSX)
+#if !defined(TARGET_ANDROID) && (defined(_LINUX) || defined(TARGET_DARWIN_OSX))
 BOOL CExternalPlayer::ExecuteAppLinux(const char* strSwitches)
 {
   CLog::Log(LOGNOTICE, "%s: %s", __FUNCTION__, strSwitches);
@@ -462,6 +472,22 @@
 
   if (ret != 0)
   {
+    CLog::Log(LOGNOTICE, "%s: Failure: %d", __FUNCTION__, ret);
+  }
+
+  return ret == 0;
+}
+#endif
+
+#if defined(TARGET_ANDROID)
+BOOL CExternalPlayer::ExecuteAppAndroid(const char* strSwitches,const char* strPath)
+{
+  CLog::Log(LOGNOTICE, "%s: %s", __FUNCTION__, strSwitches);
+
+  int ret = CXBMCApp::StartActivity(strSwitches, "android.intent.action.VIEW", "video/*", strPath);
+
+  if (ret != 0)
+  {
     CLog::Log(LOGNOTICE, "%s: Failure: %d", __FUNCTION__, ret);
   }
 
diff -ENwbur xbmcfrodo/xbmc/cores/ExternalPlayer/ExternalPlayer.h xbmc/xbmc/cores/ExternalPlayer/ExternalPlayer.h
--- xbmcfrodo/xbmc/cores/ExternalPlayer/ExternalPlayer.h	2013-02-16 18:48:35.264455357 +0000
+++ xbmc/xbmc/cores/ExternalPlayer/ExternalPlayer.h	2013-02-10 14:23:18.356518316 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -82,6 +82,8 @@
 #if defined(_WIN32)
   virtual BOOL ExecuteAppW32(const char* strPath, const char* strSwitches);
   //static void CALLBACK AppFinished(void* closure, BOOLEAN TimerOrWaitFired);
+#elif defined(TARGET_ANDROID)
+  virtual BOOL ExecuteAppAndroid(const char* strSwitches,const char* strPath);
 #elif defined(_LINUX)
   virtual BOOL ExecuteAppLinux(const char* strSwitches);
 #endif
diff -ENwbur xbmcfrodo/xbmc/cores/IAudioCallback.h xbmc/xbmc/cores/IAudioCallback.h
--- xbmcfrodo/xbmc/cores/IAudioCallback.h	2013-02-16 18:48:35.264455357 +0000
+++ xbmc/xbmc/cores/IAudioCallback.h	2013-02-10 14:23:18.356518316 +0000
@@ -6,7 +6,7 @@
 #define AFX_IAUDIOCALLBACK_H__5A6AC7CF_C60E_45B9_8113_599F036FBBF8__INCLUDED_
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/IPlayer.h xbmc/xbmc/cores/IPlayer.h
--- xbmcfrodo/xbmc/cores/IPlayer.h	2013-02-16 18:48:35.264455357 +0000
+++ xbmc/xbmc/cores/IPlayer.h	2013-03-17 12:41:38.037315162 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -22,7 +22,9 @@
 
 #include "system.h" // until we get sane int types used here
 #include "IAudioCallback.h"
+#include "IPlayerCallback.h"
 #include "utils/StdString.h"
+#include "guilib/Geometry.h"
 
 struct TextCacheStruct_t;
 class TiXmlElement;
@@ -34,21 +36,6 @@
   class CPVRChannel;
 }
 
-class IPlayerCallback
-{
-public:
-  virtual ~IPlayerCallback() {}
-  virtual void OnPlayBackEnded() = 0;
-  virtual void OnPlayBackStarted() = 0;
-  virtual void OnPlayBackPaused() {};
-  virtual void OnPlayBackResumed() {};
-  virtual void OnPlayBackStopped() = 0;
-  virtual void OnQueueNextItem() = 0;
-  virtual void OnPlayBackSeek(int iTime, int seekOffset) {};
-  virtual void OnPlayBackSeekChapter(int iChapter) {};
-  virtual void OnPlayBackSpeedChanged(int iSpeed) {};
-};
-
 class CPlayerOptions
 {
 public:
@@ -69,7 +56,6 @@
 };
 
 class CFileItem;
-class CRect;
 
 enum IPlayerAudioCapabilities
 {
@@ -89,6 +75,44 @@
   IPC_SUBS_OFFSET
 };
 
+struct SPlayerAudioStreamInfo
+{
+  int bitrate;
+  int channels;
+  std::string language;
+  std::string name;
+  std::string audioCodecName;
+
+  SPlayerAudioStreamInfo()
+  {
+    bitrate = 0;
+    channels = 0;
+  }
+};
+
+struct SPlayerSubtitleStreamInfo
+{
+  std::string language;
+  std::string name;
+};
+
+struct SPlayerVideoStreamInfo
+{
+  int bitrate;
+  float videoAspectRatio;
+  std::string language;
+  std::string name;
+  std::string videoCodecName;
+  CRect SrcRect;
+  CRect DestRect;
+
+  SPlayerVideoStreamInfo()
+  {
+    bitrate = 0;
+    videoAspectRatio = 1.0f;
+  }
+};
+
 class IPlayer
 {
 public:
@@ -114,16 +138,14 @@
   virtual void SeekPercentage(float fPercent = 0){}
   virtual float GetPercentage(){ return 0;}
   virtual float GetCachePercentage(){ return 0;}
-  virtual bool ControlsVolume(){ return false;}
   virtual void SetMute(bool bOnOff){}
   virtual void SetVolume(float volume){}
+  virtual bool ControlsVolume(){ return false;}
   virtual void SetDynamicRangeCompression(long drc){}
   virtual void GetAudioInfo( CStdString& strAudioInfo) = 0;
   virtual void GetVideoInfo( CStdString& strVideoInfo) = 0;
   virtual void GetGeneralInfo( CStdString& strVideoInfo) = 0;
   virtual void Update(bool bPauseDrawing = false) = 0;
-  virtual void GetVideoRect(CRect& SrcRect, CRect& DestRect) {}
-  virtual void GetVideoAspectRatio(float& fAR) { fAR = 1.0f; }
   virtual bool CanRecord() { return false;};
   virtual bool IsRecording() { return false;};
   virtual bool Record(bool bOnOff) { return false;};
@@ -135,19 +157,16 @@
   virtual float GetSubTitleDelay()    { return 0.0f; }
   virtual int  GetSubtitleCount()     { return 0; }
   virtual int  GetSubtitle()          { return -1; }
-  virtual void GetSubtitleName(int iStream, CStdString &strStreamName){};
-  virtual void GetSubtitleLanguage(int iStream, CStdString &strStreamLang){};
+  virtual void GetSubtitleStreamInfo(int index, SPlayerSubtitleStreamInfo &info){};
   virtual void SetSubtitle(int iStream){};
   virtual bool GetSubtitleVisible(){ return false;};
   virtual void SetSubtitleVisible(bool bVisible){};
-  virtual bool GetSubtitleExtension(CStdString &strSubtitleExtension){ return false;};
   virtual int  AddSubtitle(const CStdString& strSubPath) {return -1;};
 
   virtual int  GetAudioStreamCount()  { return 0; }
   virtual int  GetAudioStream()       { return -1; }
-  virtual void GetAudioStreamName(int iStream, CStdString &strStreamName){};
   virtual void SetAudioStream(int iStream){};
-  virtual void GetAudioStreamLanguage(int iStream, CStdString &strLanguage){};
+  virtual void GetAudioStreamInfo(int index, SPlayerAudioStreamInfo &info){};
 
   virtual TextCacheStruct_t* GetTeletextCache() { return NULL; };
   virtual void LoadPage(int p, int sp, unsigned char* buffer) {};
@@ -168,14 +187,10 @@
    \brief total time in milliseconds
    */
   virtual int64_t GetTotalTime() { return 0; }
-  virtual int GetAudioBitrate(){ return 0;}
-  virtual int GetVideoBitrate(){ return 0;}
+  virtual void GetVideoStreamInfo(SPlayerVideoStreamInfo &info){};
   virtual int GetSourceBitrate(){ return 0;}
-  virtual int GetChannels(){ return 0;};
   virtual int GetBitsPerSample(){ return 0;};
   virtual int GetSampleRate(){ return 0;};
-  virtual CStdString GetAudioCodecName(){ return "";}
-  virtual CStdString GetVideoCodecName(){ return "";}
   virtual int GetPictureWidth(){ return 0;}
   virtual int GetPictureHeight(){ return 0;}
   virtual bool GetStreamDetails(CStreamDetails &details){ return false;}
diff -ENwbur xbmcfrodo/xbmc/cores/IPlayerCallback.h xbmc/xbmc/cores/IPlayerCallback.h
--- xbmcfrodo/xbmc/cores/IPlayerCallback.h	1970-01-01 00:00:00.000000000 +0000
+++ xbmc/xbmc/cores/IPlayerCallback.h	2013-03-17 12:41:38.037315162 +0000
@@ -0,0 +1,36 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+class IPlayerCallback
+{
+public:
+  virtual ~IPlayerCallback() {}
+  virtual void OnPlayBackEnded() = 0;
+  virtual void OnPlayBackStarted() = 0;
+  virtual void OnPlayBackPaused() {};
+  virtual void OnPlayBackResumed() {};
+  virtual void OnPlayBackStopped() = 0;
+  virtual void OnQueueNextItem() = 0;
+  virtual void OnPlayBackSeek(int iTime, int seekOffset) {};
+  virtual void OnPlayBackSeekChapter(int iChapter) {};
+  virtual void OnPlayBackSpeedChanged(int iSpeed) {};
+};
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/BaseRenderer.cpp xbmc/xbmc/cores/VideoRenderers/BaseRenderer.cpp
--- xbmcfrodo/xbmc/cores/VideoRenderers/BaseRenderer.cpp	2013-02-16 18:48:35.274455159 +0000
+++ xbmc/xbmc/cores/VideoRenderers/BaseRenderer.cpp	2013-04-05 11:38:43.826816245 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -22,8 +22,10 @@
 
 #include <algorithm>
 #include "BaseRenderer.h"
+#include "settings/DisplaySettings.h"
 #include "settings/Settings.h"
 #include "settings/GUISettings.h"
+#include "settings/MediaSettings.h"
 #include "guilib/GraphicContext.h"
 #include "guilib/GUIWindowManager.h"
 #include "utils/log.h"
@@ -82,12 +84,12 @@
     }
 
     CLog::Log(LOGNOTICE, "Display resolution ADJUST : %s (%d) (weight: %.3f)",
-        g_settings.m_ResInfo[m_resolution].strMode.c_str(), m_resolution, weight);
+        CDisplaySettings::Get().GetResolutionInfo(m_resolution).strMode.c_str(), m_resolution, weight);
   }
   else
 #endif
     CLog::Log(LOGNOTICE, "Display resolution %s : %s (%d)",
-        m_resolution == RES_DESKTOP ? "DESKTOP" : "USER", g_settings.m_ResInfo[m_resolution].strMode.c_str(), m_resolution);
+        m_resolution == RES_DESKTOP ? "DESKTOP" : "USER", CDisplaySettings::Get().GetResolutionInfo(m_resolution).strMode.c_str(), m_resolution);
 }
 
 bool CBaseRenderer::FindResolutionFromOverride(float fps, float& weight, bool fallback)
@@ -104,31 +106,31 @@
     if (!fallback && (fps < override.fpsmin || fps > override.fpsmax))
       continue;
 
-    for (size_t j = (int)RES_DESKTOP; j < g_settings.m_ResInfo.size(); j++)
+    for (size_t j = (int)RES_DESKTOP; j < CDisplaySettings::Get().ResolutionInfoSize(); j++)
     {
-      if (g_settings.m_ResInfo[j].iScreenWidth  == g_settings.m_ResInfo[m_resolution].iScreenWidth
-       && g_settings.m_ResInfo[j].iScreenHeight == g_settings.m_ResInfo[m_resolution].iScreenHeight
-       && g_settings.m_ResInfo[j].iScreen       == g_settings.m_ResInfo[m_resolution].iScreen)
+      if (CDisplaySettings::Get().GetResolutionInfo(j).iScreenWidth  == CDisplaySettings::Get().GetResolutionInfo(m_resolution).iScreenWidth
+       && CDisplaySettings::Get().GetResolutionInfo(j).iScreenHeight == CDisplaySettings::Get().GetResolutionInfo(m_resolution).iScreenHeight
+       && CDisplaySettings::Get().GetResolutionInfo(j).iScreen       == CDisplaySettings::Get().GetResolutionInfo(m_resolution).iScreen)
       {
-        if (g_settings.m_ResInfo[j].fRefreshRate <= override.refreshmax
-         && g_settings.m_ResInfo[j].fRefreshRate >= override.refreshmin)
+        if (CDisplaySettings::Get().GetResolutionInfo(j).fRefreshRate <= override.refreshmax
+         && CDisplaySettings::Get().GetResolutionInfo(j).fRefreshRate >= override.refreshmin)
         {
           m_resolution = (RESOLUTION)j;
 
           if (fallback)
           {
             CLog::Log(LOGDEBUG, "Found Resolution %s (%d) from fallback (refreshmin:%.3f refreshmax:%.3f)",
-                      g_settings.m_ResInfo[m_resolution].strMode.c_str(), m_resolution,
+                      CDisplaySettings::Get().GetResolutionInfo(m_resolution).strMode.c_str(), m_resolution,
                       override.refreshmin, override.refreshmax);
           }
           else
           {
             CLog::Log(LOGDEBUG, "Found Resolution %s (%d) from override of fps %.3f (fpsmin:%.3f fpsmax:%.3f refreshmin:%.3f refreshmax:%.3f)",
-                      g_settings.m_ResInfo[m_resolution].strMode.c_str(), m_resolution, fps,
+                      CDisplaySettings::Get().GetResolutionInfo(m_resolution).strMode.c_str(), m_resolution, fps,
                       override.fpsmin, override.fpsmax, override.refreshmin, override.refreshmax);
           }
 
-          weight = RefreshWeight(g_settings.m_ResInfo[m_resolution].fRefreshRate, fps);
+          weight = RefreshWeight(CDisplaySettings::Get().GetResolutionInfo(m_resolution).fRefreshRate, fps);
 
           return true; //fps and refresh match with this override, use this resolution
         }
@@ -148,52 +150,52 @@
   if (weight >= maxWeight) //not a very good match, try a 2:3 cadence instead
   {
     CLog::Log(LOGDEBUG, "Resolution %s (%d) not a very good match for fps %.3f (weight: %.3f), trying 2:3 cadence",
-        g_settings.m_ResInfo[m_resolution].strMode.c_str(), m_resolution, fps, weight);
+        CDisplaySettings::Get().GetResolutionInfo(m_resolution).strMode.c_str(), m_resolution, fps, weight);
 
     m_resolution = FindClosestResolution(fps, 2.5, m_resolution, weight);
 
     if (weight >= maxWeight) //2:3 cadence not a good match
     {
       CLog::Log(LOGDEBUG, "Resolution %s (%d) not a very good match for fps %.3f with 2:3 cadence (weight: %.3f), choosing 60 hertz",
-          g_settings.m_ResInfo[m_resolution].strMode.c_str(), m_resolution, fps, weight);
+          CDisplaySettings::Get().GetResolutionInfo(m_resolution).strMode.c_str(), m_resolution, fps, weight);
 
       //get the resolution with the refreshrate closest to 60 hertz
-      for (size_t i = (int)RES_DESKTOP; i < g_settings.m_ResInfo.size(); i++)
+      for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
       {
-        if (MathUtils::round_int(g_settings.m_ResInfo[i].fRefreshRate) == 60
-         && g_settings.m_ResInfo[i].iScreenWidth  == g_settings.m_ResInfo[m_resolution].iScreenWidth
-         && g_settings.m_ResInfo[i].iScreenHeight == g_settings.m_ResInfo[m_resolution].iScreenHeight
-         && g_settings.m_ResInfo[i].iScreen       == g_settings.m_ResInfo[m_resolution].iScreen)
+        if (MathUtils::round_int(CDisplaySettings::Get().GetResolutionInfo(i).fRefreshRate) == 60
+         && CDisplaySettings::Get().GetResolutionInfo(i).iScreenWidth  == CDisplaySettings::Get().GetResolutionInfo(m_resolution).iScreenWidth
+         && CDisplaySettings::Get().GetResolutionInfo(i).iScreenHeight == CDisplaySettings::Get().GetResolutionInfo(m_resolution).iScreenHeight
+         && CDisplaySettings::Get().GetResolutionInfo(i).iScreen       == CDisplaySettings::Get().GetResolutionInfo(m_resolution).iScreen)
         {
-          if (fabs(g_settings.m_ResInfo[i].fRefreshRate - 60.0) < fabs(g_settings.m_ResInfo[m_resolution].fRefreshRate - 60.0))
+          if (fabs(CDisplaySettings::Get().GetResolutionInfo(i).fRefreshRate - 60.0) < fabs(CDisplaySettings::Get().GetResolutionInfo(m_resolution).fRefreshRate - 60.0))
             m_resolution = (RESOLUTION)i;
         }
       }
 
       //60 hertz not available, get the highest refreshrate
-      if (MathUtils::round_int(g_settings.m_ResInfo[m_resolution].fRefreshRate) != 60)
+      if (MathUtils::round_int(CDisplaySettings::Get().GetResolutionInfo(m_resolution).fRefreshRate) != 60)
       {
         CLog::Log(LOGDEBUG, "60 hertz refreshrate not available, choosing highest");
-        for (size_t i = (int)RES_DESKTOP; i < g_settings.m_ResInfo.size(); i++)
+        for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
         {
-          if (g_settings.m_ResInfo[i].fRefreshRate  >  g_settings.m_ResInfo[m_resolution].fRefreshRate
-           && g_settings.m_ResInfo[i].iScreenWidth  == g_settings.m_ResInfo[m_resolution].iScreenWidth
-           && g_settings.m_ResInfo[i].iScreenHeight == g_settings.m_ResInfo[m_resolution].iScreenHeight
-           && g_settings.m_ResInfo[i].iScreen       == g_settings.m_ResInfo[m_resolution].iScreen)
+          if (CDisplaySettings::Get().GetResolutionInfo(i).fRefreshRate  >  CDisplaySettings::Get().GetResolutionInfo(m_resolution).fRefreshRate
+           && CDisplaySettings::Get().GetResolutionInfo(i).iScreenWidth  == CDisplaySettings::Get().GetResolutionInfo(m_resolution).iScreenWidth
+           && CDisplaySettings::Get().GetResolutionInfo(i).iScreenHeight == CDisplaySettings::Get().GetResolutionInfo(m_resolution).iScreenHeight
+           && CDisplaySettings::Get().GetResolutionInfo(i).iScreen       == CDisplaySettings::Get().GetResolutionInfo(m_resolution).iScreen)
           {
             m_resolution = (RESOLUTION)i;
           }
         }
       }
 
-      weight = RefreshWeight(g_settings.m_ResInfo[m_resolution].fRefreshRate, fps);
+      weight = RefreshWeight(CDisplaySettings::Get().GetResolutionInfo(m_resolution).fRefreshRate, fps);
     }
   }
 }
 
 RESOLUTION CBaseRenderer::FindClosestResolution(float fps, float multiplier, RESOLUTION current, float& weight)
 {
-  RESOLUTION_INFO &curr = g_settings.m_ResInfo[current];
+  RESOLUTION_INFO &curr = CDisplaySettings::Get().GetResolutionInfo(current);
 
   int iScreenWidth  = curr.iScreenWidth;
   int iScreenHeight = curr.iScreenHeight;
@@ -234,10 +236,10 @@
   float last_diff = fRefreshRate;
 
   // Find closest refresh rate
-  for (size_t i = (int)RES_DESKTOP; i < g_settings.m_ResInfo.size(); i++)
+  for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
   {
-    RESOLUTION_INFO &info = g_settings.m_ResInfo[i];
-    RESOLUTION_INFO &best = g_settings.m_ResInfo[current];
+    RESOLUTION_INFO &info = CDisplaySettings::Get().GetResolutionInfo(i);
+    RESOLUTION_INFO &best = CDisplaySettings::Get().GetResolutionInfo(current);
 
     //discard resolutions that are not the same width and height
     //or have a too low refreshrate
@@ -276,7 +278,7 @@
   if(m_iFlags & CONF_FLAGS_FORMAT_SBS || m_iFlags & CONF_FLAGS_FORMAT_TB)
     weight = 0;
   else
-    weight = RefreshWeight(g_settings.m_ResInfo[current].fRefreshRate, fRefreshRate * multiplier);
+    weight = RefreshWeight(CDisplaySettings::Get().GetResolutionInfo(current).fRefreshRate, fRefreshRate * multiplier);
 
   return current;
 }
@@ -303,8 +305,8 @@
 
 float CBaseRenderer::GetAspectRatio() const
 {
-  float width = (float)m_sourceWidth - g_settings.m_currentVideoSettings.m_CropLeft - g_settings.m_currentVideoSettings.m_CropRight;
-  float height = (float)m_sourceHeight - g_settings.m_currentVideoSettings.m_CropTop - g_settings.m_currentVideoSettings.m_CropBottom;
+  float width = (float)m_sourceWidth - CMediaSettings::Get().GetCurrentVideoSettings().m_CropLeft - CMediaSettings::Get().GetCurrentVideoSettings().m_CropRight;
+  float height = (float)m_sourceHeight - CMediaSettings::Get().GetCurrentVideoSettings().m_CropTop - CMediaSettings::Get().GetCurrentVideoSettings().m_CropBottom;
   return m_sourceFrameRatio * width / height * m_sourceHeight / m_sourceWidth;
 }
 
@@ -421,7 +423,7 @@
   // calculate the correct output frame ratio (using the users pixel ratio setting
   // and the output pixel ratio setting)
 
-  float outputFrameRatio = inputFrameRatio / g_settings.m_ResInfo[GetResolution()].fPixelRatio;
+  float outputFrameRatio = inputFrameRatio / CDisplaySettings::Get().GetResolutionInfo(GetResolution()).fPixelRatio;
 
   // allow a certain error to maximize screen size
   float fCorrection = screenWidth / screenHeight / outputFrameRatio - 1.0f;
@@ -565,28 +567,28 @@
 {
   const CRect view = g_graphicsContext.GetViewWindow();
 
-  m_sourceRect.x1 = (float)g_settings.m_currentVideoSettings.m_CropLeft;
-  m_sourceRect.y1 = (float)g_settings.m_currentVideoSettings.m_CropTop;
-  m_sourceRect.x2 = (float)m_sourceWidth - g_settings.m_currentVideoSettings.m_CropRight;
-  m_sourceRect.y2 = (float)m_sourceHeight - g_settings.m_currentVideoSettings.m_CropBottom;
+  m_sourceRect.x1 = (float)CMediaSettings::Get().GetCurrentVideoSettings().m_CropLeft;
+  m_sourceRect.y1 = (float)CMediaSettings::Get().GetCurrentVideoSettings().m_CropTop;
+  m_sourceRect.x2 = (float)m_sourceWidth - CMediaSettings::Get().GetCurrentVideoSettings().m_CropRight;
+  m_sourceRect.y2 = (float)m_sourceHeight - CMediaSettings::Get().GetCurrentVideoSettings().m_CropBottom;
 
   CalcNormalDisplayRect(view.x1, view.y1, view.Width(), view.Height(), GetAspectRatio() * g_settings.m_fPixelRatio, g_settings.m_fZoomAmount, g_settings.m_fVerticalShift);
 }
 
 void CBaseRenderer::SetViewMode(int viewMode)
 {
-  if (viewMode < VIEW_MODE_NORMAL || viewMode > VIEW_MODE_CUSTOM)
-    viewMode = VIEW_MODE_NORMAL;
+  if (viewMode < ViewModeNormal || viewMode > ViewModeCustom)
+    viewMode = ViewModeNormal;
 
   if (m_iFlags & (CONF_FLAGS_FORMAT_SBS | CONF_FLAGS_FORMAT_TB))
-    viewMode = VIEW_MODE_NORMAL;
+    viewMode = ViewModeNormal;
 
-  g_settings.m_currentVideoSettings.m_ViewMode = viewMode;
+  CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode = viewMode;
 
   // get our calibrated full screen resolution
   RESOLUTION res = GetResolution();
-  float screenWidth = (float)(g_settings.m_ResInfo[res].Overscan.right - g_settings.m_ResInfo[res].Overscan.left);
-  float screenHeight = (float)(g_settings.m_ResInfo[res].Overscan.bottom - g_settings.m_ResInfo[res].Overscan.top);
+  float screenWidth = (float)(CDisplaySettings::Get().GetResolutionInfo(res).Overscan.right - CDisplaySettings::Get().GetResolutionInfo(res).Overscan.left);
+  float screenHeight = (float)(CDisplaySettings::Get().GetResolutionInfo(res).Overscan.bottom - CDisplaySettings::Get().GetResolutionInfo(res).Overscan.top);
 
   if(m_iFlags & CONF_FLAGS_FORMAT_SBS)
     screenWidth /= 2;
@@ -596,11 +598,11 @@
   float sourceFrameRatio = GetAspectRatio();
 
   bool is43 = (sourceFrameRatio < 8.f/(3.f*sqrt(3.f)) &&
-              g_settings.m_currentVideoSettings.m_ViewMode == VIEW_MODE_NORMAL);
+              CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode == ViewModeNormal);
 
   // Splitres scaling factor
-  float xscale = (float)g_settings.m_ResInfo[res].iScreenWidth  / (float)g_settings.m_ResInfo[res].iWidth;
-  float yscale = (float)g_settings.m_ResInfo[res].iScreenHeight / (float)g_settings.m_ResInfo[res].iHeight;
+  float xscale = (float)CDisplaySettings::Get().GetResolutionInfo(res).iScreenWidth  / (float)CDisplaySettings::Get().GetResolutionInfo(res).iWidth;
+  float yscale = (float)CDisplaySettings::Get().GetResolutionInfo(res).iScreenHeight / (float)CDisplaySettings::Get().GetResolutionInfo(res).iHeight;
 
   screenWidth   *= xscale;
   screenHeight  *= yscale;
@@ -608,12 +610,12 @@
   g_settings.m_fVerticalShift = 0.0f;
   g_settings.m_bNonLinStretch = false;
 
-  if ( g_settings.m_currentVideoSettings.m_ViewMode == VIEW_MODE_ZOOM ||
-       (is43 && g_guiSettings.GetInt("videoplayer.stretch43") == VIEW_MODE_ZOOM))
+  if ( CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode == ViewModeZoom ||
+       (is43 && g_guiSettings.GetInt("videoplayer.stretch43") == ViewModeZoom))
   { // zoom image so no black bars
     g_settings.m_fPixelRatio = 1.0;
     // calculate the desired output ratio
-    float outputFrameRatio = sourceFrameRatio * g_settings.m_fPixelRatio / g_settings.m_ResInfo[res].fPixelRatio;
+    float outputFrameRatio = sourceFrameRatio * g_settings.m_fPixelRatio / CDisplaySettings::Get().GetResolutionInfo(res).fPixelRatio;
     // now calculate the correct zoom amount.  First zoom to full height.
     float newHeight = screenHeight;
     float newWidth = newHeight * outputFrameRatio;
@@ -625,13 +627,13 @@
       g_settings.m_fZoomAmount = newHeight / screenHeight;
     }
   }
-  else if (g_settings.m_currentVideoSettings.m_ViewMode == VIEW_MODE_STRETCH_4x3)
+  else if (CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode == ViewModeStretch4x3)
   { // stretch image to 4:3 ratio
     g_settings.m_fZoomAmount = 1.0;
     if (res == RES_PAL_4x3 || res == RES_PAL60_4x3 || res == RES_NTSC_4x3 || res == RES_HDTV_480p_4x3)
     { // stretch to the limits of the 4:3 screen.
       // incorrect behaviour, but it's what the users want, so...
-      g_settings.m_fPixelRatio = (screenWidth / screenHeight) * g_settings.m_ResInfo[res].fPixelRatio / sourceFrameRatio;
+      g_settings.m_fPixelRatio = (screenWidth / screenHeight) * CDisplaySettings::Get().GetResolutionInfo(res).fPixelRatio / sourceFrameRatio;
     }
     else
     {
@@ -640,16 +642,16 @@
       g_settings.m_fPixelRatio = (4.0f / 3.0f) / sourceFrameRatio;
     }
   }
-  else if ( g_settings.m_currentVideoSettings.m_ViewMode == VIEW_MODE_WIDE_ZOOM ||
-           (is43 && g_guiSettings.GetInt("videoplayer.stretch43") == VIEW_MODE_WIDE_ZOOM))
+  else if ( CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode == ViewModeWideZoom ||
+           (is43 && g_guiSettings.GetInt("videoplayer.stretch43") == ViewModeWideZoom))
   { // super zoom
-    float stretchAmount = (screenWidth / screenHeight) * g_settings.m_ResInfo[res].fPixelRatio / sourceFrameRatio;
+    float stretchAmount = (screenWidth / screenHeight) * CDisplaySettings::Get().GetResolutionInfo(res).fPixelRatio / sourceFrameRatio;
     g_settings.m_fPixelRatio = pow(stretchAmount, float(2.0/3.0));
     g_settings.m_fZoomAmount = pow(stretchAmount, float((stretchAmount < 1.0) ? -1.0/3.0 : 1.0/3.0));
     g_settings.m_bNonLinStretch = true;
   }
-  else if ( g_settings.m_currentVideoSettings.m_ViewMode == VIEW_MODE_STRETCH_16x9 ||
-           (is43 && g_guiSettings.GetInt("videoplayer.stretch43") == VIEW_MODE_STRETCH_16x9))
+  else if ( CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode == ViewModeStretch16x9 ||
+           (is43 && g_guiSettings.GetInt("videoplayer.stretch43") == ViewModeStretch16x9))
   { // stretch image to 16:9 ratio
     g_settings.m_fZoomAmount = 1.0;
     if (res == RES_PAL_4x3 || res == RES_PAL60_4x3 || res == RES_NTSC_4x3 || res == RES_HDTV_480p_4x3)
@@ -660,43 +662,41 @@
     else
     { // stretch to the limits of the 16:9 screen.
       // incorrect behaviour, but it's what the users want, so...
-      g_settings.m_fPixelRatio = (screenWidth / screenHeight) * g_settings.m_ResInfo[res].fPixelRatio / sourceFrameRatio;
+      g_settings.m_fPixelRatio = (screenWidth / screenHeight) * CDisplaySettings::Get().GetResolutionInfo(res).fPixelRatio / sourceFrameRatio;
     }
   }
-  else  if (g_settings.m_currentVideoSettings.m_ViewMode == VIEW_MODE_ORIGINAL)
+  else  if (CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode == ViewModeOriginal)
   { // zoom image so that the height is the original size
     g_settings.m_fPixelRatio = 1.0;
     // get the size of the media file
     // calculate the desired output ratio
-    float outputFrameRatio = sourceFrameRatio * g_settings.m_fPixelRatio / g_settings.m_ResInfo[res].fPixelRatio;
+    float outputFrameRatio = sourceFrameRatio * g_settings.m_fPixelRatio / CDisplaySettings::Get().GetResolutionInfo(res).fPixelRatio;
     // now calculate the correct zoom amount.  First zoom to full width.
-    float newWidth = screenWidth;
-    float newHeight = newWidth / outputFrameRatio;
+    float newHeight = screenWidth / outputFrameRatio;
     if (newHeight > screenHeight)
     { // zoom to full height
       newHeight = screenHeight;
-      newWidth = newHeight * outputFrameRatio;
     }
     // now work out the zoom amount so that no zoom is done
-    g_settings.m_fZoomAmount = (m_sourceHeight - g_settings.m_currentVideoSettings.m_CropTop - g_settings.m_currentVideoSettings.m_CropBottom) / newHeight;
+    g_settings.m_fZoomAmount = (m_sourceHeight - CMediaSettings::Get().GetCurrentVideoSettings().m_CropTop - CMediaSettings::Get().GetCurrentVideoSettings().m_CropBottom) / newHeight;
   }
-  else if (g_settings.m_currentVideoSettings.m_ViewMode == VIEW_MODE_CUSTOM)
+  else if (CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode == ViewModeCustom)
   {
-    g_settings.m_fZoomAmount = g_settings.m_currentVideoSettings.m_CustomZoomAmount;
-    g_settings.m_fPixelRatio = g_settings.m_currentVideoSettings.m_CustomPixelRatio;
-    g_settings.m_bNonLinStretch = g_settings.m_currentVideoSettings.m_CustomNonLinStretch;
-    g_settings.m_fVerticalShift = g_settings.m_currentVideoSettings.m_CustomVerticalShift;
+    g_settings.m_fZoomAmount = CMediaSettings::Get().GetCurrentVideoSettings().m_CustomZoomAmount;
+    g_settings.m_fPixelRatio = CMediaSettings::Get().GetCurrentVideoSettings().m_CustomPixelRatio;
+    g_settings.m_bNonLinStretch = CMediaSettings::Get().GetCurrentVideoSettings().m_CustomNonLinStretch;
+    g_settings.m_fVerticalShift = CMediaSettings::Get().GetCurrentVideoSettings().m_CustomVerticalShift;
   }
-  else // if (g_settings.m_currentVideoSettings.m_ViewMode == VIEW_MODE_NORMAL)
+  else // if (CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode == ViewModeNormal)
   {
     g_settings.m_fPixelRatio = 1.0;
     g_settings.m_fZoomAmount = 1.0;
   }
 
-  g_settings.m_currentVideoSettings.m_CustomZoomAmount = g_settings.m_fZoomAmount;
-  g_settings.m_currentVideoSettings.m_CustomPixelRatio = g_settings.m_fPixelRatio;
-  g_settings.m_currentVideoSettings.m_CustomNonLinStretch = g_settings.m_bNonLinStretch;
-  g_settings.m_currentVideoSettings.m_CustomVerticalShift = g_settings.m_fVerticalShift;
+  CMediaSettings::Get().GetCurrentVideoSettings().m_CustomZoomAmount = g_settings.m_fZoomAmount;
+  CMediaSettings::Get().GetCurrentVideoSettings().m_CustomPixelRatio = g_settings.m_fPixelRatio;
+  CMediaSettings::Get().GetCurrentVideoSettings().m_CustomNonLinStretch = g_settings.m_bNonLinStretch;
+  CMediaSettings::Get().GetCurrentVideoSettings().m_CustomVerticalShift = g_settings.m_fVerticalShift;
 }
 
 void CBaseRenderer::MarkDirty()
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/BaseRenderer.h xbmc/xbmc/cores/VideoRenderers/BaseRenderer.h
--- xbmcfrodo/xbmc/cores/VideoRenderers/BaseRenderer.h	2013-02-16 18:48:35.274455159 +0000
+++ xbmc/xbmc/cores/VideoRenderers/BaseRenderer.h	2013-04-05 11:38:43.826816245 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -97,7 +97,7 @@
   bool       FindResolutionFromOverride(float fps, float& weight, bool fallback);
   void       FindResolutionFromFpsMatch(float fps, float& weight);
   RESOLUTION FindClosestResolution(float fps, float multiplier, RESOLUTION current, float& weight);
-  float      RefreshWeight(float refresh, float fps);
+  static float      RefreshWeight(float refresh, float fps);
   void       CalcNormalDisplayRect(float offsetX, float offsetY, float screenWidth, float screenHeight, float inputFrameRatio, float zoomAmount, float verticalShift);
   void       CalculateFrameAspectRatio(unsigned int desired_width, unsigned int desired_height);
   void       ManageDisplay();
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp xbmc/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
--- xbmcfrodo/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp	2013-02-16 18:48:35.304454564 +0000
+++ xbmc/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp	2013-04-05 11:38:43.836816064 +0000
@@ -32,7 +32,9 @@
 #include "Application.h"
 #include "settings/Settings.h"
 #include "settings/AdvancedSettings.h"
+#include "settings/DisplaySettings.h"
 #include "settings/GUISettings.h"
+#include "settings/MediaSettings.h"
 #include "VideoShaders/YUV2RGBShader.h"
 #include "VideoShaders/VideoFilterShader.h"
 #include "windowing/WindowingFactory.h"
@@ -45,6 +47,7 @@
 #include "utils/GLUtils.h"
 #include "RenderCapture.h"
 #include "RenderFormats.h"
+#include "cores/IPlayer.h"
 
 #ifdef HAVE_LIBVDPAU
 #include "cores/dvdplayer/DVDCodecs/Video/VDPAU.h"
@@ -172,6 +175,19 @@
   m_rgbBufferSize = 0;
   m_context = NULL;
   m_rgbPbo = 0;
+  m_fbo.width = 0.0;
+  m_fbo.height = 0.0;
+  m_NumYV12Buffers = 0;
+  m_iLastRenderBuffer = 0;
+  m_bConfigured = false;
+  m_bValidated = false;
+  m_bImageReady = false;
+  m_clearColour = 0.0f;
+  m_pboSupported = false;
+  m_pboUsed = false;
+  m_nonLinStretch = false;
+  m_nonLinStretchGui = false;
+  m_pixelRatio = 0.0f;
 
   m_dllSwScale = new DllSwScale;
 }
@@ -291,7 +307,7 @@
   // Calculate the input frame aspect ratio.
   CalculateFrameAspectRatio(d_width, d_height);
   ChooseBestResolution(fps);
-  SetViewMode(g_settings.m_currentVideoSettings.m_ViewMode);
+  SetViewMode(CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode);
   ManageDisplay();
 
   m_bConfigured = true;
@@ -777,7 +793,7 @@
   m_bConfigured = false;
   m_bValidated = false;
   UnInit();
-  m_resolution = g_guiSettings.m_LookAndFeelResolution;
+  m_resolution = CDisplaySettings::Get().GetCurrentResolution();
   if ( m_resolution == RES_WINDOW )
     m_resolution = RES_DESKTOP;
 
@@ -834,7 +850,7 @@
     }
   }
 
-  if (m_scalingMethodGui == g_settings.m_currentVideoSettings.m_ScalingMethod && !nonLinStretchChanged)
+  if (m_scalingMethodGui == CMediaSettings::Get().GetCurrentVideoSettings().m_ScalingMethod && !nonLinStretchChanged)
     return;
 
   //recompile YUV shader when non-linear stretch is turned on/off
@@ -842,7 +858,7 @@
   if (m_nonLinStretch || nonLinStretchChanged)
     m_reloadShaders = 1;
 
-  m_scalingMethodGui = g_settings.m_currentVideoSettings.m_ScalingMethod;
+  m_scalingMethodGui = CMediaSettings::Get().GetCurrentVideoSettings().m_ScalingMethod;
   m_scalingMethod    = m_scalingMethodGui;
 
   if(!Supports(m_scalingMethod))
@@ -1003,15 +1019,15 @@
           UpdateVideoFilter();
           break;
         }
-        else
+        else if (m_pYUVShader)
         {
           m_pYUVShader->Free();
           delete m_pYUVShader;
           m_pYUVShader = NULL;
+        }
           CLog::Log(LOGERROR, "GL: Error enabling YUV2RGB GLSL shader");
           // drop through and try ARB
         }
-      }
       case RENDER_METHOD_ARB:
       // Try ARB shaders if supported and user requested it or GLSL shaders failed.
       if (glewIsSupported("GL_ARB_fragment_program"))
@@ -1029,15 +1045,15 @@
           UpdateVideoFilter();
           break;
         }
-        else
+        else if (m_pYUVShader)
         {
           m_pYUVShader->Free();
           delete m_pYUVShader;
           m_pYUVShader = NULL;
+        }
           CLog::Log(LOGERROR, "GL: Error enabling YUV2RGB ARB shader");
           // drop through and use SW
         }
-      }
       case RENDER_METHOD_SOFTWARE:
       default:
       // Use software YUV 2 RGB conversion if user requested it or GLSL and/or ARB shaders failed
@@ -1246,8 +1262,8 @@
   glActiveTextureARB(GL_TEXTURE0);
   VerifyGLState();
 
-  m_pYUVShader->SetBlack(g_settings.m_currentVideoSettings.m_Brightness * 0.01f - 0.5f);
-  m_pYUVShader->SetContrast(g_settings.m_currentVideoSettings.m_Contrast * 0.02f);
+  m_pYUVShader->SetBlack(CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness * 0.01f - 0.5f);
+  m_pYUVShader->SetContrast(CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast * 0.02f);
   m_pYUVShader->SetWidth(planes[0].texwidth);
   m_pYUVShader->SetHeight(planes[0].texheight);
 
@@ -1371,8 +1387,8 @@
   m_fbo.fbo.BeginRender();
   VerifyGLState();
 
-  m_pYUVShader->SetBlack(g_settings.m_currentVideoSettings.m_Brightness * 0.01f - 0.5f);
-  m_pYUVShader->SetContrast(g_settings.m_currentVideoSettings.m_Contrast * 0.02f);
+  m_pYUVShader->SetBlack(CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness * 0.01f - 0.5f);
+  m_pYUVShader->SetContrast(CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast * 0.02f);
   m_pYUVShader->SetWidth(planes[0].texwidth);
   m_pYUVShader->SetHeight(planes[0].texheight);
   m_pYUVShader->SetNonLinStretch(1.0);
@@ -3097,11 +3113,11 @@
   }
 
   if (imaging==1 &&
-      ((g_settings.m_currentVideoSettings.m_Brightness!=50) ||
-       (g_settings.m_currentVideoSettings.m_Contrast!=50)))
+      ((CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness!=50) ||
+       (CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast!=50)))
   {
-    GLfloat brightness = ((GLfloat)g_settings.m_currentVideoSettings.m_Brightness - 50.0f)/100.0f;;
-    GLfloat contrast   = ((GLfloat)g_settings.m_currentVideoSettings.m_Contrast)/50.0f;
+    GLfloat brightness = ((GLfloat)CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness - 50.0f)/100.0f;;
+    GLfloat contrast   = ((GLfloat)CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast)/50.0f;
 
     glPixelTransferf(GL_RED_SCALE  , contrast);
     glPixelTransferf(GL_GREEN_SCALE, contrast);
@@ -3187,7 +3203,7 @@
 {
   if(feature == RENDERFEATURE_BRIGHTNESS)
   {
-    if ((m_renderMethod & RENDER_VDPAU) && !g_guiSettings.GetBool("videoplayer.vdpaustudiolevel"))
+    if ((m_renderMethod & RENDER_VDPAU) && !g_guiSettings.GetBool("videoscreen.limitedrange"))
       return true;
 
     if (m_renderMethod & RENDER_VAAPI)
@@ -3200,7 +3216,7 @@
   
   if(feature == RENDERFEATURE_CONTRAST)
   {
-    if ((m_renderMethod & RENDER_VDPAU) && !g_guiSettings.GetBool("videoplayer.vdpaustudiolevel"))
+    if ((m_renderMethod & RENDER_VDPAU) && !g_guiSettings.GetBool("videoscreen.limitedrange"))
       return true;
 
     if (m_renderMethod & RENDER_VAAPI)
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/LinuxRendererGL.h xbmc/xbmc/cores/VideoRenderers/LinuxRendererGL.h
--- xbmcfrodo/xbmc/cores/VideoRenderers/LinuxRendererGL.h	2013-02-16 18:48:35.314454365 +0000
+++ xbmc/xbmc/cores/VideoRenderers/LinuxRendererGL.h	2013-02-10 14:23:18.366518122 +0000
@@ -2,7 +2,7 @@
 #define LINUXRENDERERGL_RENDERER
 
 /*
- *      Copyright (C) 2007-2012 Team XBMC
+ *      Copyright (C) 2007-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp xbmc/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
--- xbmcfrodo/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp	2013-02-16 18:48:35.314454365 +0000
+++ xbmc/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp	2013-04-05 11:38:43.846815883 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -35,6 +35,8 @@
 #include "settings/Settings.h"
 #include "settings/AdvancedSettings.h"
 #include "settings/GUISettings.h"
+#include "settings/MediaSettings.h"
+#include "settings/DisplaySettings.h"
 #include "guilib/FrameBufferObject.h"
 #include "VideoShaders/YUV2RGBShader.h"
 #include "VideoShaders/VideoFilterShader.h"
@@ -47,6 +49,7 @@
 #include "RenderCapture.h"
 #include "RenderFormats.h"
 #include "xbmc/Application.h"
+#include "cores/IPlayer.h"
 
 #if defined(__ARM_NEON__)
 #include "yuv2rgb.neon.h"
@@ -112,6 +115,13 @@
 
   m_dllSwScale = new DllSwScale;
   m_sw_context = NULL;
+  m_NumYV12Buffers = 0;
+  m_iLastRenderBuffer = 0;
+  m_bConfigured = false;
+  m_bValidated = false;
+  m_bImageReady = false;
+  m_StrictBinding = false;
+  m_clearColour = 0.0f;
 }
 
 CLinuxRendererGLES::~CLinuxRendererGLES()
@@ -173,7 +183,7 @@
   // Calculate the input frame aspect ratio.
   CalculateFrameAspectRatio(d_width, d_height);
   ChooseBestResolution(fps);
-  SetViewMode(g_settings.m_currentVideoSettings.m_ViewMode);
+  SetViewMode(CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode);
   ManageDisplay();
 
   m_bConfigured = true;
@@ -416,8 +426,8 @@
       (*m_RenderUpdateCallBackFn)(m_RenderUpdateCallBackCtx, m_sourceRect, m_destRect);
 
     RESOLUTION res = GetResolution();
-    int iWidth = g_settings.m_ResInfo[res].iWidth;
-    int iHeight = g_settings.m_ResInfo[res].iHeight;
+    int iWidth = CDisplaySettings::Get().GetResolutionInfo(res).iWidth;
+    int iHeight = CDisplaySettings::Get().GetResolutionInfo(res).iHeight;
 
     g_graphicsContext.BeginPaint();
 
@@ -517,7 +527,7 @@
   m_bConfigured = false;
   m_bValidated = false;
   UnInit();
-  m_resolution = g_guiSettings.m_LookAndFeelResolution;
+  m_resolution = CDisplaySettings::Get().GetCurrentResolution();
   if ( m_resolution == RES_WINDOW )
     m_resolution = RES_DESKTOP;
 
@@ -544,9 +554,9 @@
 
 void CLinuxRendererGLES::UpdateVideoFilter()
 {
-  if (m_scalingMethodGui == g_settings.m_currentVideoSettings.m_ScalingMethod)
+  if (m_scalingMethodGui == CMediaSettings::Get().GetCurrentVideoSettings().m_ScalingMethod)
     return;
-  m_scalingMethodGui = g_settings.m_currentVideoSettings.m_ScalingMethod;
+  m_scalingMethodGui = CMediaSettings::Get().GetCurrentVideoSettings().m_ScalingMethod;
   m_scalingMethod    = m_scalingMethodGui;
 
   if(!Supports(m_scalingMethod))
@@ -664,7 +674,7 @@
           UpdateVideoFilter();
           break;
         }
-        else
+        else if (m_pYUVShader)
         {
           m_pYUVShader->Free();
           delete m_pYUVShader;
@@ -858,8 +868,8 @@
   glActiveTexture(GL_TEXTURE0);
   VerifyGLState();
 
-  m_pYUVShader->SetBlack(g_settings.m_currentVideoSettings.m_Brightness * 0.01f - 0.5f);
-  m_pYUVShader->SetContrast(g_settings.m_currentVideoSettings.m_Contrast * 0.02f);
+  m_pYUVShader->SetBlack(CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness * 0.01f - 0.5f);
+  m_pYUVShader->SetContrast(CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast * 0.02f);
   m_pYUVShader->SetWidth(im.width);
   m_pYUVShader->SetHeight(im.height);
   if     (field == FIELD_TOP)
@@ -980,8 +990,8 @@
   m_fbo.BeginRender();
   VerifyGLState();
 
-  m_pYUVShader->SetBlack(g_settings.m_currentVideoSettings.m_Brightness * 0.01f - 0.5f);
-  m_pYUVShader->SetContrast(g_settings.m_currentVideoSettings.m_Contrast * 0.02f);
+  m_pYUVShader->SetBlack(CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness * 0.01f - 0.5f);
+  m_pYUVShader->SetContrast(CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast * 0.02f);
   m_pYUVShader->SetWidth(im.width);
   m_pYUVShader->SetHeight(im.height);
   if     (field == FIELD_TOP)
@@ -1014,16 +1024,16 @@
     CLog::Log(LOGERROR, "GL: Error enabling YUV shader");
   }
 
-  float imgwidth  = planes[0].rect.x2 - planes[0].rect.x1;
-  float imgheight = planes[0].rect.y2 - planes[0].rect.y1;
-  if (m_textureTarget == GL_TEXTURE_2D)
-  {
-    imgwidth  *= planes[0].texwidth;
-    imgheight *= planes[0].texheight;
-  }
-
   // 1st Pass to video frame size
 //TODO
+//  float imgwidth  = planes[0].rect.x2 - planes[0].rect.x1;
+//  float imgheight = planes[0].rect.y2 - planes[0].rect.y1;
+//  if (m_textureTarget == GL_TEXTURE_2D)
+//  {
+//    imgwidth  *= planes[0].texwidth;
+//    imgheight *= planes[0].texheight;
+//  }
+//  
 //  glBegin(GL_QUADS);
 //
 //  glMultiTexCoord2fARB(GL_TEXTURE0, planes[0].rect.x1, planes[0].rect.y1);
@@ -1091,10 +1101,10 @@
 
   VerifyGLState();
 
-  imgwidth  /= m_sourceWidth;
-  imgheight /= m_sourceHeight;
-
 //TODO
+//  imgwidth  /= m_sourceWidth;
+//  imgheight /= m_sourceHeight;
+//
 //  glBegin(GL_QUADS);
 //
 //  glMultiTexCoord2fARB(GL_TEXTURE0, 0.0f    , 0.0f);
@@ -1352,7 +1362,7 @@
   // OpenGLES returns in RGBA order but CRenderCapture needs BGRA order
   // XOR Swap RGBA -> BGRA
   unsigned char* pixels = (unsigned char*)capture->GetRenderBuffer();
-  for (int i = 0; i < capture->GetWidth() * capture->GetHeight(); i++, pixels+=4)
+  for (unsigned int i = 0; i < capture->GetWidth() * capture->GetHeight(); i++, pixels+=4)
   {
     std::swap(pixels[0], pixels[2]);
   }
@@ -1962,7 +1972,7 @@
   // Player controls render, let it pick the auto-deinterlace method
   if((m_renderMethod & RENDER_BYPASS))
   {
-    if (m_deinterlaceMethods.size())
+    if (!m_deinterlaceMethods.empty())
       return ((EINTERLACEMETHOD)m_deinterlaceMethods[0]);
     else
       return VS_INTERLACEMETHOD_NONE;
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/LinuxRendererGLES.h xbmc/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
--- xbmcfrodo/xbmc/cores/VideoRenderers/LinuxRendererGLES.h	2013-02-16 18:48:35.314454365 +0000
+++ xbmc/xbmc/cores/VideoRenderers/LinuxRendererGLES.h	2013-02-10 14:23:18.366518122 +0000
@@ -2,7 +2,7 @@
 #define LINUXRENDERERGLES_RENDERER
 
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/OverlayRenderer.cpp xbmc/xbmc/cores/VideoRenderers/OverlayRenderer.cpp
--- xbmcfrodo/xbmc/cores/VideoRenderers/OverlayRenderer.cpp	2013-02-16 18:48:35.314454365 +0000
+++ xbmc/xbmc/cores/VideoRenderers/OverlayRenderer.cpp	2013-04-05 11:38:43.846815883 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *      Initial code sponsored by: Voddler Inc (voddler.com)
@@ -28,6 +28,7 @@
 #include "cores/VideoRenderers/RenderManager.h"
 #include "Application.h"
 #include "windowing/WindowingFactory.h"
+#include "settings/DisplaySettings.h"
 #include "settings/Settings.h"
 #include "threads/SingleLock.h"
 #include "utils/MathUtils.h"
@@ -129,7 +130,7 @@
   SElementV l = list;
   list.clear();
 
-  for(SElementV::iterator it = l.begin(); it != l.end(); it++)
+  for(SElementV::iterator it = l.begin(); it != l.end(); ++it)
   {
     if(it->overlay)
       it->overlay->Release();
@@ -143,7 +144,7 @@
   COverlayV l = list;
   list.clear();
 
-  for(COverlayV::iterator it = l.begin(); it != l.end(); it++)
+  for(COverlayV::iterator it = l.begin(); it != l.end(); ++it)
     (*it)->Release();
 }
 
@@ -174,7 +175,7 @@
   Release(m_cleanup);
 
   SElementV& list = m_buffers[m_render];
-  for(SElementV::iterator it = list.begin(); it != list.end(); it++)
+  for(SElementV::iterator it = list.begin(); it != list.end(); ++it)
   {
     COverlay* o = NULL;
 
@@ -198,7 +199,7 @@
   RESOLUTION_INFO res;
   g_renderManager.GetVideoRect(rs, rd);
   rv  = g_graphicsContext.GetViewWindow();
-  res = g_settings.m_ResInfo[g_renderManager.GetResolution()];
+  res = CDisplaySettings::Get().GetResolutionInfo(g_renderManager.GetResolution());
 
   SRenderState state;
   state.x       = o->m_x;
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/OverlayRenderer.h xbmc/xbmc/cores/VideoRenderers/OverlayRenderer.h
--- xbmcfrodo/xbmc/cores/VideoRenderers/OverlayRenderer.h	2013-02-16 18:48:35.314454365 +0000
+++ xbmc/xbmc/cores/VideoRenderers/OverlayRenderer.h	2013-04-05 11:38:43.846815883 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *      Initial code sponsored by: Voddler Inc (voddler.com)
@@ -107,6 +107,7 @@
       {
         overlay_dvd = NULL;
         overlay     = NULL;
+        pts         = 0.0;
       }
       double pts;
       CDVDOverlay* overlay_dvd;
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/OverlayRendererDX.cpp xbmc/xbmc/cores/VideoRenderers/OverlayRendererDX.cpp
--- xbmcfrodo/xbmc/cores/VideoRenderers/OverlayRendererDX.cpp	2013-03-11 02:09:46.430994170 +0000
+++ xbmc/xbmc/cores/VideoRenderers/OverlayRendererDX.cpp	2013-02-11 10:42:50.782893604 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/OverlayRendererDX.h xbmc/xbmc/cores/VideoRenderers/OverlayRendererDX.h
--- xbmcfrodo/xbmc/cores/VideoRenderers/OverlayRendererDX.h	2013-03-11 02:09:46.430994170 +0000
+++ xbmc/xbmc/cores/VideoRenderers/OverlayRendererDX.h	2013-02-11 10:42:50.782893604 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/OverlayRendererGL.cpp xbmc/xbmc/cores/VideoRenderers/OverlayRendererGL.cpp
--- xbmcfrodo/xbmc/cores/VideoRenderers/OverlayRendererGL.cpp	2013-03-11 02:09:46.440993984 +0000
+++ xbmc/xbmc/cores/VideoRenderers/OverlayRendererGL.cpp	2013-02-23 14:22:23.625815246 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *      Initial code sponsored by: Voddler Inc (voddler.com)
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/OverlayRendererGL.h xbmc/xbmc/cores/VideoRenderers/OverlayRendererGL.h
--- xbmcfrodo/xbmc/cores/VideoRenderers/OverlayRendererGL.h	2013-03-11 02:09:46.440993984 +0000
+++ xbmc/xbmc/cores/VideoRenderers/OverlayRendererGL.h	2013-02-11 10:42:50.782893604 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *      Initial code sponsored by: Voddler Inc (voddler.com)
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/OverlayRendererUtil.cpp xbmc/xbmc/cores/VideoRenderers/OverlayRendererUtil.cpp
--- xbmcfrodo/xbmc/cores/VideoRenderers/OverlayRendererUtil.cpp	2013-02-16 18:48:35.354453573 +0000
+++ xbmc/xbmc/cores/VideoRenderers/OverlayRendererUtil.cpp	2013-02-10 14:23:18.376517929 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/OverlayRendererUtil.h xbmc/xbmc/cores/VideoRenderers/OverlayRendererUtil.h
--- xbmcfrodo/xbmc/cores/VideoRenderers/OverlayRendererUtil.h	2013-02-16 18:48:35.354453573 +0000
+++ xbmc/xbmc/cores/VideoRenderers/OverlayRendererUtil.h	2013-02-10 14:23:18.376517929 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/RenderCapture.cpp xbmc/xbmc/cores/VideoRenderers/RenderCapture.cpp
--- xbmcfrodo/xbmc/cores/VideoRenderers/RenderCapture.cpp	2013-02-16 18:48:35.354453573 +0000
+++ xbmc/xbmc/cores/VideoRenderers/RenderCapture.cpp	2013-02-10 14:23:18.386517735 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/RenderCapture.h xbmc/xbmc/cores/VideoRenderers/RenderCapture.h
--- xbmcfrodo/xbmc/cores/VideoRenderers/RenderCapture.h	2013-02-16 18:48:35.354453573 +0000
+++ xbmc/xbmc/cores/VideoRenderers/RenderCapture.h	2013-02-10 14:23:18.386517735 +0000
@@ -6,7 +6,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/RenderFlags.h xbmc/xbmc/cores/VideoRenderers/RenderFlags.h
--- xbmcfrodo/xbmc/cores/VideoRenderers/RenderFlags.h	2013-02-16 18:48:35.354453573 +0000
+++ xbmc/xbmc/cores/VideoRenderers/RenderFlags.h	2013-02-10 14:23:18.386517735 +0000
@@ -2,7 +2,7 @@
 #define _RENDER_FLAGS_H_
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/RenderFormats.h xbmc/xbmc/cores/VideoRenderers/RenderFormats.h
--- xbmcfrodo/xbmc/cores/VideoRenderers/RenderFormats.h	2013-02-16 18:48:35.374453176 +0000
+++ xbmc/xbmc/cores/VideoRenderers/RenderFormats.h	2013-02-10 14:23:18.386517735 +0000
@@ -1,7 +1,7 @@
 #ifndef _RENDER_FORMATS_H_
 #define _RENDER_FORMATS_H_
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/RenderManager.cpp xbmc/xbmc/cores/VideoRenderers/RenderManager.cpp
--- xbmcfrodo/xbmc/cores/VideoRenderers/RenderManager.cpp	2013-02-16 18:48:35.374453176 +0000
+++ xbmc/xbmc/cores/VideoRenderers/RenderManager.cpp	2013-04-05 11:38:43.846815883 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -34,6 +34,7 @@
 #include "settings/Settings.h"
 #include "settings/GUISettings.h"
 #include "settings/AdvancedSettings.h"
+#include "settings/MediaSettings.h"
 
 #if defined(HAS_GL)
   #include "LinuxRendererGL.h"
@@ -64,7 +65,8 @@
 {
 public:
   CRetakeLock(CSharedSection &section, bool immidiate = true, CCriticalSection &owned = g_graphicsContext)
-    : m_owned(owned)
+    : m_lock (NULL  ),
+      m_owned(owned )
   {
     m_count = m_owned.exit();
     m_lock  = new T(section);
@@ -103,6 +105,10 @@
   m_bReconfigured = false;
   m_hasCaptures = false;
   m_displayLatency = 0.0f;
+  m_presentcorr = 0.0;
+  m_presenterr = 0.0;
+  memset(&m_errorbuff, 0, ERRORBUFFSIZE);
+  m_errorindex = 0;
 }
 
 CXBMCRenderManager::~CXBMCRenderManager()
@@ -495,7 +501,7 @@
         if (capture->IsAsync() && !(capture->GetFlags() & CAPTUREFLAG_IMMEDIATELY))
           RenderCapture(capture);
 
-        it++;
+        ++it;
       }
       else
       {
@@ -504,7 +510,7 @@
     }
     else
     {
-      it++;
+      ++it;
     }
   }
 
@@ -564,10 +570,8 @@
     m_presentfield = sync;
     m_presentstep  = PRESENT_FLIP;
     m_presentsource = source;
-    EDEINTERLACEMODE deinterlacemode = g_settings.m_currentVideoSettings.m_DeinterlaceMode;
-    EINTERLACEMETHOD interlacemethod = AutoInterlaceMethodInternal(g_settings.m_currentVideoSettings.m_InterlaceMethod);
-
-    bool invert = false;
+    EDEINTERLACEMODE deinterlacemode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+    EINTERLACEMETHOD interlacemethod = AutoInterlaceMethodInternal(CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod);
 
     if (deinterlacemode == VS_DEINTERLACEMODE_OFF)
       m_presentmethod = PRESENT_METHOD_SINGLE;
@@ -577,6 +581,7 @@
         m_presentmethod = PRESENT_METHOD_SINGLE;
       else
       {
+        bool invert = false;
         if      (interlacemethod == VS_INTERLACEMETHOD_RENDER_BLEND)            m_presentmethod = PRESENT_METHOD_BLEND;
         else if (interlacemethod == VS_INTERLACEMETHOD_RENDER_WEAVE)            m_presentmethod = PRESENT_METHOD_WEAVE;
         else if (interlacemethod == VS_INTERLACEMETHOD_RENDER_WEAVE_INVERTED) { m_presentmethod = PRESENT_METHOD_WEAVE ; invert = true; }
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/RenderManager.h xbmc/xbmc/cores/VideoRenderers/RenderManager.h
--- xbmcfrodo/xbmc/cores/VideoRenderers/RenderManager.h	2013-02-16 18:48:35.374453176 +0000
+++ xbmc/xbmc/cores/VideoRenderers/RenderManager.h	2013-02-10 14:23:18.386517735 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/VideoShaders/ConvolutionKernels.cpp xbmc/xbmc/cores/VideoRenderers/VideoShaders/ConvolutionKernels.cpp
--- xbmcfrodo/xbmc/cores/VideoRenderers/VideoShaders/ConvolutionKernels.cpp	2013-02-16 18:48:35.394452779 +0000
+++ xbmc/xbmc/cores/VideoRenderers/VideoShaders/ConvolutionKernels.cpp	2013-02-10 14:23:18.396517540 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/VideoShaders/ConvolutionKernels.h xbmc/xbmc/cores/VideoRenderers/VideoShaders/ConvolutionKernels.h
--- xbmcfrodo/xbmc/cores/VideoRenderers/VideoShaders/ConvolutionKernels.h	2013-02-16 18:48:35.394452779 +0000
+++ xbmc/xbmc/cores/VideoRenderers/VideoShaders/ConvolutionKernels.h	2013-04-05 11:38:43.846815883 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -36,7 +36,8 @@
     uint8_t* GetUint8Pixels()    { return m_uint8pixels; }
 
   private:
-
+    CConvolutionKernel(const CConvolutionKernel&);
+    CConvolutionKernel& operator=(const CConvolutionKernel&);
     void Lanczos2();
     void Lanczos3Fast();
     void Lanczos3();
@@ -44,9 +45,9 @@
     void Spline36();
     void Bicubic(double B, double C);
 
-    double LanczosWeight(double x, double radius);
-    double Spline36Weight(double x);
-    double BicubicWeight(double x, double B, double C);
+    static double LanczosWeight(double x, double radius);
+    static double Spline36Weight(double x);
+    static double BicubicWeight(double x, double B, double C);
 
     void ToIntFract();
     void ToUint8();
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h xbmc/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h
--- xbmcfrodo/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h	2013-02-16 18:48:35.394452779 +0000
+++ xbmc/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h	2013-02-10 14:23:18.396517540 +0000
@@ -2,7 +2,7 @@
 #define __VIDEOFILTER_SHADER_H__
 
 /*
- *      Copyright (C) 2007-2012 Team XBMC
+ *      Copyright (C) 2007-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/VideoShaders/WinVideoFilter.cpp xbmc/xbmc/cores/VideoRenderers/VideoShaders/WinVideoFilter.cpp
--- xbmcfrodo/xbmc/cores/VideoRenderers/VideoShaders/WinVideoFilter.cpp	2013-02-16 18:48:35.414452384 +0000
+++ xbmc/xbmc/cores/VideoRenderers/VideoShaders/WinVideoFilter.cpp	2013-04-05 11:38:43.856815703 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2007-2012 Team XBMC
+ *      Copyright (C) 2007-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -33,6 +33,10 @@
 CYUV2RGBMatrix::CYUV2RGBMatrix()
 {
   m_NeedRecalc = true;
+  m_blacklevel  = 0.0f;
+  m_contrast    = 0.0f;
+  m_flags       = 0;
+  m_format      = RENDER_FMT_NONE;
 }
 
 void CYUV2RGBMatrix::SetParameters(float contrast, float blacklevel, unsigned int flags, ERenderFormat format)
@@ -159,7 +163,7 @@
 
   LPDIRECT3DSURFACE9 oldRT = 0;
   // The render target will be overriden: save the caller's original RT
-  if (vecRT != NULL && vecRT->size() > 0)
+  if (vecRT != NULL && !vecRT->empty())
     pD3DDevice->GetRenderTarget(0, &oldRT);
 
   pD3DDevice->SetFVF(m_FVF);
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/VideoShaders/WinVideoFilter.h xbmc/xbmc/cores/VideoRenderers/VideoShaders/WinVideoFilter.h
--- xbmcfrodo/xbmc/cores/VideoRenderers/VideoShaders/WinVideoFilter.h	2013-02-16 18:48:35.414452384 +0000
+++ xbmc/xbmc/cores/VideoRenderers/VideoShaders/WinVideoFilter.h	2013-04-05 11:38:43.856815703 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2007-2012 Team XBMC
+ *      Copyright (C) 2007-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -46,7 +46,12 @@
 class CWinShader
 {
 protected:
-  CWinShader() {}
+  CWinShader() :
+    m_vbsize(0),
+    m_FVF(0),
+    m_vertsize(0),
+    m_primitivesCount(0)
+  {}
   virtual ~CWinShader();
   virtual bool CreateVertexBuffer(DWORD FVF, unsigned int vertCount, unsigned int vertSize, unsigned int primitivesCount);
   virtual bool LockVertexBuffer(void **data);
@@ -74,6 +79,13 @@
                       float brightness,
                       unsigned int flags,
                       YUVBuffer* YUVbuf);
+  CYUV2RGBShader() : 
+    m_sourceWidth (0),
+    m_sourceHeight(0),
+    m_format      (RENDER_FMT_NONE)    
+    {
+      memset(&m_texSteps,0,sizeof(m_texSteps));
+    }
   virtual ~CYUV2RGBShader();
 
 protected:
@@ -138,6 +150,7 @@
                                unsigned int destWidth, unsigned int destHeight,
                                CRect sourceRect,
                                CRect destRect);
+    CConvolutionShader1Pass() : m_sourceWidth (0), m_sourceHeight(0) {}
 
 protected:
   virtual void PrepareParameters(unsigned int sourceWidth, unsigned int sourceHeight,
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp xbmc/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
--- xbmcfrodo/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp	2013-02-16 18:48:35.414452384 +0000
+++ xbmc/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp	2013-03-01 21:47:36.743947119 +0000
@@ -24,6 +24,7 @@
 #include "YUV2RGBShader.h"
 #include "settings/AdvancedSettings.h"
 #include "guilib/TransformMatrix.h"
+#include "windowing/WindowingFactory.h"
 #include "utils/log.h"
 #if defined(HAS_GL) || defined(HAS_GLES)
 #include "utils/GLUtils.h"
@@ -106,8 +107,20 @@
       coef.m[row][col] = conv[col][row];
   coef.identity = false;
 
+
+  if(g_Windowing.UseLimitedColor())
+  {
+    matrix *= TransformMatrix::CreateTranslation(+ 16.0f / 255
+                                               , + 16.0f / 255
+                                               , + 16.0f / 255);
+    matrix *= TransformMatrix::CreateScaler((235 - 16) / 255.0f
+                                          , (235 - 16) / 255.0f
+                                          , (235 - 16) / 255.0f);
+  }
+
   matrix *= coef;
   matrix *= TransformMatrix::CreateTranslation(0.0, -0.5, -0.5);
+
   if (!(flags & CONF_FLAGS_YUV_FULLRANGE))
   {
     matrix *= TransformMatrix::CreateScaler(255.0f / (235 - 16)
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h xbmc/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
--- xbmcfrodo/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h	2013-02-16 18:48:35.414452384 +0000
+++ xbmc/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h	2013-02-10 14:23:18.396517540 +0000
@@ -2,7 +2,7 @@
 #define __YUV2RGB_SHADERS_H__
 
 /*
- *      Copyright (C) 2007-2012 Team XBMC
+ *      Copyright (C) 2007-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/WinRenderer.cpp xbmc/xbmc/cores/VideoRenderers/WinRenderer.cpp
--- xbmcfrodo/xbmc/cores/VideoRenderers/WinRenderer.cpp	2013-02-19 17:48:55.471699631 +0000
+++ xbmc/xbmc/cores/VideoRenderers/WinRenderer.cpp	2013-04-05 11:38:43.856815703 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -22,8 +22,10 @@
 
 #include "WinRenderer.h"
 #include "Util.h"
+#include "settings/DisplaySettings.h"
 #include "settings/Settings.h"
 #include "settings/GUISettings.h"
+#include "settings/MediaSettings.h"
 #include "guilib/Texture.h"
 #include "windowing/WindowingFactory.h"
 #include "settings/AdvancedSettings.h"
@@ -83,6 +85,13 @@
 
   m_sw_scale_ctx = NULL;
   m_dllSwScale = NULL;
+  m_destWidth = 0;
+  m_destHeight = 0;
+  m_dllAvUtil = NULL;
+  m_dllAvCodec = NULL;
+  m_bConfigured = false;
+  m_clearColour = 0;
+  m_format = RENDER_FMT_NONE;
 }
 
 CWinRenderer::~CWinRenderer()
@@ -232,9 +241,9 @@
   // calculate the input frame aspect ratio
   CalculateFrameAspectRatio(d_width, d_height);
   ChooseBestResolution(fps);
-  m_destWidth = g_settings.m_ResInfo[m_resolution].iWidth;
-  m_destHeight = g_settings.m_ResInfo[m_resolution].iHeight;
-  SetViewMode(g_settings.m_currentVideoSettings.m_ViewMode);
+  m_destWidth = CDisplaySettings::Get().GetResolutionInfo(m_resolution).iWidth;
+  m_destHeight = CDisplaySettings::Get().GetResolutionInfo(m_resolution).iHeight;
+  SetViewMode(CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode);
   ManageDisplay();
 
   m_bConfigured = true;
@@ -364,7 +373,7 @@
   CSingleLock lock(g_graphicsContext);
   m_bConfigured = false;
   UnInit();
-  m_resolution = g_guiSettings.m_LookAndFeelResolution;
+  m_resolution = CDisplaySettings::Get().GetCurrentResolution();
   if ( m_resolution == RES_WINDOW )
     m_resolution = RES_DESKTOP;
 
@@ -510,7 +519,7 @@
     bool scaleUp = (int)m_sourceHeight < g_graphicsContext.GetHeight() && (int)m_sourceWidth < g_graphicsContext.GetWidth();
     bool scaleFps = m_fps < (g_advancedSettings.m_videoAutoScaleMaxFps + 0.01f);
 
-    if (Supports(VS_SCALINGMETHOD_LANCZOS3_FAST) && scaleSD && scaleUp && scaleFps)
+    if (scaleSD && scaleUp && scaleFps && Supports(VS_SCALINGMETHOD_LANCZOS3_FAST))
     {
       m_scalingMethod = VS_SCALINGMETHOD_LANCZOS3_FAST;
       m_bUseHQScaler = true;
@@ -582,12 +591,12 @@
 
 void CWinRenderer::UpdateVideoFilter()
 {
-  if (m_scalingMethodGui == g_settings.m_currentVideoSettings.m_ScalingMethod && m_bFilterInitialized)
+  if (m_scalingMethodGui == CMediaSettings::Get().GetCurrentVideoSettings().m_ScalingMethod && m_bFilterInitialized)
     return;
 
   m_bFilterInitialized = true;
 
-  m_scalingMethodGui = g_settings.m_currentVideoSettings.m_ScalingMethod;
+  m_scalingMethodGui = CMediaSettings::Get().GetCurrentVideoSettings().m_ScalingMethod;
   m_scalingMethod    = m_scalingMethodGui;
 
   if (!Supports(m_scalingMethod))
@@ -762,9 +771,9 @@
   float srcWidth  = (float)srcDesc.Width;
   float srcHeight = (float)srcDesc.Height;
 
-  bool cbcontrol          = (g_settings.m_currentVideoSettings.m_Contrast != 50.0f || g_settings.m_currentVideoSettings.m_Brightness != 50.0f);
-  unsigned int contrast   = (unsigned int)(g_settings.m_currentVideoSettings.m_Contrast *.01f * 255.0f); // we have to divide by two here/multiply by two later
-  unsigned int brightness = (unsigned int)(g_settings.m_currentVideoSettings.m_Brightness * .01f * 255.0f);
+  bool cbcontrol          = (CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast != 50.0f || CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness != 50.0f);
+  unsigned int contrast   = (unsigned int)(CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast *.01f * 255.0f); // we have to divide by two here/multiply by two later
+  unsigned int brightness = (unsigned int)(CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness * .01f * 255.0f);
 
   D3DCOLOR diffuse  = D3DCOLOR_ARGB(255, contrast, contrast, contrast);
   D3DCOLOR specular = D3DCOLOR_ARGB(255, brightness, brightness, brightness);
@@ -796,46 +805,46 @@
 
   if (!cbcontrol)
   {
-    hr = pD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
-    hr = pD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
-    hr = pD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
-    hr = pD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
-    hr = pD3DDev->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_DISABLE );
-    hr = pD3DDev->SetTextureStageState( 1, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
+    pD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
+    pD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
+    pD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
+    pD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
+    pD3DDev->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_DISABLE );
+    pD3DDev->SetTextureStageState( 1, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
   }
   else
   {
-    hr = pD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE2X );
-    hr = pD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
-    hr = pD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
-    hr = pD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
-    hr = pD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE );
-
-    hr = pD3DDev->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_ADDSIGNED );
-    hr = pD3DDev->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_CURRENT );
-    hr = pD3DDev->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_SPECULAR );
-    hr = pD3DDev->SetTextureStageState( 1, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
-    hr = pD3DDev->SetTextureStageState( 1, D3DTSS_ALPHAARG1, D3DTA_CURRENT );
-
-    hr = pD3DDev->SetTextureStageState( 2, D3DTSS_COLOROP, D3DTOP_DISABLE );
-    hr = pD3DDev->SetTextureStageState( 2, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
-  }
-
-  hr = pD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
-  hr = pD3DDev->SetRenderState(D3DRS_LIGHTING, FALSE);
-  hr = pD3DDev->SetRenderState(D3DRS_ZENABLE, FALSE);
-  hr = pD3DDev->SetRenderState(D3DRS_STENCILENABLE, FALSE);
-  hr = pD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
-  hr = pD3DDev->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
-  hr = pD3DDev->SetRenderState(D3DRS_SCISSORTESTENABLE, FALSE);
-  hr = pD3DDev->SetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALPHA|D3DCOLORWRITEENABLE_BLUE|D3DCOLORWRITEENABLE_GREEN|D3DCOLORWRITEENABLE_RED); 
-
-  hr = pD3DDev->SetSamplerState(0, D3DSAMP_MAGFILTER, m_TextureFilter);
-  hr = pD3DDev->SetSamplerState(0, D3DSAMP_MINFILTER, m_TextureFilter);
-  hr = pD3DDev->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
-  hr = pD3DDev->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
+    pD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE2X );
+    pD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
+    pD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
+    pD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
+    pD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE );
+
+    pD3DDev->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_ADDSIGNED );
+    pD3DDev->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_CURRENT );
+    pD3DDev->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_SPECULAR );
+    pD3DDev->SetTextureStageState( 1, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
+    pD3DDev->SetTextureStageState( 1, D3DTSS_ALPHAARG1, D3DTA_CURRENT );
+
+    pD3DDev->SetTextureStageState( 2, D3DTSS_COLOROP, D3DTOP_DISABLE );
+    pD3DDev->SetTextureStageState( 2, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
+  }
+
+  pD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
+  pD3DDev->SetRenderState(D3DRS_LIGHTING, FALSE);
+  pD3DDev->SetRenderState(D3DRS_ZENABLE, FALSE);
+  pD3DDev->SetRenderState(D3DRS_STENCILENABLE, FALSE);
+  pD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
+  pD3DDev->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
+  pD3DDev->SetRenderState(D3DRS_SCISSORTESTENABLE, FALSE);
+  pD3DDev->SetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALPHA|D3DCOLORWRITEENABLE_BLUE|D3DCOLORWRITEENABLE_GREEN|D3DCOLORWRITEENABLE_RED); 
+
+  pD3DDev->SetSamplerState(0, D3DSAMP_MAGFILTER, m_TextureFilter);
+  pD3DDev->SetSamplerState(0, D3DSAMP_MINFILTER, m_TextureFilter);
+  pD3DDev->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
+  pD3DDev->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
 
-  hr = pD3DDev->SetFVF(D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_SPECULAR | D3DFVF_TEX1);
+  pD3DDev->SetFVF(D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_SPECULAR | D3DFVF_TEX1);
 
   if (FAILED(hr = pD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, vertex, sizeof(VERTEX))))
     CLog::Log(LOGERROR, __FUNCTION__": DrawPrimitiveUP failed. %s", CRenderSystemDX::GetErrorDescription(hr).c_str());
@@ -861,8 +870,8 @@
   if (!m_bUseHQScaler)
   {
       m_colorShader->Render(m_sourceRect, m_destRect,
-                            g_settings.m_currentVideoSettings.m_Contrast,
-                            g_settings.m_currentVideoSettings.m_Brightness,
+                            CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast,
+                            CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness,
                             m_iFlags,
                             (YUVBuffer*)m_VideoBuffers[m_iYV12RenderBuffer]);
   }
@@ -879,8 +888,8 @@
     CRect rtRect(0.0f, 0.0f, m_sourceWidth, m_sourceHeight);
 
     m_colorShader->Render(srcRect, rtRect,
-                          g_settings.m_currentVideoSettings.m_Contrast,
-                          g_settings.m_currentVideoSettings.m_Brightness,
+                          CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast,
+                          CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness,
                           m_iFlags,
                           (YUVBuffer*)m_VideoBuffers[m_iYV12RenderBuffer]);
 
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/WinRenderer.h xbmc/xbmc/cores/VideoRenderers/WinRenderer.h
--- xbmcfrodo/xbmc/cores/VideoRenderers/WinRenderer.h	2013-02-16 18:48:35.424452185 +0000
+++ xbmc/xbmc/cores/VideoRenderers/WinRenderer.h	2013-04-05 11:38:43.866815524 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -112,6 +112,7 @@
 
 struct YUVBuffer : SVideoBuffer
 {
+  YUVBuffer() : m_width (0), m_height(0), m_format(RENDER_FMT_NONE), m_activeplanes(0) {}
   ~YUVBuffer();
   bool Create(ERenderFormat format, unsigned int width, unsigned int height);
   virtual void Release();
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/legacy/ComboRenderer.cpp xbmc/xbmc/cores/VideoRenderers/legacy/ComboRenderer.cpp
--- xbmcfrodo/xbmc/cores/VideoRenderers/legacy/ComboRenderer.cpp	2013-02-16 18:48:35.424452185 +0000
+++ xbmc/xbmc/cores/VideoRenderers/legacy/ComboRenderer.cpp	2013-04-05 11:38:43.866815524 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -34,6 +34,8 @@
   m_hPixelShader = 0;
   m_iYUY2RenderBuffer = 0;
   m_iYUY2Buffers = 2;
+  m_iScreenWidth = 0;
+  m_iScreenHeight = 0;
 }
 
 void CComboRenderer::DeleteYUY2Texture(int index)
@@ -116,8 +118,8 @@
   float fOffsetX1 = (float)rv.left;
   float fOffsetY1 = (float)rv.top;
   float fPixelRatio = g_settings.m_fPixelRatio;
-  float fMaxScreenWidth = (float)g_settings.m_ResInfo[g_graphicsContext.GetVideoResolution()].iWidth;
-  float fMaxScreenHeight = (float)g_settings.m_ResInfo[g_graphicsContext.GetVideoResolution()].iHeight;
+  float fMaxScreenWidth = (float)CDisplaySettings::Get().GetResolutionInfo(g_graphicsContext.GetVideoResolution()).iWidth;
+  float fMaxScreenHeight = (float)CDisplaySettings::Get().GetResolutionInfo(g_graphicsContext.GetVideoResolution()).iHeight;
   if (fOffsetX1 < 0) fOffsetX1 = 0;
   if (fOffsetY1 < 0) fOffsetY1 = 0;
   if (fScreenWidth + fOffsetX1 > fMaxScreenWidth) fScreenWidth = fMaxScreenWidth - fOffsetX1;
@@ -132,10 +134,10 @@
   }
 
   // source rect
-  rs.left = g_settings.m_currentVideoSettings.m_CropLeft;
-  rs.top = g_settings.m_currentVideoSettings.m_CropTop;
-  rs.right = m_iSourceWidth - g_settings.m_currentVideoSettings.m_CropRight;
-  rs.bottom = m_iSourceHeight - g_settings.m_currentVideoSettings.m_CropBottom;
+  rs.left = CMediaSettings::Get().GetCurrentVideoSettings().m_CropLeft;
+  rs.top = CMediaSettings::Get().GetCurrentVideoSettings().m_CropTop;
+  rs.right = m_iSourceWidth - CMediaSettings::Get().GetCurrentVideoSettings().m_CropRight;
+  rs.bottom = m_iSourceHeight - CMediaSettings::Get().GetCurrentVideoSettings().m_CropBottom;
 
   CalcNormalDisplayRect(fOffsetX1, fOffsetY1, fScreenWidth, fScreenHeight, GetAspectRatio() * fPixelRatio, g_settings.m_fZoomAmount);
 
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/legacy/ComboRenderer.h xbmc/xbmc/cores/VideoRenderers/legacy/ComboRenderer.h
--- xbmcfrodo/xbmc/cores/VideoRenderers/legacy/ComboRenderer.h	2013-02-16 18:48:35.424452185 +0000
+++ xbmc/xbmc/cores/VideoRenderers/legacy/ComboRenderer.h	2013-02-10 14:23:18.406517345 +0000
@@ -2,7 +2,7 @@
 #define COMBO_RENDERER
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/legacy/RGBRendererV2.cpp xbmc/xbmc/cores/VideoRenderers/legacy/RGBRendererV2.cpp
--- xbmcfrodo/xbmc/cores/VideoRenderers/legacy/RGBRendererV2.cpp	2013-02-16 18:48:35.444451788 +0000
+++ xbmc/xbmc/cores/VideoRenderers/legacy/RGBRendererV2.cpp	2013-04-05 11:38:43.866815524 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -37,6 +37,8 @@
   m_UVLookup = NULL;
   m_UVErrorLookup = NULL;
   m_motionpass = 5;
+  m_444GeneratedFull = false;
+  m_444RenderBuffer = 0;
   memset(&m_yuvcoef_last, 0, sizeof(YUVCOEF));
   memset(&m_yuvrange_last, 0, sizeof(YUVRANGE));
 }
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/legacy/RGBRendererV2.h xbmc/xbmc/cores/VideoRenderers/legacy/RGBRendererV2.h
--- xbmcfrodo/xbmc/cores/VideoRenderers/legacy/RGBRendererV2.h	2013-02-16 18:48:35.444451788 +0000
+++ xbmc/xbmc/cores/VideoRenderers/legacy/RGBRendererV2.h	2013-02-10 14:23:18.416517151 +0000
@@ -2,7 +2,7 @@
 #define RGBV2_RENDERER
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/VideoRenderers/yuv2rgb.neon.h xbmc/xbmc/cores/VideoRenderers/yuv2rgb.neon.h
--- xbmcfrodo/xbmc/cores/VideoRenderers/yuv2rgb.neon.h	2013-02-16 18:48:35.444451788 +0000
+++ xbmc/xbmc/cores/VideoRenderers/yuv2rgb.neon.h	2013-02-10 14:23:18.416517151 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/amlplayer/AMLPlayer.cpp xbmc/xbmc/cores/amlplayer/AMLPlayer.cpp
--- xbmcfrodo/xbmc/cores/amlplayer/AMLPlayer.cpp	2013-02-16 18:48:35.464451392 +0000
+++ xbmc/xbmc/cores/amlplayer/AMLPlayer.cpp	2013-04-05 11:38:43.876815344 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -27,6 +27,7 @@
 #include "GUIInfoManager.h"
 #include "video/VideoThumbLoader.h"
 #include "Util.h"
+#include "cores/AudioEngine/Utils/AEUtil.h"
 #include "cores/VideoRenderers/RenderFlags.h"
 #include "cores/VideoRenderers/RenderFormats.h"
 #include "cores/VideoRenderers/RenderManager.h"
@@ -315,7 +316,7 @@
 void CAMLSubTitleThread::UpdateSubtitle(CStdString &subtitle, int64_t elapsed_ms)
 {
   CSingleLock lock(m_subtitle_csection);
-  if (m_subtitle_strings.size())
+  if (!m_subtitle_strings.empty())
   {
     AMLSubtitle *amlsubtitle;
     // remove any expired subtitles
@@ -326,7 +327,7 @@
       if (elapsed_ms > amlsubtitle->endtime)
         it = m_subtitle_strings.erase(it);
       else
-        it++;
+        ++it;
     }
 
     // find the current subtitle
@@ -339,7 +340,7 @@
         subtitle = amlsubtitle->string;
         break;
       }
-      it++;
+      ++it;
     }
   }
 }
@@ -363,7 +364,6 @@
       int sub_size = m_dll->codec_get_sub_size_fd(m_subtitle_codec);
       if (sub_size > 0)
       {
-        int sub_type = 0, sub_pts = 0;
         // calloc sub_size + 1 so we auto terminate the string
         char *sub_buffer = (char*)calloc(sub_size + 1, 1);
         m_dll->codec_read_sub_data_fd(m_subtitle_codec, sub_buffer, sub_size);
@@ -380,10 +380,9 @@
             CSingleLock lock(m_subtitle_csection);
 
             AMLSubtitle *subtitle = new AMLSubtitle;
-
-            sub_type  = (sub_buffer[5] << 16)  | (sub_buffer[6] << 8)   | sub_buffer[7];
+            int sub_type  = (sub_buffer[5] << 16)  | (sub_buffer[6] << 8)   | sub_buffer[7];
             // sub_pts are in ffmpeg timebase, not ms timebase, convert it.
-            sub_pts = (sub_buffer[12] << 24) | (sub_buffer[13] << 16) | (sub_buffer[14] << 8) | sub_buffer[15];
+            int sub_pts = (sub_buffer[12] << 24) | (sub_buffer[13] << 16) | (sub_buffer[14] << 8) | sub_buffer[15];
 
             /* TODO: handle other subtitle codec types
             // subtitle codecs
@@ -502,19 +501,45 @@
 CAMLPlayer::CAMLPlayer(IPlayerCallback &callback)
   : IPlayer(callback),
   CThread("CAMLPlayer"),
-  m_ready(true)
+  m_cpu                   (0            ),
+  m_speed                 (0            ),
+  m_paused                (false        ),
+  m_bAbortRequest         (false        ),
+  m_ready                 (true         ),
+  m_audio_index           (0            ),
+  m_audio_count           (0            ),
+  m_audio_delay           (0            ),
+  m_audio_passthrough_ac3 (false        ),
+  m_audio_passthrough_dts (false        ),
+  m_audio_mute            (false        ),
+  m_audio_volume          (0.0f         ),
+  m_video_index           (0            ),
+  m_video_count           (0            ),
+  m_video_width           (0            ),
+  m_video_height          (0            ),
+  m_video_fps_numerator   (0            ),
+  m_video_fps_denominator (0            ),
+  m_subtitle_index        (0            ),
+  m_subtitle_count        (0            ),
+  m_subtitle_show         (false        ),
+  m_subtitle_delay        (0            ),
+  m_subtitle_thread       (NULL         ),
+  m_chapter_index         (0            ),
+  m_chapter_count         (0            ),
+  m_show_mainvideo        (0            ),
+  m_view_mode             (0            ),
+  m_zoom                  (0            ),
+  m_contrast              (0            ),
+  m_brightness            (0            )
 {
   m_dll = new DllLibAmplayer;
   m_dll->Load();
   m_pid = -1;
-  m_speed = 0;
-  m_paused = false;
 #if defined(_DEBUG)
   m_log_level = 5;
 #else
   m_log_level = 3;
 #endif
-  m_bAbortRequest = false;
 
   // for external subtitles
   m_dvdOverlayContainer = new CDVDOverlayContainer;
@@ -813,7 +838,7 @@
 void CAMLPlayer::GetAudioInfo(CStdString &strAudioInfo)
 {
   CSingleLock lock(m_aml_csection);
-  if (m_audio_streams.size() == 0 || m_audio_index > (int)(m_audio_streams.size() - 1))
+  if (m_audio_streams.empty() || m_audio_index > (int)(m_audio_streams.size() - 1))
     return;
 
   strAudioInfo.Format("Audio stream (%s) [Kb/s:%.2f]",
@@ -824,7 +849,7 @@
 void CAMLPlayer::GetVideoInfo(CStdString &strVideoInfo)
 {
   CSingleLock lock(m_aml_csection);
-  if (m_video_streams.size() == 0 || m_video_index > (int)(m_video_streams.size() - 1))
+  if (m_video_streams.empty() || m_video_index > (int)(m_video_streams.size() - 1))
     return;
 
   strVideoInfo.Format("Video stream (%s) [fr:%.3f Mb/s:%.2f]",
@@ -845,25 +870,6 @@
   return m_audio_index;
 }
 
-void CAMLPlayer::GetAudioStreamName(int iStream, CStdString &strStreamName)
-{
-  //CLog::Log(LOGDEBUG, "CAMLPlayer::GetAudioStreamName");
-  CSingleLock lock(m_aml_csection);
-
-  strStreamName.Format("Undefined");
-
-  if (iStream > (int)m_audio_streams.size() || iStream < 0)
-    return;
-
-  if ( m_audio_streams[iStream]->language.size())
-  {
-    CStdString name;
-    g_LangCodeExpander.Lookup( name, m_audio_streams[iStream]->language);
-    strStreamName = name;
-  }
-
-}
-
 void CAMLPlayer::SetAudioStream(int SetAudioStream)
 {
   //CLog::Log(LOGDEBUG, "CAMLPlayer::SetAudioStream");
@@ -925,35 +931,18 @@
     return -1;
 }
 
-void CAMLPlayer::GetSubtitleName(int iStream, CStdString &strStreamName)
+void CAMLPlayer::GetSubtitleStreamInfo(int index, SPlayerSubtitleStreamInfo &info)
 {
   CSingleLock lock(m_aml_csection);
 
-  strStreamName = "";
-
-  if (iStream > (int)m_subtitle_streams.size() || iStream < 0)
+  if (index > (int)m_subtitle_streams.size() -1 || index < 0)
     return;
 
-  if (m_subtitle_streams[m_subtitle_index]->source == STREAM_SOURCE_NONE)
-  {
-    if ( m_subtitle_streams[iStream]->language.size())
-    {
-      CStdString name;
-      g_LangCodeExpander.Lookup(name, m_subtitle_streams[iStream]->language);
-      strStreamName = name;
-    }
-    else
-      strStreamName = g_localizeStrings.Get(13205); // Unknown
-  }
-  else
-  {
-    if(m_subtitle_streams[m_subtitle_index]->name.length() > 0)
-      strStreamName = m_subtitle_streams[m_subtitle_index]->name;
-    else
-      strStreamName = g_localizeStrings.Get(13205); // Unknown
-  }
+  info.language = m_subtitle_streams[index]->language;
+  info.name = m_subtitle_streams[m_subtitle_index]->name;
+
   if (m_log_level > 5)
-    CLog::Log(LOGDEBUG, "CAMLPlayer::GetSubtitleName, iStream(%d)", iStream);
+    CLog::Log(LOGDEBUG, "CAMLPlayer::GetSubtitleName, iStream(%d)", index);
 }
  
 void CAMLPlayer::SetSubtitle(int iStream)
@@ -988,7 +977,7 @@
 void CAMLPlayer::SetSubtitleVisible(bool bVisible)
 {
   m_subtitle_show = (bVisible && m_subtitle_count);
-  g_settings.m_currentVideoSettings.m_SubtitleOn = bVisible;
+  CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleOn = bVisible;
 
   if (m_subtitle_show  && m_subtitle_count)
   {
@@ -1015,16 +1004,6 @@
   g_renderManager.Update(bPauseDrawing);
 }
 
-void CAMLPlayer::GetVideoRect(CRect& SrcRect, CRect& DestRect)
-{
-  g_renderManager.GetVideoRect(SrcRect, DestRect);
-}
-
-void CAMLPlayer::GetVideoAspectRatio(float &fAR)
-{
-  fAR = g_renderManager.GetAspectRatio();
-}
-
 int CAMLPlayer::GetChapterCount()
 {
   return m_chapter_count;
@@ -1127,22 +1106,57 @@
   return m_duration_ms;
 }
 
-int CAMLPlayer::GetAudioBitrate()
+void CAMLPlayer::GetAudioStreamInfo(int index, SPlayerAudioStreamInfo &info)
 {
   CSingleLock lock(m_aml_csection);
-  if (m_audio_streams.size() == 0 || m_audio_index > (int)(m_audio_streams.size() - 1))
-    return 0;
+  if (index < 0 || m_audio_streams.empty() || index > (int)(m_audio_streams.size() - 1))
+    return;
+
+  info.bitrate = m_audio_streams[index]->bit_rate;
+
+  info.language = m_audio_streams[index]->language;
 
-  return m_audio_streams[m_audio_index]->bit_rate;
+  info.channels = m_audio_streams[index]->channel;
+
+  info.audioCodecName = AudioCodecName(m_audio_streams[index]->format);
+
+  if (info.audioCodecName.size())
+    info.name = info.audioCodecName + " ";
+
+  switch(info.channels)
+  {
+  case 1:
+    info.name += "Mono";
+    break;
+  case 2: 
+    info.name += "Stereo";
+    break;
+  case 6: 
+    info.name += "5.1";
+    break;
+  case 7:
+    info.name += "6.1";
+    break;
+  case 8:
+    info.name += "7.1";
+    break;
+  default:
+    char temp[32];
+    sprintf(temp, "%d-chs", info.channels);
+    info.name += temp;
+  }
 }
 
-int CAMLPlayer::GetVideoBitrate()
+void CAMLPlayer::GetVideoStreamInfo(SPlayerVideoStreamInfo &info)
 {
   CSingleLock lock(m_aml_csection);
-  if (m_video_streams.size() == 0 || m_video_index > (int)(m_video_streams.size() - 1))
-    return 0;
+  if (m_video_streams.empty() || m_video_index > (int)(m_video_streams.size() - 1))
+    return;
 
-  return m_video_streams[m_video_index]->bit_rate;
+  info.bitrate = m_video_streams[m_video_index]->bit_rate;
+  info.videoCodecName = VideoCodecName(m_video_streams[m_video_index]->format);
+  info.videoAspectRatio = g_renderManager.GetAspectRatio();
+  g_renderManager.GetVideoRect(info.SrcRect, info.DestRect);
 }
 
 int CAMLPlayer::GetSourceBitrate()
@@ -1151,15 +1165,6 @@
   return 0;
 }
 
-int CAMLPlayer::GetChannels()
-{
-  CSingleLock lock(m_aml_csection);
-  if (m_audio_streams.size() == 0 || m_audio_index > (int)(m_audio_streams.size() - 1))
-    return 0;
-  
-  return m_audio_streams[m_audio_index]->channel;
-}
-
 int CAMLPlayer::GetBitsPerSample()
 {
   CLog::Log(LOGDEBUG, "CAMLPlayer::GetBitsPerSample");
@@ -1169,34 +1174,12 @@
 int CAMLPlayer::GetSampleRate()
 {
   CSingleLock lock(m_aml_csection);
-  if (m_audio_streams.size() == 0 || m_audio_index > (int)(m_audio_streams.size() - 1))
+  if (m_audio_streams.empty() || m_audio_index > (int)(m_audio_streams.size() - 1))
     return 0;
   
   return m_audio_streams[m_audio_index]->sample_rate;
 }
 
-CStdString CAMLPlayer::GetAudioCodecName()
-{
-  CStdString strAudioCodec = "";
-  if (m_audio_streams.size() == 0 || m_audio_index > (int)(m_audio_streams.size() - 1))
-    return strAudioCodec;
-
-  strAudioCodec = AudioCodecName(m_audio_streams[m_audio_index]->format);
-
-  return strAudioCodec;
-}
-
-CStdString CAMLPlayer::GetVideoCodecName()
-{
-  CStdString strVideoCodec = "";
-  if (m_video_streams.size() == 0 || m_video_index > (int)(m_video_streams.size() - 1))
-    return strVideoCodec;
-  
-  strVideoCodec = VideoCodecName(m_video_streams[m_video_index]->format);
-
-  return strVideoCodec;
-}
-
 int CAMLPlayer::GetPictureWidth()
 {
   //CLog::Log(LOGDEBUG, "CAMLPlayer::GetPictureWidth(%d)", m_video_width);
@@ -1306,9 +1289,7 @@
   CLog::Log(LOGNOTICE, "CAMLPlayer::Process");
   try
   {
-    CJobManager::GetInstance().Pause(kJobTypeMediaFlags);
-
-    if (CJobManager::GetInstance().IsProcessing(kJobTypeMediaFlags) > 0)
+    if (CJobManager::GetInstance().IsProcessing(CJob::PRIORITY_LOW))
     {
       if (!WaitForPausedThumbJobs(20000))
       {
@@ -1480,11 +1461,11 @@
       // check for video in media content
       if (GetVideoStreamCount() > 0)
       {
-        SetAVDelay(g_settings.m_currentVideoSettings.m_AudioDelay);
+        SetAVDelay(CMediaSettings::Get().GetCurrentVideoSettings().m_AudioDelay);
 
         // turn on/off subs
-        SetSubtitleVisible(g_settings.m_currentVideoSettings.m_SubtitleOn);
-        SetSubTitleDelay(g_settings.m_currentVideoSettings.m_SubtitleDelay);
+        SetSubtitleVisible(CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleOn);
+        SetSubTitleDelay(CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleDelay);
 
         // setup renderer for bypass. This tell renderer to get out of the way as
         // hw decoder will be doing the actual video rendering in a video plane
@@ -1614,8 +1595,6 @@
 
   // reset ac3/dts passthough
   SetAudioPassThrough(AFORMAT_UNKNOWN);
-  // let thumbgen jobs resume.
-  CJobManager::GetInstance().UnPause(kJobTypeMediaFlags);
 
   if (m_log_level > 5)
     CLog::Log(LOGDEBUG, "CAMLPlayer::Process exit");
@@ -1721,7 +1700,7 @@
   // use m_bStop and Sleep so we can get canceled.
   while (!m_bStop && (timeout_ms > 0))
   {
-    if (CJobManager::GetInstance().IsProcessing(kJobTypeMediaFlags) > 0)
+    if (CJobManager::GetInstance().IsProcessing(CJob::PRIORITY_LOW))
     {
       Sleep(100);
       timeout_ms -= 100;
@@ -1975,7 +1954,16 @@
             info->format          = media_info.audio_info[i]->aformat;
 #if !defined(TARGET_ANDROID)
             if (media_info.audio_info[i]->audio_language[0] != 0)
+            {
               info->language = std::string(media_info.audio_info[i]->audio_language, 3);
+
+              if (info->language.length() == 2)
+              {
+                CStdString lang;
+                g_LangCodeExpander.ConvertToThreeCharCode(lang, info->language);
+                info->language = lang;
+              }
+            }
 #endif
             m_audio_streams.push_back(info);
           }
@@ -1999,7 +1987,16 @@
             info->id   = media_info.sub_info[i]->id;
             info->type = STREAM_SUBTITLE;
             if (media_info.sub_info[i]->sub_language && media_info.sub_info[i]->sub_language[0] != 0)
+            {
               info->language = std::string(media_info.sub_info[i]->sub_language, 3);
+
+              if (info->language.length() == 2)
+              {
+                CStdString lang;
+                g_LangCodeExpander.ConvertToThreeCharCode(lang, info->language);
+                info->language = lang;
+              }
+            }
             m_subtitle_streams.push_back(info);
           }
           m_subtitle_index = media_info.stream_info.cur_sub_index;
@@ -2130,11 +2127,11 @@
 int CAMLPlayer::AddSubtitleFile(const std::string &filename, const std::string &subfilename)
 {
   std::string ext = URIUtils::GetExtension(filename);
-  std::string vobsubfile = subfilename;
 
   if(ext == ".idx")
   {
     /* TODO: we do not handle idx/sub binary subs yet.
+    std::string vobsubfile = subfilename;
     if (vobsubfile.empty())
       vobsubfile = URIUtils::ReplaceExtension(filename, ".sub");
 
@@ -2244,20 +2241,20 @@
   // do not do anything stupid here.
 
   // video zoom adjustment.
-  float zoom = g_settings.m_currentVideoSettings.m_CustomZoomAmount;
+  float zoom = CMediaSettings::Get().GetCurrentVideoSettings().m_CustomZoomAmount;
   if ((int)(zoom * 1000) != (int)(m_zoom * 1000))
   {
     m_zoom = zoom;
   }
   // video contrast adjustment.
-  int contrast = g_settings.m_currentVideoSettings.m_Contrast;
+  int contrast = CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast;
   if (contrast != m_contrast)
   {
     SetVideoContrast(contrast);
     m_contrast = contrast;
   }
   // video brightness adjustment.
-  int brightness = g_settings.m_currentVideoSettings.m_Brightness;
+  int brightness = CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness;
   if (brightness != m_brightness)
   {
     SetVideoBrightness(brightness);
@@ -2265,10 +2262,10 @@
   }
 
   // check if destination rect or video view mode has changed
-  if ((m_dst_rect != DestRect) || (m_view_mode != g_settings.m_currentVideoSettings.m_ViewMode))
+  if ((m_dst_rect != DestRect) || (m_view_mode != CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode))
   {
     m_dst_rect  = DestRect;
-    m_view_mode = g_settings.m_currentVideoSettings.m_ViewMode;
+    m_view_mode = CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode;
   }
   else
   {
@@ -2284,7 +2281,7 @@
   // so we have to setup video axis for 720p instead of 1080p... Boooo.
   display = g_graphicsContext.GetViewWindow();
   //RESOLUTION res = g_graphicsContext.GetVideoResolution();
-  //display.SetRect(0, 0, g_settings.m_ResInfo[res].iScreenWidth, g_settings.m_ResInfo[res].iScreenHeight);
+  //display.SetRect(0, 0, CDisplaySettings::Get().GetResolutionInfo(res).iScreenWidth, CDisplaySettings::Get().GetResolutionInfo(res).iScreenHeight);
   dst_rect = m_dst_rect;
   if (gui != display)
   {
diff -ENwbur xbmcfrodo/xbmc/cores/amlplayer/AMLPlayer.h xbmc/xbmc/cores/amlplayer/AMLPlayer.h
--- xbmcfrodo/xbmc/cores/amlplayer/AMLPlayer.h	2013-02-16 18:48:35.464451392 +0000
+++ xbmc/xbmc/cores/amlplayer/AMLPlayer.h	2013-03-02 12:30:08.648239677 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -81,15 +81,13 @@
   virtual void  SeekPercentage(float fPercent = 0.0f);
   virtual float GetPercentage();
   virtual void  SetMute(bool bOnOff);
-  virtual bool  ControlsVolume() {return true;}
   virtual void  SetVolume(float volume);
+  virtual bool  ControlsVolume() {return true;}
   virtual void  SetDynamicRangeCompression(long drc)              {}
   virtual void  GetAudioInfo(CStdString &strAudioInfo);
   virtual void  GetVideoInfo(CStdString &strVideoInfo);
   virtual void  GetGeneralInfo(CStdString &strVideoInfo) {};
   virtual void  Update(bool bPauseDrawing);
-  virtual void  GetVideoRect(CRect& SrcRect, CRect& DestRect);
-  virtual void  GetVideoAspectRatio(float &fAR);
   virtual bool  CanRecord()                                       {return false;};
   virtual bool  IsRecording()                                     {return false;};
   virtual bool  Record(bool bOnOff)                               {return false;};
@@ -101,18 +99,15 @@
   virtual float GetSubTitleDelay();
   virtual int   GetSubtitleCount();
   virtual int   GetSubtitle();
-  virtual void  GetSubtitleName(int iStream, CStdString &strStreamName);
+  virtual void  GetSubtitleStreamInfo(int index, SPlayerSubtitleStreamInfo &info);
   virtual void  SetSubtitle(int iStream);
   virtual bool  GetSubtitleVisible();
   virtual void  SetSubtitleVisible(bool bVisible);
-  virtual bool  GetSubtitleExtension(CStdString &strSubtitleExtension) { return false; }
   virtual int   AddSubtitle(const CStdString& strSubPath);
 
   virtual int   GetAudioStreamCount();
   virtual int   GetAudioStream();
-  virtual void  GetAudioStreamName(int iStream, CStdString &strStreamName);
   virtual void  SetAudioStream(int iStream);
-  virtual void  GetAudioStreamLanguage(int iStream, CStdString &strLanguage) {};
 
   virtual TextCacheStruct_t* GetTeletextCache()                   {return NULL;};
   virtual void  LoadPage(int p, int sp, unsigned char* buffer)    {};
@@ -126,14 +121,11 @@
   virtual void  SeekTime(__int64 iTime = 0);
   virtual __int64 GetTime();
   virtual __int64 GetTotalTime();
-  virtual int   GetAudioBitrate();
-  virtual int   GetVideoBitrate();
+  virtual void  GetAudioStreamInfo(int index, SPlayerAudioStreamInfo &info);
+  virtual void  GetVideoStreamInfo(SPlayerVideoStreamInfo &info);
   virtual int   GetSourceBitrate();
-  virtual int   GetChannels();
   virtual int   GetBitsPerSample();
   virtual int   GetSampleRate();
-  virtual CStdString GetAudioCodecName();
-  virtual CStdString GetVideoCodecName();
   virtual int   GetPictureWidth();
   virtual int   GetPictureHeight();
   virtual bool  GetStreamDetails(CStreamDetails &details);
diff -ENwbur xbmcfrodo/xbmc/cores/amlplayer/AMLUtils.cpp xbmc/xbmc/cores/amlplayer/AMLUtils.cpp
--- xbmcfrodo/xbmc/cores/amlplayer/AMLUtils.cpp	2013-02-16 18:48:35.464451392 +0000
+++ xbmc/xbmc/cores/amlplayer/AMLUtils.cpp	2013-02-10 14:23:18.426516957 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/amlplayer/AMLUtils.h xbmc/xbmc/cores/amlplayer/AMLUtils.h
--- xbmcfrodo/xbmc/cores/amlplayer/AMLUtils.h	2013-02-16 18:48:35.464451392 +0000
+++ xbmc/xbmc/cores/amlplayer/AMLUtils.h	2013-02-10 14:23:18.426516957 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/amlplayer/DllLibamplayer.h xbmc/xbmc/cores/amlplayer/DllLibamplayer.h
--- xbmcfrodo/xbmc/cores/amlplayer/DllLibamplayer.h	2013-02-16 18:48:38.074399583 +0000
+++ xbmc/xbmc/cores/amlplayer/DllLibamplayer.h	2013-02-10 14:23:18.426516957 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2012 Team XBMC
+ *      Copyright (C) 2012-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/amlplayer/FileURLProtocol.cpp xbmc/xbmc/cores/amlplayer/FileURLProtocol.cpp
--- xbmcfrodo/xbmc/cores/amlplayer/FileURLProtocol.cpp	2013-02-16 18:48:38.074399583 +0000
+++ xbmc/xbmc/cores/amlplayer/FileURLProtocol.cpp	2013-02-10 14:23:18.426516957 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/amlplayer/FileURLProtocol.h xbmc/xbmc/cores/amlplayer/FileURLProtocol.h
--- xbmcfrodo/xbmc/cores/amlplayer/FileURLProtocol.h	2013-02-16 18:48:38.074399583 +0000
+++ xbmc/xbmc/cores/amlplayer/FileURLProtocol.h	2013-02-10 14:23:18.426516957 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDAudio.cpp xbmc/xbmc/cores/dvdplayer/DVDAudio.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDAudio.cpp	2013-02-16 18:48:38.074399583 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDAudio.cpp	2013-04-01 22:58:06.684292754 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -27,6 +27,7 @@
 #include "cores/AudioEngine/AEFactory.h"
 #include "cores/AudioEngine/Interfaces/AEStream.h"
 #include "settings/Settings.h"
+#include "settings/MediaSettings.h"
 
 using namespace std;
 
@@ -152,7 +153,7 @@
     m_SecondsPerByte = 0.0;
 
   m_iBufferSize = 0;
-  SetDynamicRangeCompression((long)(g_settings.m_currentVideoSettings.m_VolumeAmplification * 100));
+  SetDynamicRangeCompression((long)(CMediaSettings::Get().GetCurrentVideoSettings().m_VolumeAmplification * 100));
 
   if (m_pAudioCallback)
     RegisterAudioCallback(m_pAudioCallback);
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDAudio.h xbmc/xbmc/cores/dvdplayer/DVDAudio.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDAudio.h	2013-02-16 18:48:38.074399583 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDAudio.h	2013-02-10 14:23:18.436516763 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDClock.cpp xbmc/xbmc/cores/dvdplayer/DVDClock.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDClock.cpp	2013-02-16 18:48:38.074399583 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDClock.cpp	2013-02-10 14:23:18.436516763 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDClock.h xbmc/xbmc/cores/dvdplayer/DVDClock.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDClock.h	2013-02-16 18:48:38.074399583 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDClock.h	2013-02-10 14:23:18.436516763 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h	2013-02-16 18:48:38.104398988 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h	2013-02-10 14:23:18.436516763 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp	2013-02-16 18:48:38.104398988 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp	2013-02-10 14:23:18.436516763 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h	2013-02-16 18:48:38.104398988 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h	2013-02-10 14:23:18.446516569 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.cpp	2013-02-16 18:48:38.104398988 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.cpp	2013-04-05 11:38:43.876815344 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -47,12 +47,12 @@
 {
   BYTE* d = m_buffer;
   BYTE* s = pData;
-  int iDecoded = 0;
 
   if (iSize > m_bufferSize) iSize = m_bufferSize;
 
   if (iSize >= 12)
   {
+    int iDecoded = 0;
 #if 0
     if (m_codecID == CODEC_ID_LPCM_S24BE)
 #endif
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.h	2013-02-16 18:48:38.104398988 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.h	2013-02-10 14:23:18.446516569 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLibMad.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLibMad.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLibMad.cpp	2013-02-16 18:48:38.104398988 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLibMad.cpp	2013-04-05 11:38:43.876815344 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -36,6 +36,8 @@
   m_iSourceBitrate = 0;
   
   m_iInputBufferSize = 0;
+  memset(&m_decodedData, 0, MAD_DECODED_SIZE);
+  memset(&m_inputBuffer, 0, MAD_INPUT_SIZE);
 }
 
 CDVDAudioCodecLibMad::~CDVDAudioCodecLibMad()
@@ -86,7 +88,6 @@
 {
   BYTE* pBuffer = m_inputBuffer;
   //int iBufferSize = iSize;
-  bool bFullOutputBuffer = false;
 
   m_iDecodedDataSize = 0;
 
@@ -100,6 +101,7 @@
 
   if (m_bInitialized)
   {
+    bool bFullOutputBuffer = false;
     m_dll.mad_stream_buffer(&m_stream, pBuffer, m_iInputBufferSize);
 
     while (true)
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLibMad.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLibMad.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLibMad.h	2013-02-16 18:48:38.104398988 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLibMad.h	2013-02-10 14:23:18.446516569 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp	2013-02-16 18:48:38.124398591 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp	2013-02-10 14:23:18.446516569 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.h	2013-02-16 18:48:38.124398591 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.h	2013-02-10 14:23:18.446516569 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.cpp	2013-02-16 18:48:38.144398195 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.cpp	2013-04-05 11:38:43.886815163 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -22,6 +22,7 @@
 #include "DVDCodecs/DVDCodecs.h"
 #include "DVDStreamInfo.h"
 #include "settings/GUISettings.h"
+#include "settings/MediaSettings.h"
 #include "settings/Settings.h"
 #include "utils/log.h"
 
@@ -59,6 +60,11 @@
   /* make enough room for at-least two audio frames */
   m_DecodeSize   = 0;
   m_DecodeBuffer = NULL;
+  m_bSupportsAC3Out = false;
+  m_bSupportsDTSOut = false;
+  m_bSupportsAACOut = false;
+  m_LostSync = false;
+  
 }
 
 CDVDAudioCodecPassthroughFFmpeg::~CDVDAudioCodecPassthroughFFmpeg(void)
@@ -300,7 +306,7 @@
     return false;
 
   // TODO - this is only valid for video files, and should be moved somewhere else
-  if( hints.channels == 2 && g_settings.m_currentVideoSettings.m_OutputToAllSpeakers )
+  if( hints.channels == 2 && CMediaSettings::Get().GetCurrentVideoSettings().m_OutputToAllSpeakers )
   {
     CLog::Log(LOGINFO, "CDVDAudioCodecPassthroughFFmpeg::Open - disabled passthrough due to video OTAS");
     return false;
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.h	2013-02-16 18:48:38.144398195 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.h	2013-02-10 14:23:18.456516375 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.cpp	2013-02-16 18:48:38.144398195 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.cpp	2013-02-10 14:23:18.456516375 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.h	2013-02-16 18:48:38.144398195 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.h	2013-02-10 14:23:18.456516375 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DllLibMad.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DllLibMad.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Audio/DllLibMad.h	2013-02-16 18:48:38.144398195 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Audio/DllLibMad.h	2013-02-10 14:23:18.456516375 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp	2013-02-16 18:48:38.164397798 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp	2013-02-10 14:23:18.456516375 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.h	2013-02-16 18:48:38.164397798 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.h	2013-02-10 14:23:18.456516375 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecs.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecs.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecs.h	2013-02-16 18:48:38.164397798 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecs.h	2013-04-05 11:38:43.886815163 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -61,7 +61,7 @@
 class CDVDCodecOption
 {
 public:
-  CDVDCodecOption(std::string name, std::string value) { m_name = name; m_value = value; }
+  CDVDCodecOption(const std::string& name, const std::string& value) : m_name(name), m_value(value) {}
   std::string m_name;
   std::string m_value;
 };
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	2013-02-16 18:48:38.174397599 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	2013-04-05 11:38:43.886815163 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -26,7 +26,9 @@
 #include "Audio/DVDAudioCodec.h"
 #include "Overlay/DVDOverlayCodec.h"
 
+#if defined(HAVE_LIBVDADECODER)
 #include "Video/DVDVideoCodecVDA.h"
+#endif
 #if defined(HAVE_VIDEOTOOLBOXDECODER)
 #include "Video/DVDVideoCodecVideoToolBox.h"
 #endif
@@ -126,7 +128,7 @@
   CDVDVideoCodec* pCodec = NULL;
   CDVDCodecOptions options;
 
-  if(formats.size() == 0)
+  if(formats.empty())
     options.m_formats.push_back(RENDER_FMT_YUV420P);
   else
     options.m_formats = formats;
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.h	2013-02-16 18:48:38.174397599 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.h	2013-02-10 14:23:18.466516181 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlay.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlay.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlay.h	2013-03-11 02:09:46.440993984 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlay.h	2013-04-05 11:38:43.886815163 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2006-2012 Team XBMC
+ *      Copyright (C) 2006-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -75,7 +75,7 @@
   }
 
   /**
-   * decrease the reference counter by one.
+  * increase the reference counter by one.
    */
   CDVDOverlay* Acquire()
   {
@@ -84,7 +84,7 @@
   }
 
   /**
-   * increase the reference counter by one.
+  * decrease the reference counter by one.
    */
   long Release()
   {
@@ -145,8 +145,8 @@
   CDVDOverlayGroup(CDVDOverlayGroup& src)
     : CDVDOverlay(src)
   {
-    for(VecOverlaysIter it = m_overlays.begin(); it != m_overlays.end(); ++it)
-      m_overlays.push_back((*it)->Acquire());
+    for(VecOverlaysIter it = src.m_overlays.begin(); it != src.m_overlays.end(); ++it)
+      m_overlays.push_back((*it)->Clone());
   }
   VecOverlays m_overlays;
 };
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodec.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodec.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodec.cpp	2013-02-16 18:48:38.174397599 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodec.cpp	2013-02-10 14:23:18.466516181 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2012 Team XBMC
+ *      Copyright (C) 2012-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodec.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodec.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodec.h	2013-02-16 18:48:38.174397599 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodec.h	2013-04-05 11:38:43.886815163 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -39,10 +39,7 @@
 {
 public:
 
-  CDVDOverlayCodec(const char* name)
-  {
-    m_codecName = name;
-  }
+  CDVDOverlayCodec(const char* name) : m_codecName(name) {}
 
   virtual ~CDVDOverlayCodec() {}
 
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecCC.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecCC.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecCC.cpp	2013-02-16 18:48:38.174397599 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecCC.cpp	2013-02-10 14:23:18.466516181 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecCC.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecCC.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecCC.h	2013-02-16 18:48:38.174397599 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecCC.h	2013-02-10 14:23:18.466516181 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp	2013-02-16 18:48:38.174397599 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp	2013-02-10 14:23:18.476515987 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.h	2013-02-16 18:48:38.174397599 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.h	2013-02-10 14:23:18.476515987 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecSSA.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecSSA.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecSSA.cpp	2013-02-16 18:48:38.194397204 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecSSA.cpp	2013-02-10 14:23:18.476515987 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecSSA.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecSSA.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecSSA.h	2013-02-16 18:48:38.204397006 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecSSA.h	2013-02-10 14:23:18.476515987 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecTX3G.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecTX3G.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecTX3G.cpp	2013-02-16 18:48:38.204397006 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecTX3G.cpp	2013-02-10 14:23:18.476515987 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecTX3G.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecTX3G.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecTX3G.h	2013-02-16 18:48:38.204397006 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecTX3G.h	2013-02-10 14:23:18.476515987 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecText.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecText.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecText.cpp	2013-02-16 18:48:38.204397006 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecText.cpp	2013-02-10 14:23:18.476515987 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecText.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecText.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecText.h	2013-02-16 18:48:38.204397006 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecText.h	2013-02-10 14:23:18.476515987 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayImage.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayImage.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayImage.h	2013-03-11 02:09:46.440993984 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayImage.h	2013-03-04 20:00:54.105218826 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlaySSA.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlaySSA.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlaySSA.h	2013-03-11 02:09:46.440993984 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlaySSA.h	2013-03-04 20:00:54.105218826 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlaySpu.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlaySpu.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlaySpu.h	2013-02-16 18:48:38.204397006 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlaySpu.h	2013-02-10 14:23:18.486515793 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayText.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayText.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayText.h	2013-03-11 02:09:46.440993984 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayText.h	2013-03-31 15:25:11.619996868 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -21,10 +21,8 @@
  */
 
 #include "DVDOverlay.h"
-#ifdef _LINUX
-#include "utils/CharsetConverter.h"
-#endif
 #include <string.h>
+#include <stdlib.h>
 
 class CDVDOverlayText : public CDVDOverlay
 {
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.cpp	2013-02-16 18:48:38.224396608 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.cpp	2013-04-05 11:38:43.896814982 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -1869,9 +1869,17 @@
       free(out);
       return false;
     }
-    out = (uint8_t*)realloc(out, total_size);
-    if (!out)
+    uint8_t* new_out = (uint8_t*)realloc(out, total_size);
+    if (new_out)
+    {
+      out = new_out;
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "bitstream_convert_init failed - %s : could not realloc the buffer out",  __FUNCTION__);
+      free(out);
       return false;
+    }
 
     memcpy(out + total_size - unit_size - 4, nalu_header, 4);
     memcpy(out + total_size - unit_size, extradata + 2, unit_size);
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.h	2013-02-16 18:48:38.244396212 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.h	2013-04-05 11:38:43.896814982 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -44,7 +44,7 @@
   {
     T* p = NULL;
     CSingleLock lock(m_Lock);
-    if (m_Queue.size())
+    if (!m_Queue.empty())
     {
       p = m_Queue.front();
       m_Queue.pop_front();
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h	2013-02-16 18:48:38.244396212 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h	2013-02-10 14:23:18.496515598 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -192,6 +192,12 @@
   virtual void SetDropState(bool bDrop) = 0;
 
   /*
+   * will be called by video player indicating the playback speed. see DVD_PLAYSPEED_NORMAL,
+   * DVD_PLAYSPEED_PAUSE and friends.
+   */
+  virtual void SetSpeed(int iSpeed) {};
+
+  /*
    * returns the number of demuxer bytes in any internal buffers
    */
   virtual int GetDataSize(void)
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.cpp	2013-02-16 18:48:38.244396212 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.cpp	2013-02-10 14:23:18.496515598 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.h	2013-02-16 18:48:38.244396212 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.h	2013-02-10 14:23:18.496515598 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp	2013-02-16 18:48:38.244396212 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp	2013-04-05 11:38:43.896814982 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -138,6 +138,7 @@
   m_iScreenHeight = 0;
   m_iOrientation = 0;
   m_bSoftware = false;
+  m_isHi10p = false;
   m_pHardware = NULL;
   m_iLastKeyframe = 0;
   m_dts = DVD_NOPTS_VALUE;
@@ -187,7 +188,10 @@
       case FF_PROFILE_H264_HIGH_444_PREDICTIVE:
       case FF_PROFILE_H264_HIGH_444_INTRA:
       case FF_PROFILE_H264_CAVLC_444:
+      // this is needed to not open the decoders
       m_bSoftware = true;
+      // this we need to enable multithreading for hi10p via advancedsettings
+      m_isHi10p = true;
       break;
     }
   }
@@ -247,7 +251,17 @@
   m_pCodecContext->codec_tag = hints.codec_tag;
   /* Only allow slice threading, since frame threading is more
    * sensitive to changes in frame sizes, and it causes crashes
-   * during HW accell */
+   * during HW accell - so we unset it in this case.
+   *
+   * When we detect Hi10p and user did not disable hi10pmultithreading
+   * via advancedsettings.xml we keep the ffmpeg default thread type.
+   * */
+  if(m_isHi10p && !g_advancedSettings.m_videoDisableHi10pMultithreading)
+  {
+    CLog::Log(LOGDEBUG,"CDVDVideoCodecFFmpeg::Open() Keep default threading for Hi10p: %d",
+                        m_pCodecContext->thread_type);
+  }
+  else
   m_pCodecContext->thread_type = FF_THREAD_SLICE;
 
 #if defined(TARGET_DARWIN_IOS)
@@ -272,9 +286,6 @@
     memcpy(m_pCodecContext->extradata, hints.extradata, hints.extrasize);
   }
 
-  // set acceleration
-  m_pCodecContext->dsp_mask = 0;//FF_MM_FORCE | FF_MM_MMX | FF_MM_MMXEXT | FF_MM_SSE;
-
   // advanced setting override for skip loop filter (see avcodec.h for valid options)
   // TODO: allow per video setting?
   if (g_advancedSettings.m_iSkipLoopFilter != 0)
@@ -283,7 +294,7 @@
   }
 
   // set any special options
-  for(std::vector<CDVDCodecOption>::iterator it = options.m_keys.begin(); it != options.m_keys.end(); it++)
+  for(std::vector<CDVDCodecOption>::iterator it = options.m_keys.begin(); it != options.m_keys.end(); ++it)
   {
     if (it->m_name == "surfaces")
       m_uSurfacesCount = std::atoi(it->m_value.c_str());
@@ -828,7 +839,7 @@
   {
 
     result = m_dllAvFilter.av_buffersink_get_buffer_ref(m_pFilterOut, &m_pBufferRef, 0);
-    if(!m_pBufferRef)
+    if(!m_pBufferRef || result < 0)
     {
       CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::FilterProcess - cur_buf");
       return VC_ERROR;
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h	2013-02-16 18:48:38.244396212 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h	2013-03-02 00:47:41.876014770 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -114,6 +114,7 @@
 
   std::string m_name;
   bool              m_bSoftware;
+  bool  m_isHi10p;
   IHardwareDecoder *m_pHardware;
   int m_iLastKeyframe;
   double m_dts;
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecLibMpeg2.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecLibMpeg2.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecLibMpeg2.cpp	2013-02-16 18:48:38.264395816 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecLibMpeg2.cpp	2013-02-10 14:23:18.506515403 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecLibMpeg2.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecLibMpeg2.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecLibMpeg2.h	2013-02-16 18:48:38.264395816 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecLibMpeg2.h	2013-04-05 11:38:43.896814982 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -43,7 +43,7 @@
   inline void ReleaseBuffer(DVDVideoPicture* pPic);
   inline void DeleteBuffer(DVDVideoPicture* pPic);
 
-  int GuessAspect(const mpeg2_sequence_t *sequence, unsigned int *pixel_width, unsigned int *pixel_height);
+  static int GuessAspect(const mpeg2_sequence_t *sequence, unsigned int *pixel_width, unsigned int *pixel_height);
 
   mpeg2dec_t* m_pHandle;
   const mpeg2_info_t* m_pInfo;
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp	2013-02-16 18:48:38.264395816 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp	2013-04-05 11:38:43.896814982 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -98,8 +98,6 @@
     // allocate a YV12 DVDVideoPicture buffer.
     // first make sure all properties are reset.
     memset(&m_videobuffer, 0, sizeof(DVDVideoPicture));
-    unsigned int luma_pixels = hints.width * hints.height;
-    unsigned int chroma_pixels = luma_pixels/4;
 
     m_videobuffer.dts = DVD_NOPTS_VALUE;
     m_videobuffer.pts = DVD_NOPTS_VALUE;
@@ -235,9 +233,17 @@
       free(out);
       return false;
     }
-    out = (uint8_t*)realloc(out, total_size);
-    if (!out)
+    uint8_t* new_out = (uint8_t*)realloc(out, total_size);
+    if (new_out)
+    {
+      out = new_out;
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "bitstream_convert_init failed - %s : could not realloc the buffer out",  __FUNCTION__);
+      free(out);
       return false;
+    }
 
     memcpy(out + total_size - unit_size - 4, nalu_header, 4);
     memcpy(out + total_size - unit_size, extradata + 2, unit_size);
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h	2013-02-16 18:48:38.264395816 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h	2013-04-05 11:38:43.896814982 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -47,7 +47,7 @@
   // bitstream to bytestream (Annex B) conversion support.
   bool bitstream_convert_init(void *in_extradata, int in_extrasize);
   bool bitstream_convert(BYTE* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size);
-  void bitstream_alloc_and_copy( uint8_t **poutbuf, int *poutbuf_size,
+  static void bitstream_alloc_and_copy( uint8_t **poutbuf, int *poutbuf_size,
     const uint8_t *sps_pps, uint32_t sps_pps_size, const uint8_t *in, uint32_t in_size);
 
   typedef struct omx_bitstream_ctx {
@@ -55,6 +55,15 @@
       uint8_t  first_idr;
       uint8_t *sps_pps_data;
       uint32_t size;
+
+      omx_bitstream_ctx()
+      {
+        length_size = 0;
+        first_idr = 0;
+        sps_pps_data = NULL;
+        size = 0;
+      }
+
   } omx_bitstream_ctx;
 
   uint32_t          m_sps_pps_size;
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp	2013-03-05 19:37:56.582328697 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp	2013-04-05 11:38:43.906814802 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -18,51 +18,26 @@
  *
  */
 
-#if (defined HAVE_CONFIG_H) && (!defined WIN32)
   #include "config.h"
-#endif
 
 #if defined(HAVE_LIBVDADECODER)
 #include "system_gl.h"
-#include "DynamicDll.h"
-#include "settings/GUISettings.h"
+#include "DVDVideoCodecVDA.h"
+
+#include "DllSwScale.h"
 #include "DVDClock.h"
 #include "DVDStreamInfo.h"
 #include "cores/dvdplayer/DVDCodecs/DVDCodecUtils.h"
-#include "DVDVideoCodecVDA.h"
-#include "DllAvFormat.h"
-#include "DllSwScale.h"
+#include "osx/CocoaInterface.h"
+#include "settings/GUISettings.h"
+#include "windowing/WindowingFactory.h"
+#include "utils/BitstreamConverter.h"
 #include "utils/log.h"
 #include "utils/TimeUtils.h"
-#include "windowing/WindowingFactory.h"
-#include "osx/CocoaInterface.h"
+
 #include <CoreFoundation/CoreFoundation.h>
 
 /*
- * if extradata size is greater than 7, then have a valid quicktime 
- * avcC atom header.
- *
- *      -: avcC atom header :-
- *  -----------------------------------
- *  1 byte  - version
- *  1 byte  - h.264 stream profile
- *  1 byte  - h.264 compatible profiles
- *  1 byte  - h.264 stream level
- *  6 bits  - reserved set to 63
- *  2 bits  - NAL length 
- *            ( 0 - 1 byte; 1 - 2 bytes; 3 - 4 bytes)
- *  3 bit   - reserved
- *  5 bits  - number of SPS 
- *  for (i=0; i < number of SPS; i++) {
- *      2 bytes - SPS length
- *      SPS length bytes - SPS NAL unit
- *  }
- *  1 byte  - number of PPS
- *  for (i=0; i < number of PPS; i++) {
- *      2 bytes - PPS length 
- *      PPS length bytes - PPS NAL unit 
- *  }
- 
  how to detect the interlacing used on an existing stream:
 - progressive is signalled by setting
    frame_mbs_only_flag: 1 in the SPS.
@@ -80,6 +55,15 @@
    (field_pic_flag: 1 would indicate a normal interlaced frame).
 */
 
+// tracks a frame in and output queue in display order
+typedef struct frame_queue {
+  double              dts;
+  double              pts;
+  double              sort_time;
+  FourCharCode        pixel_buffer_format;
+  CVBufferRef         pixel_buffer_ref;
+  struct frame_queue  *nextframe;
+} frame_queue;
 
 ////////////////////////////////////////////////////////////////////////////////////////////
 // http://developer.apple.com/mac/library/technotes/tn2010/tn2267.html
@@ -209,409 +193,6 @@
   return;
 }
 
-////////////////////////////////////////////////////////////////////////////////////////////
-////////////////////////////////////////////////////////////////////////////////////////////
-// GStreamer h264 parser
-// Copyright (C) 2005 Michal Benes <michal.benes@itonis.tv>
-//           (C) 2008 Wim Taymans <wim.taymans@gmail.com>
-// gsth264parse.c:
-//  * License as published by the Free Software Foundation; either
-//  * version 2.1 of the License, or (at your option) any later version.
-typedef struct
-{
-  const uint8_t *data;
-  const uint8_t *end;
-  int head;
-  uint64_t cache;
-} nal_bitstream;
-
-static void
-nal_bs_init(nal_bitstream *bs, const uint8_t *data, size_t size)
-{
-  bs->data = data;
-  bs->end  = data + size;
-  bs->head = 0;
-  // fill with something other than 0 to detect
-  //  emulation prevention bytes
-  bs->cache = 0xffffffff;
-}
-
-static uint32_t
-nal_bs_read(nal_bitstream *bs, int n)
-{
-  uint32_t res = 0;
-  int shift;
-
-  if (n == 0)
-    return res;
-
-  // fill up the cache if we need to
-  while (bs->head < n)
-  {
-    uint8_t a_byte;
-    bool check_three_byte;
-
-    check_three_byte = TRUE;
-next_byte:
-    if (bs->data >= bs->end)
-    {
-      // we're at the end, can't produce more than head number of bits
-      n = bs->head;
-      break;
-    }
-    // get the byte, this can be an emulation_prevention_three_byte that we need
-    // to ignore.
-    a_byte = *bs->data++;
-    if (check_three_byte && a_byte == 0x03 && ((bs->cache & 0xffff) == 0))
-    {
-      // next byte goes unconditionally to the cache, even if it's 0x03
-      check_three_byte = FALSE;
-      goto next_byte;
-    }
-    // shift bytes in cache, moving the head bits of the cache left
-    bs->cache = (bs->cache << 8) | a_byte;
-    bs->head += 8;
-  }
-
-  // bring the required bits down and truncate
-  if ((shift = bs->head - n) > 0)
-    res = bs->cache >> shift;
-  else
-    res = bs->cache;
-
-  // mask out required bits
-  if (n < 32)
-    res &= (1 << n) - 1;
-
-  bs->head = shift;
-
-  return res;
-}
-
-static bool
-nal_bs_eos(nal_bitstream *bs)
-{
-  return (bs->data >= bs->end) && (bs->head == 0);
-}
-
-// read unsigned Exp-Golomb code
-static int
-nal_bs_read_ue(nal_bitstream *bs)
-{
-  int i = 0;
-
-  while (nal_bs_read(bs, 1) == 0 && !nal_bs_eos(bs) && i < 32)
-    i++;
-
-  return ((1 << i) - 1 + nal_bs_read(bs, i));
-}
-
-typedef struct
-{
-  int profile_idc;
-  int level_idc;
-  int sps_id;
-
-  int chroma_format_idc;
-  int separate_colour_plane_flag;
-  int bit_depth_luma_minus8;
-  int bit_depth_chroma_minus8;
-  int qpprime_y_zero_transform_bypass_flag;
-  int seq_scaling_matrix_present_flag;
-
-  int log2_max_frame_num_minus4;
-  int pic_order_cnt_type;
-  int log2_max_pic_order_cnt_lsb_minus4;
-
-  int max_num_ref_frames;
-  int gaps_in_frame_num_value_allowed_flag;
-  int pic_width_in_mbs_minus1;
-  int pic_height_in_map_units_minus1;
-
-  int frame_mbs_only_flag;
-  int mb_adaptive_frame_field_flag;
-
-  int direct_8x8_inference_flag;
-
-  int frame_cropping_flag;
-  int frame_crop_left_offset;
-  int frame_crop_right_offset;
-  int frame_crop_top_offset;
-  int frame_crop_bottom_offset;
-} sps_info_struct;
-
-static void
-parseh264_sps(uint8_t *sps, uint32_t sps_size, int *level, int *profile, bool *interlaced, int32_t *max_ref_frames)
-{
-  nal_bitstream bs;
-  sps_info_struct sps_info;
-
-  nal_bs_init(&bs, sps, sps_size);
-
-  sps_info.profile_idc  = nal_bs_read(&bs, 8);
-  nal_bs_read(&bs, 1);  // constraint_set0_flag
-  nal_bs_read(&bs, 1);  // constraint_set1_flag
-  nal_bs_read(&bs, 1);  // constraint_set2_flag
-  nal_bs_read(&bs, 1);  // constraint_set3_flag
-  nal_bs_read(&bs, 4);  // reserved
-  sps_info.level_idc    = nal_bs_read(&bs, 8);
-  sps_info.sps_id       = nal_bs_read_ue(&bs);
-
-  if (sps_info.profile_idc == 100 ||
-      sps_info.profile_idc == 110 ||
-      sps_info.profile_idc == 122 ||
-      sps_info.profile_idc == 244 ||
-      sps_info.profile_idc == 44  ||
-      sps_info.profile_idc == 83  ||
-      sps_info.profile_idc == 86)
-  {
-    sps_info.chroma_format_idc                    = nal_bs_read_ue(&bs);
-    if (sps_info.chroma_format_idc == 3)
-      sps_info.separate_colour_plane_flag         = nal_bs_read(&bs, 1);
-    sps_info.bit_depth_luma_minus8                = nal_bs_read_ue(&bs);
-    sps_info.bit_depth_chroma_minus8              = nal_bs_read_ue(&bs);
-    sps_info.qpprime_y_zero_transform_bypass_flag = nal_bs_read(&bs, 1);
-
-    sps_info.seq_scaling_matrix_present_flag = nal_bs_read (&bs, 1);
-    if (sps_info.seq_scaling_matrix_present_flag)
-    {
-      /* TODO: unfinished */
-    }
-  }
-  sps_info.log2_max_frame_num_minus4 = nal_bs_read_ue(&bs);
-  if (sps_info.log2_max_frame_num_minus4 > 12)
-  { // must be between 0 and 12
-    // don't early return here - the bits we are using (profile/level/interlaced/ref frames)
-    // might still be valid - let the parser go on and pray.
-    //return;
-  }
-
-  sps_info.pic_order_cnt_type = nal_bs_read_ue(&bs);
-  if (sps_info.pic_order_cnt_type == 0)
-  {
-    sps_info.log2_max_pic_order_cnt_lsb_minus4 = nal_bs_read_ue(&bs);
-  }
-  else if (sps_info.pic_order_cnt_type == 1)
-  { // TODO: unfinished
-    /*
-    delta_pic_order_always_zero_flag = gst_nal_bs_read (bs, 1);
-    offset_for_non_ref_pic = gst_nal_bs_read_se (bs);
-    offset_for_top_to_bottom_field = gst_nal_bs_read_se (bs);
-
-    num_ref_frames_in_pic_order_cnt_cycle = gst_nal_bs_read_ue (bs);
-    for( i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++ )
-    offset_for_ref_frame[i] = gst_nal_bs_read_se (bs);
-    */
-  }
-
-  sps_info.max_num_ref_frames             = nal_bs_read_ue(&bs);
-  sps_info.gaps_in_frame_num_value_allowed_flag = nal_bs_read(&bs, 1);
-  sps_info.pic_width_in_mbs_minus1        = nal_bs_read_ue(&bs);
-  sps_info.pic_height_in_map_units_minus1 = nal_bs_read_ue(&bs);
-
-  sps_info.frame_mbs_only_flag            = nal_bs_read(&bs, 1);
-  if (!sps_info.frame_mbs_only_flag)
-    sps_info.mb_adaptive_frame_field_flag = nal_bs_read(&bs, 1);
-
-  sps_info.direct_8x8_inference_flag      = nal_bs_read(&bs, 1);
-
-  sps_info.frame_cropping_flag            = nal_bs_read(&bs, 1);
-  if (sps_info.frame_cropping_flag)
-  {
-    sps_info.frame_crop_left_offset       = nal_bs_read_ue(&bs);
-    sps_info.frame_crop_right_offset      = nal_bs_read_ue(&bs);
-    sps_info.frame_crop_top_offset        = nal_bs_read_ue(&bs);
-    sps_info.frame_crop_bottom_offset     = nal_bs_read_ue(&bs);
-  }
-
-  *level = sps_info.level_idc;
-  *profile = sps_info.profile_idc;
-  *interlaced = !sps_info.frame_mbs_only_flag;
-  *max_ref_frames = sps_info.max_num_ref_frames;
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////
-// TODO: refactor this so as not to need these ffmpeg routines.
-// These are not exposed in ffmpeg's API so we dupe them here.
-// AVC helper functions for muxers,
-//  * Copyright (c) 2006 Baptiste Coudurier <baptiste.coudurier@smartjog.com>
-// This is part of FFmpeg
-//  * License as published by the Free Software Foundation; either
-//  * version 2.1 of the License, or (at your option) any later version.
-#define VDA_RB16(x)                          \
-  ((((const uint8_t*)(x))[0] <<  8) |        \
-   ((const uint8_t*)(x)) [1])
-
-#define VDA_RB24(x)                          \
-  ((((const uint8_t*)(x))[0] << 16) |        \
-   (((const uint8_t*)(x))[1] <<  8) |        \
-   ((const uint8_t*)(x))[2])
-
-#define VDA_RB32(x)                          \
-  ((((const uint8_t*)(x))[0] << 24) |        \
-   (((const uint8_t*)(x))[1] << 16) |        \
-   (((const uint8_t*)(x))[2] <<  8) |        \
-   ((const uint8_t*)(x))[3])
-
-#define VDA_WB32(p, d) { \
-  ((uint8_t*)(p))[3] = (d); \
-  ((uint8_t*)(p))[2] = (d) >> 8; \
-  ((uint8_t*)(p))[1] = (d) >> 16; \
-  ((uint8_t*)(p))[0] = (d) >> 24; }
-
-static const uint8_t *avc_find_startcode_internal(const uint8_t *p, const uint8_t *end)
-{
-  const uint8_t *a = p + 4 - ((intptr_t)p & 3);
-
-  for (end -= 3; p < a && p < end; p++)
-  {
-    if (p[0] == 0 && p[1] == 0 && p[2] == 1)
-      return p;
-  }
-
-  for (end -= 3; p < end; p += 4)
-  {
-    uint32_t x = *(const uint32_t*)p;
-    if ((x - 0x01010101) & (~x) & 0x80808080) // generic
-    {
-      if (p[1] == 0)
-      {
-        if (p[0] == 0 && p[2] == 1)
-          return p;
-        if (p[2] == 0 && p[3] == 1)
-          return p+1;
-      }
-      if (p[3] == 0)
-      {
-        if (p[2] == 0 && p[4] == 1)
-          return p+2;
-        if (p[4] == 0 && p[5] == 1)
-          return p+3;
-      }
-    }
-  }
-
-  for (end += 3; p < end; p++)
-  {
-    if (p[0] == 0 && p[1] == 0 && p[2] == 1)
-      return p;
-  }
-
-  return end + 3;
-}
-
-const uint8_t *avc_find_startcode(const uint8_t *p, const uint8_t *end)
-{
-  const uint8_t *out= avc_find_startcode_internal(p, end);
-  if (p<out && out<end && !out[-1])
-    out--;
-  return out;
-}
-
-const int avc_parse_nal_units(DllAvFormat *av_format_ctx,
-  AVIOContext *pb, const uint8_t *buf_in, int size)
-{
-  const uint8_t *p = buf_in;
-  const uint8_t *end = p + size;
-  const uint8_t *nal_start, *nal_end;
-
-  size = 0;
-  nal_start = avc_find_startcode(p, end);
-  while (nal_start < end)
-  {
-    while (!*(nal_start++));
-    nal_end = avc_find_startcode(nal_start, end);
-    av_format_ctx->avio_wb32(pb, nal_end - nal_start);
-    av_format_ctx->avio_write(pb, nal_start, nal_end - nal_start);
-    size += 4 + nal_end - nal_start;
-    nal_start = nal_end;
-  }
-  return size;
-}
-
-const int avc_parse_nal_units_buf(DllAvUtil *av_util_ctx, DllAvFormat *av_format_ctx,
-  const uint8_t *buf_in, uint8_t **buf, int *size)
-{
-  AVIOContext *pb;
-  int ret = av_format_ctx->avio_open_dyn_buf(&pb);
-  if (ret < 0)
-    return ret;
-
-  avc_parse_nal_units(av_format_ctx, pb, buf_in, *size);
-
-  av_util_ctx->av_freep(buf);
-  *size = av_format_ctx->avio_close_dyn_buf(pb, buf);
-  return 0;
-}
-
-const int isom_write_avcc(DllAvUtil *av_util_ctx, DllAvFormat *av_format_ctx,
-  AVIOContext *pb, const uint8_t *data, int len)
-{
-  // extradata from bytestream h264, convert to avcC atom data for bitstream
-  if (len > 6)
-  {
-    /* check for h264 start code */
-    if (VDA_RB32(data) == 0x00000001 || VDA_RB24(data) == 0x000001)
-    {
-      uint8_t *buf=NULL, *end, *start;
-      uint32_t sps_size=0, pps_size=0;
-      uint8_t *sps=0, *pps=0;
-
-      int ret = avc_parse_nal_units_buf(av_util_ctx, av_format_ctx, data, &buf, &len);
-      if (ret < 0)
-        return ret;
-      start = buf;
-      end = buf + len;
-
-      /* look for sps and pps */
-      while (buf < end)
-      {
-        unsigned int size;
-        uint8_t nal_type;
-        size = VDA_RB32(buf);
-        nal_type = buf[4] & 0x1f;
-        if (nal_type == 7) /* SPS */
-        {
-          sps = buf + 4;
-          sps_size = size;
-          
-          //parse_sps(sps+1, sps_size-1);
-        }
-        else if (nal_type == 8) /* PPS */
-        {
-          pps = buf + 4;
-          pps_size = size;
-        }
-        buf += size + 4;
-      }
-      assert(sps);
-
-      av_format_ctx->avio_w8(pb, 1); /* version */
-      av_format_ctx->avio_w8(pb, sps[1]); /* profile */
-      av_format_ctx->avio_w8(pb, sps[2]); /* profile compat */
-      av_format_ctx->avio_w8(pb, sps[3]); /* level */
-      av_format_ctx->avio_w8(pb, 0xff); /* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */
-      av_format_ctx->avio_w8(pb, 0xe1); /* 3 bits reserved (111) + 5 bits number of sps (00001) */
-
-      av_format_ctx->avio_wb16(pb, sps_size);
-      av_format_ctx->avio_write(pb, sps, sps_size);
-      if (pps)
-      {
-        av_format_ctx->avio_w8(pb, 1); /* number of pps */
-        av_format_ctx->avio_wb16(pb, pps_size);
-        av_format_ctx->avio_write(pb, pps, pps_size);
-      }
-      av_util_ctx->av_free(start);
-    }
-    else
-    {
-      av_format_ctx->avio_write(pb, data, len);
-    }
-  }
-  return 0;
-}
-
-
 static DllLibVDADecoder *g_DllLibVDADecoder = (DllLibVDADecoder*)-1;
 ////////////////////////////////////////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////////////////////////////////////////
@@ -624,12 +205,14 @@
   m_display_queue = NULL;
   pthread_mutex_init(&m_queue_mutex, NULL);
 
-  m_convert_bytestream = false;
-  m_convert_3byteTo4byteNALSize = false;
-  m_dllAvUtil = NULL;
-  m_dllAvFormat = NULL;
+  m_bitstream = NULL;
   m_dllSwScale = NULL;
   memset(&m_videobuffer, 0, sizeof(DVDVideoPicture));
+  m_dll = NULL;
+  m_DropPictures = false;
+  m_decode_async = false;
+  m_sort_time_offset = 0.0;
+  m_use_cvBufferRef = false;
 }
 
 CDVDVideoCodecVDA::~CDVDVideoCodecVDA()
@@ -656,17 +239,12 @@
   if (g_guiSettings.GetBool("videoplayer.usevda") && !hints.software)
   {
     CCocoaAutoPool pool;
-    CFDataRef avcCData;
-    uint8_t *extradata; // extra data for codec to use
-    unsigned int extrasize; // size of extra data
 
     //
     int width  = hints.width;
     int height = hints.height;
     int level  = hints.level;
     int profile = hints.profile;
-    extrasize = hints.extrasize;
-    extradata = (uint8_t*)hints.extradata;
     
     switch(profile)
     {
@@ -695,71 +273,16 @@
       return false;
     }
 
+    CFDataRef avcCData;
     switch (hints.codec)
     {
       case CODEC_ID_H264:
-        // source must be H.264 with valid avcC atom data in extradata
-        if (extrasize < 7 || extradata == NULL)
-        {
-          CLog::Log(LOGNOTICE, "%s - avcC atom too data small or missing", __FUNCTION__);
-          return false;
-        }
-        // valid avcC atom data always starts with the value 1 (version)
-        if ( *extradata != 1 )
-        {
-          if ( (extradata[0] == 0 && extradata[1] == 0 && extradata[2] == 0 && extradata[3] == 1) ||
-               (extradata[0] == 0 && extradata[1] == 0 && extradata[2] == 1) )
-          {
-            // video content is from x264 or from bytestream h264 (AnnexB format)
-            // NAL reformating to bitstream format needed
-            m_dllAvUtil = new DllAvUtil;
-            m_dllAvFormat = new DllAvFormat;
-            if (!m_dllAvUtil->Load() || !m_dllAvFormat->Load())
-            {
-              return false;
-            }
-
-            AVIOContext *pb;
-            if (m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
-            {
-              return false;
-            }
-
-            m_convert_bytestream = true;
-            // create a valid avcC atom data from ffmpeg's extradata
-            isom_write_avcc(m_dllAvUtil, m_dllAvFormat, pb, extradata, extrasize);
-            // unhook from ffmpeg's extradata
-            extradata = NULL;
-            // extract the avcC atom data into extradata then write it into avcCData for VDADecoder
-            extrasize = m_dllAvFormat->avio_close_dyn_buf(pb, &extradata);
-            // CFDataCreate makes a copy of extradata contents
-            avcCData = CFDataCreate(kCFAllocatorDefault, (const uint8_t*)extradata, extrasize);
-            // done with the converted extradata, we MUST free using av_free
-            m_dllAvUtil->av_free(extradata);
-          }
-          else
-          {
-            CLog::Log(LOGNOTICE, "%s - invalid avcC atom data", __FUNCTION__);
-            return false;
-          }
-        }
-        else
-        {
-          if (extradata[4] == 0xFE)
-          {
-            // video content is from so silly encoder that think 3 byte NAL sizes
-            // are valid, setup to convert 3 byte NAL sizes to 4 byte.
-            m_dllAvUtil = new DllAvUtil;
-            m_dllAvFormat = new DllAvFormat;
-            if (!m_dllAvUtil->Load() || !m_dllAvFormat->Load())
+        m_bitstream = new CBitstreamConverter;
+        if (!m_bitstream->Open(hints.codec, (uint8_t*)hints.extradata, hints.extrasize, false))
               return false;
 
-            extradata[4] = 0xFF;
-            m_convert_3byteTo4byteNALSize = true;
-          }
-          // CFDataCreate makes a copy of extradata contents
-          avcCData = CFDataCreate(kCFAllocatorDefault, (const uint8_t*)extradata, extrasize);
-        }
+        avcCData = CFDataCreate(kCFAllocatorDefault,
+          (const uint8_t*)m_bitstream->GetExtraData(), m_bitstream->GetExtraSize());
 
         m_format = 'avc1';
         m_pFormatName = "vda-h264";
@@ -776,15 +299,16 @@
     {
       // avcc atoms with length less than 8 are borked.
       CFRelease(avcCData);
+      delete m_bitstream, m_bitstream = NULL;
       return false;
     }
     else
     {
       bool interlaced = true;
       uint8_t *spc = (uint8_t*)CFDataGetBytePtr(avcCData) + 6;
-      uint32_t sps_size = VDA_RB16(spc);
+      uint32_t sps_size = BS_RB16(spc);
       if (sps_size)
-        parseh264_sps(spc+3, sps_size-1, &level, &profile, &interlaced, &m_max_ref_frames);
+        m_bitstream->parseh264_sps(spc+3, sps_size-1, &interlaced, &m_max_ref_frames);
       if (interlaced)
       {
         CLog::Log(LOGNOTICE, "%s - possible interlaced content.", __FUNCTION__);
@@ -952,14 +476,11 @@
     m_videobuffer.iFlags = 0;
   }
 
-  if (m_dllAvUtil)
-    delete m_dllAvUtil, m_dllAvUtil = NULL;
+  if (m_bitstream)
+    delete m_bitstream, m_bitstream = NULL;
 
   if (m_dllSwScale)
     delete m_dllSwScale, m_dllSwScale = NULL;
-
-  if (m_dllAvFormat)
-    delete m_dllAvFormat, m_dllAvFormat = NULL;
 }
 
 void CDVDVideoCodecVDA::SetDropState(bool bDrop)
@@ -973,63 +494,18 @@
   //
   if (pData)
   {
-    OSStatus status;
-    double sort_time;
-    uint32_t avc_flags = 0;
-    CFDataRef avc_demux;
-    CFDictionaryRef avc_time;
+    m_bitstream->Convert(pData, iSize);
+    CFDataRef avc_demux = CFDataCreate(kCFAllocatorDefault,
+      m_bitstream->GetConvertBuffer(), m_bitstream->GetConvertSize());
 
-    if (m_convert_bytestream)
-    {
-      // convert demuxer packet from bytestream (AnnexB) to bitstream
-      AVIOContext *pb;
-      int demuxer_bytes;
-      uint8_t *demuxer_content;
-
-      if(m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
-      {
-        return VC_ERROR;
-      }
-      demuxer_bytes = avc_parse_nal_units(m_dllAvFormat, pb, pData, iSize);
-      demuxer_bytes = m_dllAvFormat->avio_close_dyn_buf(pb, &demuxer_content);
-      avc_demux = CFDataCreate(kCFAllocatorDefault, demuxer_content, demuxer_bytes);
-      m_dllAvUtil->av_free(demuxer_content);
-    }
-    else if (m_convert_3byteTo4byteNALSize)
-    {
-      // convert demuxer packet from 3 byte NAL sizes to 4 byte
-      AVIOContext *pb;
-      if (m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
-        return VC_ERROR;
-
-      uint32_t nal_size;
-      uint8_t *end = pData + iSize;
-      uint8_t *nal_start = pData;
-      while (nal_start < end)
-      {
-        nal_size = VDA_RB24(nal_start);
-        m_dllAvFormat->avio_wb32(pb, nal_size);
-        nal_start += 3;
-        m_dllAvFormat->avio_write(pb, nal_start, nal_size);
-        nal_start += nal_size;
-      }
-
-      uint8_t *demuxer_content;
-      int demuxer_bytes = m_dllAvFormat->avio_close_dyn_buf(pb, &demuxer_content);
-      avc_demux = CFDataCreate(kCFAllocatorDefault, demuxer_content, demuxer_bytes);
-      m_dllAvUtil->av_free(demuxer_content);
-    }
-    else
-    {
-      avc_demux = CFDataCreate(kCFAllocatorDefault, pData, iSize);
-    }
-    sort_time = (CurrentHostCounter() * 1000.0) / CurrentHostFrequency();
-    avc_time = CreateDictionaryWithDisplayTime(sort_time - m_sort_time_offset, dts, pts);
+    double sort_time = (CurrentHostCounter() * 1000.0) / CurrentHostFrequency();
+    CFDictionaryRef avc_time = CreateDictionaryWithDisplayTime(sort_time - m_sort_time_offset, dts, pts);
 
+    uint32_t avc_flags = 0;
     if (m_DropPictures)
       avc_flags = kVDADecoderDecodeFlags_DontEmitFrame;
 
-    status = m_dll->VDADecoderDecode((VDADecoder)m_vda_decoder, avc_flags, avc_demux, avc_time);
+    OSStatus status = m_dll->VDADecoderDecode((VDADecoder)m_vda_decoder, avc_flags, avc_demux, avc_time);
     CFRelease(avc_time);
     CFRelease(avc_demux);
     if (status != kVDADecoderNoErr)
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.h	2013-03-05 19:37:56.582328697 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.h	2013-03-08 08:42:01.930923975 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -19,25 +19,14 @@
  *
  */
 
-#if defined(HAVE_LIBVDADECODER)
-
 #include "DVDVideoCodec.h"
 #include <CoreVideo/CoreVideo.h>
 
-// tracks a frame in and output queue in display order
-typedef struct frame_queue {
-  double              dts;
-  double              pts;
-  double              sort_time;
-  FourCharCode        pixel_buffer_format;
-  CVBufferRef         pixel_buffer_ref;
-  struct frame_queue  *nextframe;
-} frame_queue;
-
-class DllAvUtil;
 class DllSwScale;
-class DllAvFormat;
 class DllLibVDADecoder;
+class CBitstreamConverter;
+struct frame_queue;
+
 class CDVDVideoCodecVDA : public CDVDVideoCodec
 {
 public:
@@ -77,13 +66,8 @@
   int32_t           m_max_ref_frames;
   bool              m_use_cvBufferRef;
   
-  bool              m_convert_bytestream;
-  bool              m_convert_3byteTo4byteNALSize;
-  DllAvUtil         *m_dllAvUtil;
-  DllAvFormat       *m_dllAvFormat;
+  CBitstreamConverter *m_bitstream;
 
   DllSwScale        *m_dllSwScale;
   DVDVideoPicture   m_videobuffer;
 };
-
-#endif
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp	2013-02-16 18:48:38.284395418 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp	2013-04-05 11:38:43.916814623 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -1046,6 +1046,8 @@
   m_dllAvUtil   = NULL;
   m_dllAvFormat = NULL;
   memset(&m_videobuffer, 0, sizeof(DVDVideoPicture));
+  m_DropPictures = false;
+  m_sort_time_offset = 0.0;
 }
 
 CDVDVideoCodecVideoToolBox::~CDVDVideoCodecVideoToolBox()
@@ -1349,7 +1351,7 @@
       if(m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
         return VC_ERROR;
 
-      demux_size = avc_parse_nal_units(m_dllAvFormat, pb, pData, iSize);
+      avc_parse_nal_units(m_dllAvFormat, pb, pData, iSize);
       demux_size = m_dllAvFormat->avio_close_dyn_buf(pb, &demux_buff);
       sampleBuff = CreateSampleBufferFrom(m_fmt_desc, demux_buff, demux_size);
     }
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.h	2013-02-16 18:48:38.284395418 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.h	2013-02-10 14:23:18.516515209 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoPPFFmpeg.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoPPFFmpeg.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoPPFFmpeg.cpp	2013-02-16 18:48:38.284395418 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoPPFFmpeg.cpp	2013-02-10 14:23:18.516515209 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoPPFFmpeg.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoPPFFmpeg.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoPPFFmpeg.h	2013-02-16 18:48:38.284395418 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoPPFFmpeg.h	2013-02-10 14:23:18.526515016 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVA.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVA.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVA.cpp	2013-02-16 18:48:38.304395022 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVA.cpp	2013-04-05 11:38:43.916814623 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -39,6 +39,7 @@
 #include "boost/shared_ptr.hpp"
 #include "utils/AutoPtrHandle.h"
 #include "settings/AdvancedSettings.h"
+#include "settings/MediaSettings.h"
 #include "cores/VideoRenderers/RenderManager.h"
 #include "win32/WIN32Util.h"
 
@@ -312,7 +313,7 @@
 
 CSurfaceContext::~CSurfaceContext()
 {
-  for (vector<IDirect3DSurface9*>::iterator it = m_heldsurfaces.begin(); it != m_heldsurfaces.end(); it++)
+  for (vector<IDirect3DSurface9*>::iterator it = m_heldsurfaces.begin(); it != m_heldsurfaces.end(); ++it)
     SAFE_RELEASE(*it);
 }
 
@@ -1175,8 +1176,8 @@
   // And for those GPUs, the correct values will be calculated with the first Render() and the correct processor
   // will replace the one allocated here, before the user sees anything.
   // It's a bit inefficient, that's all.
-  m_deinterlace_mode = g_settings.m_currentVideoSettings.m_DeinterlaceMode;
-  m_interlace_method = g_renderManager.AutoInterlaceMethod(g_settings.m_currentVideoSettings.m_InterlaceMethod);;
+  m_deinterlace_mode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+  m_interlace_method = g_renderManager.AutoInterlaceMethod(CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod);;
 
   EvaluateQuirkNoDeintProcForProg();
 
@@ -1460,10 +1461,10 @@
   // With auto deinterlacing, the Ion Gen. 1 drops some frames with deinterlacing processor + progressive flags for progressive material.
   // For that GPU (or when specified by an advanced setting), use the progressive processor.
   // This is at the expense of the switch speed when video interlacing flags change and a deinterlacing processor is actually required.
-  EDEINTERLACEMODE mode = g_settings.m_currentVideoSettings.m_DeinterlaceMode;
+  EDEINTERLACEMODE mode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
   if (g_advancedSettings.m_DXVANoDeintProcForProgressive || m_quirk_nodeintprocforprog)
     mode = (flags & RENDER_FLAG_FIELD0 || flags & RENDER_FLAG_FIELD1) ? VS_DEINTERLACEMODE_FORCE : VS_DEINTERLACEMODE_OFF;
-  EINTERLACEMETHOD method = g_renderManager.AutoInterlaceMethod(g_settings.m_currentVideoSettings.m_InterlaceMethod);
+  EINTERLACEMETHOD method = g_renderManager.AutoInterlaceMethod(CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod);
   if(m_interlace_method != method
   || m_deinterlace_mode != mode
   || !m_process)
@@ -1489,7 +1490,7 @@
       it = m_sample.erase(it);
     }
     else
-      it++;
+      ++it;
   }
 
   if(m_sample.empty())
@@ -1519,7 +1520,7 @@
   for (int i = 0; i < count; i++)
     samp[i].SampleFormat.SampleFormat = DXVA2_SampleUnknown;
 
-  for(it = m_sample.begin(); it != m_sample.end() && valid < count; it++)
+  for(it = m_sample.begin(); it != m_sample.end() && valid < count; ++it)
   {
     if (it->sample.Start >= MinTime && it->sample.Start <= MaxTime)
     {
@@ -1571,12 +1572,15 @@
 
   blt.DestFormat.VideoTransferFunction = DXVA2_VideoTransFunc_sRGB;
   blt.DestFormat.SampleFormat          = DXVA2_SampleProgressiveFrame;
+  if(g_Windowing.UseLimitedColor())
+    blt.DestFormat.NominalRange          = DXVA2_NominalRange_16_235;
+  else
   blt.DestFormat.NominalRange          = DXVA2_NominalRange_0_255;
   blt.Alpha = DXVA2_Fixed32OpaqueAlpha();
 
-  blt.ProcAmpValues.Brightness = ConvertRange( m_brightness, g_settings.m_currentVideoSettings.m_Brightness
+  blt.ProcAmpValues.Brightness = ConvertRange( m_brightness, CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness
                                              , 0, 100, 50);
-  blt.ProcAmpValues.Contrast   = ConvertRange( m_contrast, g_settings.m_currentVideoSettings.m_Contrast
+  blt.ProcAmpValues.Contrast   = ConvertRange( m_contrast, CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast
                                              , 0, 100, 50);
   blt.ProcAmpValues.Hue        = m_hue.DefaultValue;
   blt.ProcAmpValues.Saturation = m_saturation.DefaultValue;
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVA.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVA.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVA.h	2013-02-16 18:48:38.304395022 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVA.h	2013-02-10 14:23:18.526515016 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DllLibMpeg2.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DllLibMpeg2.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/DllLibMpeg2.h	2013-02-16 18:48:38.304395022 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/DllLibMpeg2.h	2013-02-10 14:23:18.526515016 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMax.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMax.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMax.cpp	2013-02-16 18:48:38.304395022 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMax.cpp	2013-04-05 11:38:43.916814623 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -103,6 +103,9 @@
   m_is_open = false;
 
   m_omx_decoder = NULL;
+  m_omx_client_state = DEAD;
+  m_omx_decoder_state = 0;
+  sem_init(m_omx_decoder_state_change, 0, 0);
   /*
   m_omx_flush_input  = (sem_t*)malloc(sizeof(sem_t));
   sem_init(m_omx_flush_input, 0, 0);
@@ -167,11 +170,10 @@
 // Wait for a component to transition to the specified state
 OMX_ERRORTYPE COpenMax::WaitForState(OMX_STATETYPE state)
 {
-  OMX_ERRORTYPE omx_error = OMX_ErrorNone;
   OMX_STATETYPE test_state;
   int tries = 0;
   struct timespec timeout;
-  omx_error = OMX_GetState(m_omx_decoder, &test_state);
+  OMX_ERRORTYPE omx_error = OMX_GetState(m_omx_decoder, &test_state);
 
   #if defined(OMX_DEBUG_VERBOSE)
   CLog::Log(LOGDEBUG, "%s::%s - waiting for state(%d)\n", CLASSNAME, __func__, state);
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMax.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMax.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMax.h	2013-02-16 18:48:38.304395022 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMax.h	2013-02-10 14:23:18.536514822 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp	2013-02-16 18:48:38.324394626 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp	2013-04-05 11:38:43.926814443 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -86,6 +86,15 @@
 
   m_omx_decoder_state_change = (sem_t*)malloc(sizeof(sem_t));
   sem_init(m_omx_decoder_state_change, 0, 0);
+  memset(&m_videobuffer, 0, sizeof(DVDVideoPicture));
+  m_drop_state = false;
+  m_decoded_width = 0;
+  m_decoded_height = 0;
+  m_omx_input_eos = false;
+  m_omx_input_port = 0;
+  m_omx_output_eos = false;
+  m_omx_output_port = 0;
+  m_videoplayback_done = false;
 }
 
 COpenMaxVideo::~COpenMaxVideo()
@@ -861,7 +870,7 @@
           if (ctx->m_omx_output_port == (int)nData2)
           {
             // Got OMX_CommandPortDisable event, alloc new buffers for the output port.
-            omx_err = ctx->AllocOMXOutputBuffers();
+            ctx->AllocOMXOutputBuffers();
             omx_err = OMX_SendCommand(ctx->m_omx_decoder, OMX_CommandPortEnable, ctx->m_omx_output_port, NULL);
           }
         break;
@@ -917,7 +926,7 @@
         // OMX_CommandPortDisable to component as it expects output buffers
         // to be freed before it will issue a OMX_CommandPortDisable event.
         ctx->m_portChanging = true;
-        omx_err = OMX_SendCommand(ctx->m_omx_decoder, OMX_CommandPortDisable, ctx->m_omx_output_port, NULL);
+        OMX_SendCommand(ctx->m_omx_decoder, OMX_CommandPortDisable, ctx->m_omx_output_port, NULL);
         omx_err = ctx->FreeOMXOutputBuffers(false);
       }
     break;
@@ -1025,9 +1034,9 @@
 
   // we can free our allocated port buffers in OMX_StateIdle state.
   // free OpenMax input buffers.
-  omx_err = FreeOMXInputBuffers(true);
+  FreeOMXInputBuffers(true);
   // free OpenMax output buffers.
-  omx_err = FreeOMXOutputBuffers(true);
+  FreeOMXOutputBuffers(true);
 
   // transition decoder component from idle to loaded
   omx_err = SetStateForComponent(OMX_StateLoaded);
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h	2013-02-16 18:48:38.324394626 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h	2013-02-10 14:23:18.536514822 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp	2013-02-16 18:48:38.324394626 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp	2013-04-05 11:38:43.926814443 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This library is free software; you can redistribute it and/or
@@ -161,7 +161,7 @@
 {
   VASurfaceID surface = GetSurfaceID(pic);
 
-  for(std::list<CSurfacePtr>::iterator it = m_surfaces_used.begin(); it != m_surfaces_used.end(); it++)
+  for(std::list<CSurfacePtr>::iterator it = m_surfaces_used.begin(); it != m_surfaces_used.end(); ++it)
   {    
     if((*it)->m_id == surface)
     {
@@ -184,7 +184,7 @@
   if(surface)
   {
     /* reget call */
-    for(; it != m_surfaces_free.end(); it++)
+    for(; it != m_surfaces_free.end(); ++it)
     {
       if((*it)->m_id == surface)
       {
@@ -204,7 +204,7 @@
   {
     // To avoid stutter, we scan the free surface pool (provided by decoder) for surfaces
     // that are 100% not in use by renderer. The pointers to these surfaces have a use_count of 1.
-    for (; it != m_surfaces_free.end() && it->use_count() > 1; it++) {}
+    for (; it != m_surfaces_free.end() && it->use_count() > 1; ++it) {}
 
     // If we have zero free surface from decoder OR all free surfaces are in use by renderer, we allocate a new surface
     if (it == m_surfaces_free.end())
@@ -217,7 +217,7 @@
         return -1;
       }
       // Set itarator position to the newly allocated surface (end-1)
-      it = m_surfaces_free.end(); it--;
+      it = m_surfaces_free.end(); --it;
     }
     /* getbuffer call */
     wrapper = it->get();
@@ -452,7 +452,7 @@
   m_holder.surface.reset();
 
   std::list<CSurfacePtr>::iterator it;
-  for(it = m_surfaces_used.begin(); it != m_surfaces_used.end() && !m_holder.surface; it++)
+  for(it = m_surfaces_used.begin(); it != m_surfaces_used.end() && !m_holder.surface; ++it)
   {    
     if((*it)->m_id == surface)
     {
@@ -461,7 +461,7 @@
     }
   }
 
-  for(it = m_surfaces_free.begin(); it != m_surfaces_free.end() && !m_holder.surface; it++)
+  for(it = m_surfaces_free.begin(); it != m_surfaces_free.end() && !m_holder.surface; ++it)
   {    
     if((*it)->m_id == surface)
     {
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h	2013-02-16 18:48:38.324394626 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h	2013-02-10 14:23:18.536514822 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This library is free software; you can redistribute it and/or
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp	2013-02-16 18:48:38.344394229 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp	2013-04-05 11:38:43.926814443 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -30,6 +30,7 @@
 #include "settings/Settings.h"
 #include "settings/GUISettings.h"
 #include "settings/AdvancedSettings.h"
+#include "settings/MediaSettings.h"
 #include "Application.h"
 #include "utils/MathUtils.h"
 #include "DVDCodecs/DVDCodecUtils.h"
@@ -147,6 +148,31 @@
   dl_vdp_device_create_x11 = NULL;
   dl_vdp_get_proc_address = NULL;
   dl_vdp_preemption_callback_register = NULL;
+  past[0] = NULL;
+  past[1] = NULL;
+  current = NULL;
+  future = NULL;
+  tmpNoiseReduction = 0.0f;
+  tmpSharpness = 0.0f;
+  vdp_get_proc_address = NULL;
+  vdp_device_destroy = NULL;
+  vdp_video_surface_create = NULL;
+  vdp_video_surface_destroy = NULL;
+  vdp_video_surface_put_bits_y_cb_cr = NULL;
+  vdp_video_surface_get_bits_y_cb_cr = NULL;
+  vdp_output_surface_put_bits_y_cb_cr = NULL;
+  vdp_output_surface_put_bits_native = NULL;
+  vdp_output_surface_create = NULL;
+  vdp_output_surface_destroy = NULL;
+  vdp_output_surface_get_bits_native = NULL;
+  vdp_output_surface_render_output_surface = NULL;
+  vdp_output_surface_put_bits_indexed = NULL;
+  vdp_video_mixer_create = NULL;
+  vdp_video_mixer_set_feature_enables = NULL;
+  vdp_video_mixer_query_parameter_support = NULL;
+  vdp_video_mixer_query_feature_support = NULL;
+  vdp_video_mixer_destroy = NULL;
+  vdp_video_mixer_render = NULL;
 }
 
 bool CVDPAU::Open(AVCodecContext* avctx, const enum PixelFormat, unsigned int surfaces)
@@ -501,8 +527,7 @@
     tmpNoiseReduction = 0;
     tmpSharpness = 0;
 
-    VdpStatus vdp_st = VDP_STATUS_ERROR;
-    vdp_st = vdp_video_mixer_create(vdp_device,
+    VdpStatus vdp_st = vdp_video_mixer_create(vdp_device,
                                     m_feature_count,
                                     m_features,
                                     ARSIZE(parameters),
@@ -514,29 +539,29 @@
     SetHWUpscaling();
   }
 
-  if (tmpBrightness != g_settings.m_currentVideoSettings.m_Brightness ||
-      tmpContrast   != g_settings.m_currentVideoSettings.m_Contrast)
+  if (tmpBrightness != CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness ||
+      tmpContrast   != CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast)
   {
     SetColor();
-    tmpBrightness = g_settings.m_currentVideoSettings.m_Brightness;
-    tmpContrast = g_settings.m_currentVideoSettings.m_Contrast;
+    tmpBrightness = CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness;
+    tmpContrast = CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast;
   }
-  if (tmpNoiseReduction != g_settings.m_currentVideoSettings.m_NoiseReduction)
+  if (tmpNoiseReduction != CMediaSettings::Get().GetCurrentVideoSettings().m_NoiseReduction)
   {
-    tmpNoiseReduction = g_settings.m_currentVideoSettings.m_NoiseReduction;
+    tmpNoiseReduction = CMediaSettings::Get().GetCurrentVideoSettings().m_NoiseReduction;
     SetNoiseReduction();
   }
-  if (tmpSharpness != g_settings.m_currentVideoSettings.m_Sharpness)
+  if (tmpSharpness != CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness)
   {
-    tmpSharpness = g_settings.m_currentVideoSettings.m_Sharpness;
+    tmpSharpness = CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness;
     SetSharpness();
   }
-  if (  tmpDeintMode != g_settings.m_currentVideoSettings.m_DeinterlaceMode ||
-        tmpDeintGUI  != g_settings.m_currentVideoSettings.m_InterlaceMethod ||
+  if (  tmpDeintMode != CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode ||
+        tmpDeintGUI  != CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod ||
        (tmpDeintGUI == VS_INTERLACEMETHOD_AUTO && tmpDeint != AutoInterlaceMethod()))
   {
-    tmpDeintMode = g_settings.m_currentVideoSettings.m_DeinterlaceMode;
-    tmpDeintGUI  = g_settings.m_currentVideoSettings.m_InterlaceMethod;
+    tmpDeintMode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+    tmpDeintGUI  = CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod;
     if (tmpDeintGUI == VS_INTERLACEMETHOD_AUTO)
       tmpDeint = AutoInterlaceMethod();
     else
@@ -580,10 +605,10 @@
 {
   VdpStatus vdp_st;
 
-  if (tmpBrightness != g_settings.m_currentVideoSettings.m_Brightness)
-    m_Procamp.brightness = (float)((g_settings.m_currentVideoSettings.m_Brightness)-50) / 100;
-  if (tmpContrast != g_settings.m_currentVideoSettings.m_Contrast)
-    m_Procamp.contrast = (float)((g_settings.m_currentVideoSettings.m_Contrast)+50) / 100;
+  if (tmpBrightness != CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness)
+    m_Procamp.brightness = (float)((CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness)-50) / 100;
+  if (tmpContrast != CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast)
+    m_Procamp.contrast = (float)((CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast)+50) / 100;
 
   if(vid_height >= 600 || vid_width > 1024)
     vdp_st = vdp_generate_csc_matrix(&m_Procamp, VDP_COLOR_STANDARD_ITUR_BT_709, &m_CSCMatrix);
@@ -591,7 +616,7 @@
     vdp_st = vdp_generate_csc_matrix(&m_Procamp, VDP_COLOR_STANDARD_ITUR_BT_601, &m_CSCMatrix);
 
   VdpVideoMixerAttribute attributes[] = { VDP_VIDEO_MIXER_ATTRIBUTE_CSC_MATRIX };
-  if (g_guiSettings.GetBool("videoplayer.vdpaustudiolevel"))
+  if (g_guiSettings.GetBool("videoscreen.limitedrange"))
   {
     void const * pm_CSCMatix[] = { &studioCSC };
     vdp_st = vdp_video_mixer_set_attribute_values(videoMixer, ARSIZE(attributes), attributes, pm_CSCMatix);
@@ -613,7 +638,7 @@
   VdpVideoMixerAttribute attributes[] = { VDP_VIDEO_MIXER_ATTRIBUTE_NOISE_REDUCTION_LEVEL };
   VdpStatus vdp_st;
 
-  if (!g_settings.m_currentVideoSettings.m_NoiseReduction)
+  if (!CMediaSettings::Get().GetCurrentVideoSettings().m_NoiseReduction)
   {
     VdpBool enabled[]= {0};
     vdp_st = vdp_video_mixer_set_feature_enables(videoMixer, ARSIZE(feature), feature, enabled);
@@ -623,8 +648,8 @@
   VdpBool enabled[]={1};
   vdp_st = vdp_video_mixer_set_feature_enables(videoMixer, ARSIZE(feature), feature, enabled);
   CheckStatus(vdp_st, __LINE__);
-  void* nr[] = { &g_settings.m_currentVideoSettings.m_NoiseReduction };
-  CLog::Log(LOGNOTICE,"Setting Noise Reduction to %f",g_settings.m_currentVideoSettings.m_NoiseReduction);
+  void* nr[] = { &CMediaSettings::Get().GetCurrentVideoSettings().m_NoiseReduction };
+  CLog::Log(LOGNOTICE,"Setting Noise Reduction to %f",CMediaSettings::Get().GetCurrentVideoSettings().m_NoiseReduction);
   vdp_st = vdp_video_mixer_set_attribute_values(videoMixer, ARSIZE(attributes), attributes, nr);
   CheckStatus(vdp_st, __LINE__);
 }
@@ -638,7 +663,7 @@
   VdpVideoMixerAttribute attributes[] = { VDP_VIDEO_MIXER_ATTRIBUTE_SHARPNESS_LEVEL };
   VdpStatus vdp_st;
 
-  if (!g_settings.m_currentVideoSettings.m_Sharpness)
+  if (!CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness)
   {
     VdpBool enabled[]={0};
     vdp_st = vdp_video_mixer_set_feature_enables(videoMixer, ARSIZE(feature), feature, enabled);
@@ -648,8 +673,8 @@
   VdpBool enabled[]={1};
   vdp_st = vdp_video_mixer_set_feature_enables(videoMixer, ARSIZE(feature), feature, enabled);
   CheckStatus(vdp_st, __LINE__);
-  void* sh[] = { &g_settings.m_currentVideoSettings.m_Sharpness };
-  CLog::Log(LOGNOTICE,"Setting Sharpness to %f",g_settings.m_currentVideoSettings.m_Sharpness);
+  void* sh[] = { &CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness };
+  CLog::Log(LOGNOTICE,"Setting Sharpness to %f",CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness);
   vdp_st = vdp_video_mixer_set_attribute_values(videoMixer, ARSIZE(attributes), attributes, sh);
   CheckStatus(vdp_st, __LINE__);
 }
@@ -671,8 +696,8 @@
 void CVDPAU::SetDeinterlacing()
 {
   VdpStatus vdp_st;
-  EDEINTERLACEMODE   mode = g_settings.m_currentVideoSettings.m_DeinterlaceMode;
-  EINTERLACEMETHOD method = g_settings.m_currentVideoSettings.m_InterlaceMethod;
+  EDEINTERLACEMODE   mode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+  EINTERLACEMETHOD method = CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod;
   if (method == VS_INTERLACEMETHOD_AUTO)
     method = AutoInterlaceMethod();
 
@@ -1381,8 +1406,8 @@
     outRectVid.y1 = OutHeight;
   }
 
-  EDEINTERLACEMODE   mode = g_settings.m_currentVideoSettings.m_DeinterlaceMode;
-  EINTERLACEMETHOD method = g_settings.m_currentVideoSettings.m_InterlaceMethod;
+  EDEINTERLACEMODE   mode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+  EINTERLACEMETHOD method = CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod;
   if (method == VS_INTERLACEMETHOD_AUTO)
     method = AutoInterlaceMethod();
 
@@ -1516,7 +1541,7 @@
     }
   }
 
-  vdp_st = vdp_presentation_queue_block_until_surface_idle(vdp_flip_queue,outputSurface,&time);
+  vdp_presentation_queue_block_until_surface_idle(vdp_flip_queue,outputSurface,&time);
 
   VdpRect sourceRect = {0,0,vid_width, vid_height};
 
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h	2013-02-16 18:48:38.344394229 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h	2013-02-10 14:23:18.546514627 +0000
@@ -1,7 +1,7 @@
 
 #pragma once
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxSPU.cpp xbmc/xbmc/cores/dvdplayer/DVDDemuxSPU.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxSPU.cpp	2013-02-16 18:48:38.344394229 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxSPU.cpp	2013-04-05 11:38:43.936814262 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -582,10 +582,10 @@
   else
   {
     // old code
-    int i, i_inner = -1, i_shade = -1;
 
     if (last_color >= 0 && last_color < 4)
     {
+      int i, i_inner = -1, i_shade = -1;
       // Set the border color, the last color is probably the border color
       pSPU->color[last_color][0] = custom_subtitle_color[COLOR_BORDER][0];
       pSPU->color[last_color][1] = custom_subtitle_color[COLOR_BORDER][1];
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxSPU.h xbmc/xbmc/cores/dvdplayer/DVDDemuxSPU.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxSPU.h	2013-02-16 18:48:38.344394229 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxSPU.h	2013-04-05 11:38:43.936814262 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -46,8 +46,8 @@
   CDVDOverlaySpu* AddData(BYTE* data, int iSize, double pts); // returns a packet from ParsePacket if possible
 
   CDVDOverlaySpu* ParseRLE(CDVDOverlaySpu* pSPU, BYTE* pUnparsedData);
-  void FindSubtitleColor(int last_color, int stats[4], CDVDOverlaySpu* pSPU);
-  bool CanDisplayWithAlphas(int a[4], int stats[4]);
+  static void FindSubtitleColor(int last_color, int stats[4], CDVDOverlaySpu* pSPU);
+  static bool CanDisplayWithAlphas(int a[4], int stats[4]);
 
   void Reset();
   void FlushCurrentPacket(); // flushes current unparsed data
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.cpp xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.cpp	2013-02-16 18:48:38.344394229 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.cpp	2013-04-02 23:19:38.303455983 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -20,7 +20,6 @@
 
 #include "DVDDemux.h"
 #include "DVDCodecs/DVDCodecs.h"
-#include "utils/LangCodeExpander.h"
 
 void CDemuxStreamTeletext::GetStreamInfo(std::string& strInfo)
 {
@@ -44,15 +43,17 @@
       strcpy(sInfo, "DTS ");
   }
   else if (codec == CODEC_ID_MP2) strcpy(sInfo, "MP2 ");
+  else if (codec == CODEC_ID_TRUEHD) strcpy(sInfo, "Dolby TrueHD ");
   else strcpy(sInfo, "");
 
   if (iChannels == 1) strcat(sInfo, "Mono");
   else if (iChannels == 2) strcat(sInfo, "Stereo");
   else if (iChannels == 6) strcat(sInfo, "5.1");
+  else if (iChannels == 8) strcat(sInfo, "7.1");
   else if (iChannels != 0)
   {
     char temp[32];
-    sprintf(temp, " %d %s", iChannels, "Channels");
+    sprintf(temp, " %d%s", iChannels, "-chs");
     strcat(sInfo, temp);
   }
   strInfo = sInfo;
@@ -168,14 +169,7 @@
 
 void CDemuxStream::GetStreamName( std::string& strInfo )
 {
-  if( language[0] == 0 )
     strInfo = "";
-  else
-  {
-    CStdString name;
-    g_LangCodeExpander.Lookup( name, language );
-    strInfo = name;
-  }
 }
 
 AVDiscard CDemuxStream::GetDiscard()
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.h xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.h	2013-02-16 18:48:38.364393832 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.h	2013-02-10 14:23:18.556514432 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxBXA.cpp xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxBXA.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxBXA.cpp	2013-02-16 18:48:38.364393832 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxBXA.cpp	2013-02-10 14:23:18.556514432 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2012 Team XBMC
+ *      Copyright (C) 2012-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxBXA.h xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxBXA.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxBXA.h	2013-02-16 18:48:38.364393832 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxBXA.h	2013-02-10 14:23:18.556514432 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2012 Team XBMC
+ *      Copyright (C) 2012-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp	2013-02-16 18:48:38.364393832 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp	2013-02-11 10:42:50.792893398 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -446,7 +446,9 @@
     if (iErr < 0)
     {
       CLog::Log(LOGWARNING,"could not find codec parameters for %s", strFile.c_str());
-      if (m_pInput->IsStreamType(DVDSTREAM_TYPE_DVD) || (m_pFormatContext->nb_streams == 1 && m_pFormatContext->streams[0]->codec->codec_id == CODEC_ID_AC3))
+      if (m_pInput->IsStreamType(DVDSTREAM_TYPE_DVD)
+      ||  m_pInput->IsStreamType(DVDSTREAM_TYPE_BLURAY)
+      || (m_pFormatContext->nb_streams == 1 && m_pFormatContext->streams[0]->codec->codec_id == CODEC_ID_AC3))
       {
         // special case, our codecs can still handle it.
       }
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h	2013-02-16 18:48:38.364393832 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h	2013-02-10 14:23:18.556514432 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxHTSP.cpp xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxHTSP.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxHTSP.cpp	2013-02-16 18:48:38.364393832 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxHTSP.cpp	2013-04-05 11:38:43.936814262 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -102,7 +102,7 @@
   m_Input       = (CDVDInputStreamHTSP*)input;
   m_StatusCount = 0;
 
-  while(m_Streams.size() == 0 && m_StatusCount == 0)
+  while(m_Streams.empty() && m_StatusCount == 0)
   {
     DemuxPacket* pkg = Read();
     if(!pkg)
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxHTSP.h xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxHTSP.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxHTSP.h	2013-02-16 18:48:38.384393435 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxHTSP.h	2013-02-10 14:23:18.566514238 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp	2013-02-16 18:48:38.384393435 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp	2013-04-05 11:38:43.936814262 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2012 Team XBMC
+ *      Copyright (C) 2012-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -34,6 +34,7 @@
  : m_parent(parent)
  , m_parser(NULL)
  , m_context(NULL)
+ , m_parser_split(false)
 {
 }
 
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.h xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.h	2013-02-16 18:48:38.384393435 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.h	2013-02-10 14:23:18.566514238 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2012 Team XBMC
+ *      Copyright (C) 2012-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPacket.h xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPacket.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPacket.h	2013-02-16 18:48:38.384393435 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPacket.h	2013-02-10 14:23:18.566514238 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2012 Team XBMC
+ *      Copyright (C) 2012-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxShoutcast.cpp xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxShoutcast.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxShoutcast.cpp	2013-02-16 18:48:38.384393435 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxShoutcast.cpp	2013-04-05 11:38:43.936814262 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -118,8 +118,6 @@
 
 DemuxPacket* CDVDDemuxShoutcast::Read()
 {
-  int iRead = 0;
-
   // XXX
   // if meta interval is greater than FileCurl's max read size (currently 64k)
   // it will simply fail becuse the meta-interval will get incorrect
@@ -152,7 +150,7 @@
     // we already have read m_iMetaStreamInterval bytes of streaming data
     // metadata follows
     BYTE l;
-    iRead = m_pInput->Read(&l, 1);
+    int iRead = m_pInput->Read(&l, 1);
     if (iRead > 0)
     {
       int iMetaLength = l * 16;
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxShoutcast.h xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxShoutcast.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxShoutcast.h	2013-02-16 18:48:38.384393435 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxShoutcast.h	2013-02-10 14:23:18.576514045 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp	2013-02-16 18:48:38.384393435 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp	2013-02-10 14:23:18.576514045 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.h xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.h	2013-02-16 18:48:38.384393435 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.h	2013-02-10 14:23:18.576514045 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxVobsub.cpp xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxVobsub.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxVobsub.cpp	2013-02-16 18:48:38.384393435 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxVobsub.cpp	2013-02-10 14:23:18.576514045 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxVobsub.h xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxVobsub.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxVobsub.h	2013-02-16 18:48:38.404393038 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxVobsub.h	2013-02-10 14:23:18.576514045 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp	2013-02-16 18:48:38.404393038 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp	2013-02-10 14:23:18.576514045 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.h xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.h	2013-02-16 18:48:38.404393038 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.h	2013-02-10 14:23:18.576514045 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDFileInfo.cpp xbmc/xbmc/cores/dvdplayer/DVDFileInfo.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDFileInfo.cpp	2013-02-16 18:48:38.404393038 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDFileInfo.cpp	2013-04-05 11:38:43.936814262 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -236,13 +236,13 @@
             BYTE *pOutBuf = new BYTE[nWidth * nHeight * 4];
             struct SwsContext *context = dllSwScale.sws_getContext(picture.iWidth, picture.iHeight,
                   PIX_FMT_YUV420P, nWidth, nHeight, PIX_FMT_BGRA, SWS_FAST_BILINEAR | SwScaleCPUFlags(), NULL, NULL, NULL);
-            uint8_t *src[] = { picture.data[0], picture.data[1], picture.data[2], 0 };
-            int     srcStride[] = { picture.iLineSize[0], picture.iLineSize[1], picture.iLineSize[2], 0 };
-            uint8_t *dst[] = { pOutBuf, 0, 0, 0 };
-            int     dstStride[] = { nWidth*4, 0, 0, 0 };
 
             if (context)
             {
+              uint8_t *src[] = { picture.data[0], picture.data[1], picture.data[2], 0 };
+              int     srcStride[] = { picture.iLineSize[0], picture.iLineSize[1], picture.iLineSize[2], 0 };
+              uint8_t *dst[] = { pOutBuf, 0, 0, 0 };
+              int     dstStride[] = { (int)nWidth*4, 0, 0, 0 };
               int orientation = DegreeToOrientation(hint.orientation);
               dllSwScale.sws_scale(context, src, srcStride, 0, picture.iHeight, dst, dstStride);
               dllSwScale.sws_freeContext(context);
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDFileInfo.h xbmc/xbmc/cores/dvdplayer/DVDFileInfo.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDFileInfo.h	2013-02-16 18:48:38.404393038 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDFileInfo.h	2013-02-10 14:23:18.586513851 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.cpp xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.cpp	2013-02-16 18:48:38.404393038 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.cpp	2013-02-10 14:23:18.586513851 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.h	2013-02-16 18:48:38.404393038 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.h	2013-02-10 14:23:18.586513851 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStream.cpp xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStream.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStream.cpp	2013-02-16 18:48:38.404393038 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStream.cpp	2013-02-10 14:23:18.586513851 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStream.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStream.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStream.h	2013-02-16 18:48:38.424392643 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStream.h	2013-04-01 11:36:51.968805855 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -25,6 +25,7 @@
 #include "filesystem/IFileTypes.h"
 
 #include "FileItem.h"
+#include "guilib/Geometry.h"
 
 enum DVDStreamType
 {
@@ -47,8 +48,6 @@
 #define DVDSTREAM_BLOCK_SIZE_FILE (2048 * 16)
 #define DVDSTREAM_BLOCK_SIZE_DVD  2048
 
-class CPoint;
-
 namespace PVR
 {
   class CPVRChannel;
@@ -119,7 +118,19 @@
     virtual bool OnMouseMove(const CPoint &point) = 0;
     virtual bool OnMouseClick(const CPoint &point) = 0;
     virtual bool IsInMenu() = 0;
+    virtual void SkipStill() = 0;
     virtual double GetTimeStampCorrection() = 0;
+    virtual bool GetState(std::string &xmlstate) = 0;
+    virtual bool SetState(const std::string &xmlstate) = 0;
+
+  };
+
+  class ISeekable
+  {
+    public:
+    virtual ~ISeekable() {};
+    virtual bool CanSeek()  = 0;
+    virtual bool CanPause() = 0;
   };
 
   enum ENextStream
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamBluray.cpp xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamBluray.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamBluray.cpp	2013-02-16 18:48:38.424392643 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamBluray.cpp	2013-04-05 11:38:43.946814081 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -172,11 +172,20 @@
   static_cast<CDVDInputStreamBluray*>(this_gen)->OverlayCallback(ov);
 }
 
+#ifdef HAVE_LIBBLURAY_BDJ
+void  bluray_overlay_argb_cb(void *this_gen, const struct bd_argb_overlay_s * const ov)
+{
+  static_cast<CDVDInputStreamBluray*>(this_gen)->OverlayCallbackARGB(ov);
+}
+#endif
+
 CDVDInputStreamBluray::CDVDInputStreamBluray(IDVDPlayer* player) :
   CDVDInputStream(DVDSTREAM_TYPE_BLURAY)
 {
   m_title = NULL;
-  m_clip  = 0;
+  m_clip  = (uint32_t)-1;
+  m_playlist = (uint32_t)-1;
+  m_menu  = false;
   m_bd    = NULL;
   m_dll = new DllLibbluray;
   if (!m_dll->Load())
@@ -186,7 +195,6 @@
   }
   m_content = "video/x-mpegts";
   m_player  = player;
-  m_title_playing = false;
   m_navmode = false;
   m_hold = HOLD_NONE;
   memset(&m_event, 0, sizeof(m_event));
@@ -386,6 +394,9 @@
     m_dll->bd_set_player_setting_str(m_bd, BLURAY_PLAYER_SETTING_MENU_LANG,    g_langInfo.GetDVDMenuLanguage().c_str());
     m_dll->bd_set_player_setting_str(m_bd, BLURAY_PLAYER_SETTING_COUNTRY_CODE, "us");
     m_dll->bd_register_overlay_proc (m_bd, this, bluray_overlay_cb);
+#ifdef HAVE_LIBBLURAY_BDJ
+    m_dll->bd_register_argb_overlay_proc (m_bd, this, bluray_overlay_argb_cb, NULL);
+#endif
 
     m_dll->bd_get_event(m_bd, NULL);
 
@@ -396,7 +407,6 @@
       return false;
     }
     m_hold = HOLD_DATA;
-    m_title_playing = false;
   }
   else
   {
@@ -432,136 +442,129 @@
   m_title = NULL;
 }
 
-int CDVDInputStreamBluray::Read(BYTE* buf, int buf_size)
-{
-  if(m_navmode)
-  {
-    int result = 0;
-    do {
-
-      if(m_hold == HOLD_HELD)
-        return 0;
-
-      if(m_hold == HOLD_SKIP)
-      {
-        /* m_event already holds data */
-        m_hold = HOLD_DATA;
-        result = 0;
-      }
-      else
-      {
-        result = m_dll->bd_read_ext (m_bd, buf, buf_size, &m_event);
-
-        if(m_hold == HOLD_NONE)
-        {
-          /* Check for holding events */
-          switch(m_event.event) {
-            case BD_EVENT_SEEK:
-            case BD_EVENT_TITLE:
-              if(m_title_playing)
-                m_player->OnDVDNavResult(NULL, 1);
-              m_hold = HOLD_HELD;
-              return result;
+void CDVDInputStreamBluray::ProcessEvent() {
 
-            case BD_EVENT_PLAYLIST:
-            case BD_EVENT_PLAYITEM:
-              m_hold = HOLD_HELD;
-              return result;
-            default:
-              break;
-          }
-        }
-        if(result > 0)
-          m_hold = HOLD_NONE;
-      }
       int pid = -1;
       switch (m_event.event) {
 
         case BD_EVENT_ERROR:
           CLog::Log(LOGERROR, "CDVDInputStreamBluray - BD_EVENT_ERROR");
-          return -1;
+    break;
 
         case BD_EVENT_ENCRYPTED:
           CLog::Log(LOGERROR, "CDVDInputStreamBluray - BD_EVENT_ENCRYPTED");
-          return -1;
+    break;
 
         /* playback control */
 
         case BD_EVENT_SEEK:
           CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_SEEK");
+    //m_player->OnDVDNavResult(NULL, 1);
+    //m_dll->bd_read_skip_still(m_bd);
+    //m_hold = HOLD_HELD;
           break;
 
         case BD_EVENT_STILL_TIME:
           CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_STILL_TIME %d", m_event.param);
-          return 0;
+    pid = m_event.param;
+    m_player->OnDVDNavResult((void*) &pid, 5);
+    m_hold = HOLD_STILL;
+    break;
 
         case BD_EVENT_STILL:
-          CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_STILL %d", m_event.param);
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_STILL %d",
+        m_event.param);
           break;
 
         /* playback position */
 
         case BD_EVENT_ANGLE:
-          CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_ANGLE %d", m_event.param);
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_ANGLE %d",
+        m_event.param);
+    m_angle = m_event.param;
+    if (m_title)
+      m_dll->bd_free_title_info(m_title);
+    m_title = m_dll->bd_get_playlist_info(m_bd, m_playlist, m_angle);
           break;
 
         case BD_EVENT_END_OF_TITLE:
-          CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_END_OF_TITLE %d", m_event.param);
-          m_title_playing = false;
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_END_OF_TITLE %d",
+        m_event.param);
+    /* when a title ends, playlist WILL eventually change */
+    if (m_title)
+      m_dll->bd_free_title_info(m_title);
+    m_title = NULL;
           break;
 
         case BD_EVENT_TITLE:
-          CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_TITLE %d", m_event.param);
-          if(m_title)
-            m_dll->bd_free_title_info(m_title);
-          m_title = m_dll->bd_get_title_info(m_bd, m_event.param, 0);
-          m_title_playing = true;
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_TITLE %d",
+        m_event.param);
           break;
 
         case BD_EVENT_PLAYLIST:
-          CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_PLAYLIST %d", m_event.param);
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_PLAYLIST %d",
+        m_event.param);
+    m_playlist = m_event.param;
           if(m_title)
             m_dll->bd_free_title_info(m_title);
-          m_title = m_dll->bd_get_playlist_info(m_bd, m_event.param, 0);
+    m_title = m_dll->bd_get_playlist_info(m_bd, m_playlist, m_angle);
           break;
 
         case BD_EVENT_PLAYITEM:
-          CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_PLAYITEM %d", m_event.param);
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_PLAYITEM %d",
+        m_event.param);
           m_clip = m_event.param;
           break;
 
         case BD_EVENT_CHAPTER:
-          CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_CHAPTER %d", m_event.param);
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_CHAPTER %d",
+        m_event.param);
           break;
 
         /* stream selection */
 
         case BD_EVENT_AUDIO_STREAM:
           pid = -1;
-          if(m_title
-          && m_title->clip_count > m_clip
-          && m_title->clips[m_clip].audio_stream_count > (uint8_t)(m_event.param - 1))
+    if (m_title && m_title->clip_count > m_clip
+        && m_title->clips[m_clip].audio_stream_count
+            > (uint8_t) (m_event.param - 1))
             pid = m_title->clips[m_clip].audio_streams[m_event.param-1].pid;
-          CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_AUDIO_STREAM %d %d", m_event.param, pid);
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_AUDIO_STREAM %d %d",
+        m_event.param, pid);
           m_player->OnDVDNavResult((void*)&pid, 2);
           break;
 
         case BD_EVENT_PG_TEXTST:
-          CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_PG_TEXTST %d", m_event.param);
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_PG_TEXTST %d",
+        m_event.param);
           pid = m_event.param;
           m_player->OnDVDNavResult((void*)&pid, 4);
           break;
 
         case BD_EVENT_PG_TEXTST_STREAM:
           pid = -1;
-          if(m_title
-          && m_title->clip_count > m_clip
-          && m_title->clips[m_clip].pg_stream_count > (uint8_t)(m_event.param - 1))
+    if (m_title && m_title->clip_count > m_clip
+        && m_title->clips[m_clip].pg_stream_count
+            > (uint8_t) (m_event.param - 1))
             pid = m_title->clips[m_clip].pg_streams[m_event.param-1].pid;
-          CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_PG_TEXTST_STREAM %d, %d", m_event.param, pid);
+    CLog::Log(LOGDEBUG,
+        "CDVDInputStreamBluray - BD_EVENT_PG_TEXTST_STREAM %d, %d",
+        m_event.param, pid);
           m_player->OnDVDNavResult((void*)&pid, 3);
           break;
 
+#ifdef HAVE_LIBBLURAY_BDJ
+  case BD_EVENT_MENU:
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_PG_TEXTST %d",
+        m_event.param);
+    m_menu = !!m_event.param;
+    break;
+
+  case BD_EVENT_IDLE:
+    Sleep(100);
+    break;
+#endif
+
         case BD_EVENT_IG_STREAM:
         case BD_EVENT_SECONDARY_AUDIO:
         case BD_EVENT_SECONDARY_AUDIO_STREAM:
@@ -573,10 +576,58 @@
           break;
 
         default:
-          CLog::Log(LOGWARNING, "CDVDInputStreamBluray - unhandled libbluray event %d [param %d]", m_event.event, m_event.param);
+    CLog::Log(LOGWARNING,
+        "CDVDInputStreamBluray - unhandled libbluray event %d [param %d]",
+        m_event.event, m_event.param);
           break;
       }
 
+  /* event has been consumed */
+  m_event.event = BD_EVENT_NONE;
+}
+
+int CDVDInputStreamBluray::Read(BYTE* buf, int buf_size)
+{
+  if(m_navmode)
+  {
+    int result = 0;
+    do {
+
+      if(m_hold == HOLD_HELD)
+        return 0;
+
+      result = m_dll->bd_read_ext (m_bd, buf, buf_size, &m_event);
+
+      /* Check for holding events */
+      switch(m_event.event) {
+        case BD_EVENT_SEEK:
+        case BD_EVENT_TITLE:
+        case BD_EVENT_ANGLE:
+        case BD_EVENT_PLAYLIST:
+        case BD_EVENT_PLAYITEM:
+          if(m_hold != HOLD_DATA)
+          {
+            m_hold = HOLD_HELD;
+            return result;
+          }
+          break;
+
+        case BD_EVENT_STILL_TIME:
+          if(m_hold == HOLD_STILL)
+            m_event.event = 0; /* Consume duplicate still event */
+          else
+            m_hold = HOLD_HELD;
+          return result;
+
+        default:
+          break;
+      }
+
+      if(result > 0)
+        m_hold = HOLD_NONE;
+
+      ProcessEvent();
+
     } while(result == 0);
 
     return result;
@@ -601,48 +652,33 @@
        | (uint32_t)clamp(b) << PIXEL_BSHIFT;
 }
 
-void CDVDInputStreamBluray::OverlayCallback(const BD_OVERLAY * const ov)
+void CDVDInputStreamBluray::OverlayClose()
 {
 #if(BD_OVERLAY_INTERFACE_VERSION >= 2)
-  if(ov == NULL || ov->cmd == BD_OVERLAY_CLOSE)
-  {
     for(unsigned i = 0; i < 2; ++i)
       m_planes[i].o.clear();
     CDVDOverlayGroup* group   = new CDVDOverlayGroup();
     group->bForced = true;
     m_player->OnDVDNavResult(group, 0);
-    return;
-  }
-
-  if (ov->plane > 1)
-  {
-    CLog::Log(LOGWARNING, "CDVDInputStreamBluray - Ignoring overlay with multiple planes");
-    return;
-  }
-
-  SPlane& plane(m_planes[ov->plane]);
-
-  if (ov->cmd == BD_OVERLAY_CLEAR)
-  {
-    plane.o.clear();
-    return;
+#endif
   }
 
-  if (ov->cmd == BD_OVERLAY_INIT)
+void CDVDInputStreamBluray::OverlayInit(SPlane& plane, int w, int h)
   {
+#if(BD_OVERLAY_INTERFACE_VERSION >= 2)
     plane.o.clear();
-    plane.w = ov->w;
-    plane.h = ov->h;
-    return;
+  plane.w = w;
+  plane.h = h;
+#endif
   }
 
-  if (ov->cmd == BD_OVERLAY_DRAW
-  ||  ov->cmd == BD_OVERLAY_WIPE)
+void CDVDInputStreamBluray::OverlayClear(SPlane& plane, int x, int y, int w, int h)
   {
-    CRect ovr(ov->x
-            , ov->y
-            , ov->x + ov->w
-            , ov->y + ov->h);
+#if(BD_OVERLAY_INTERFACE_VERSION >= 2)
+  CRect ovr(x
+          , y
+          , x + w
+          , y + h);
 
     /* fixup existing overlays */
     for(SOverlays::iterator it = plane.o.begin(); it != plane.o.end();)
@@ -657,7 +693,7 @@
       /* if no overlap we are done */
       if(rem.size() == 1 && !(rem[0] != old))
       {
-        it++;
+      ++it;
         continue;
       }
 
@@ -676,8 +712,61 @@
       it = plane.o.erase(it);
       plane.o.insert(it, add.begin(), add.end());
     }
+#endif
+}
+
+void CDVDInputStreamBluray::OverlayFlush(int64_t pts)
+{
+#if(BD_OVERLAY_INTERFACE_VERSION >= 2)
+  CDVDOverlayGroup* group   = new CDVDOverlayGroup();
+  group->bForced       = true;
+  group->iPTSStartTime = (double) pts;
+  group->iPTSStopTime  = 0;
+
+  for(unsigned i = 0; i < 2; ++i)
+  {
+    for(SOverlays::iterator it = m_planes[i].o.begin(); it != m_planes[i].o.end(); ++it)
+      group->m_overlays.push_back((*it)->Acquire());
+  }
+
+  m_player->OnDVDNavResult(group, 0);
+#endif
   }
 
+void CDVDInputStreamBluray::OverlayCallback(const BD_OVERLAY * const ov)
+{
+#if(BD_OVERLAY_INTERFACE_VERSION >= 2)
+  if(ov == NULL || ov->cmd == BD_OVERLAY_CLOSE)
+  {
+    OverlayClose();
+    return;
+  }
+
+  if (ov->plane > 1)
+  {
+    CLog::Log(LOGWARNING, "CDVDInputStreamBluray - Ignoring overlay with multiple planes");
+    return;
+  }
+
+  SPlane& plane(m_planes[ov->plane]);
+
+  if (ov->cmd == BD_OVERLAY_CLEAR)
+  {
+    plane.o.clear();
+    return;
+  }
+
+  if (ov->cmd == BD_OVERLAY_INIT)
+  {
+    OverlayInit(plane, ov->w, ov->h);
+    return;
+  }
+
+  if (ov->cmd == BD_OVERLAY_DRAW
+  ||  ov->cmd == BD_OVERLAY_WIPE)
+    OverlayClear(plane, ov->x, ov->y, ov->w, ov->h);
+
+
   /* uncompress and draw bitmap */
   if (ov->img && ov->cmd == BD_OVERLAY_DRAW)
   {
@@ -712,22 +801,64 @@
   }
 
   if(ov->cmd == BD_OVERLAY_FLUSH)
+    OverlayFlush(ov->pts);
+#endif
+}
+
+#ifdef HAVE_LIBBLURAY_BDJ
+void CDVDInputStreamBluray::OverlayCallbackARGB(const struct bd_argb_overlay_s * const ov)
   {
-    CDVDOverlayGroup* group   = new CDVDOverlayGroup();
-    group->bForced       = true;
-    group->iPTSStartTime = (double) ov->pts;
-    group->iPTSStopTime  = 0;
+  if(ov == NULL || ov->cmd == BD_ARGB_OVERLAY_CLOSE)
+  {
+    OverlayClose();
+    return;
+  }
 
-    for(unsigned i = 0; i < 2; ++i)
+  if (ov->plane > 1)
     {
-      for(SOverlays::iterator it = m_planes[i].o.begin(); it != m_planes[i].o.end(); ++it)
-        group->m_overlays.push_back((*it)->Acquire());
+    CLog::Log(LOGWARNING, "CDVDInputStreamBluray - Ignoring overlay with multiple planes");
+    return;
     }
 
-    m_player->OnDVDNavResult(group, 0);
+  SPlane& plane(m_planes[ov->plane]);
+
+  if (ov->cmd == BD_ARGB_OVERLAY_INIT)
+  {
+    OverlayInit(plane, ov->w, ov->h);
+    return;
   }
-#endif
+
+  if (ov->cmd == BD_ARGB_OVERLAY_DRAW)
+    OverlayClear(plane, ov->x, ov->y, ov->w, ov->h);
+
+  /* uncompress and draw bitmap */
+  if (ov->argb && ov->cmd == BD_ARGB_OVERLAY_DRAW)
+  {
+    SOverlay overlay(new CDVDOverlayImage(), std::ptr_fun(CDVDOverlay::Release));
+
+    overlay->palette_colors = 0;
+    overlay->palette        = NULL;
+
+    unsigned bytes = ov->stride * ov->h * 4;
+    uint8_t *img = (uint8_t*) malloc(bytes);
+    memcpy(img, ov->argb, bytes);
+
+    overlay->data     = img;
+    overlay->linesize = ov->stride * 4;
+    overlay->x        = ov->x;
+    overlay->y        = ov->y;
+    overlay->height   = ov->h;
+    overlay->width    = ov->w;
+    overlay->source_height = plane.h;
+    overlay->source_width  = plane.w;
+    plane.o.push_back(overlay);
+  }
+
+  if(ov->cmd == BD_ARGB_OVERLAY_FLUSH)
+    OverlayFlush(ov->pts);
 }
+#endif
+
 
 int CDVDInputStreamBluray::GetTotalTime()
 {
@@ -850,17 +981,18 @@
   if(!m_navmode)
     return NEXTSTREAM_NONE;
 
-  if(m_hold == HOLD_HELD)
-  {
-    m_hold = HOLD_SKIP;
-    return NEXTSTREAM_OPEN;
-  }
-  if(m_hold == HOLD_NONE)
-  {
-    m_hold = HOLD_DATA;
-    m_dll->bd_read_skip_still(m_bd);
-  }
+  /* process any current event */
+  ProcessEvent();
+
+  /* process all queued up events */
+  while(m_dll->bd_get_event(m_bd, &m_event))
+    ProcessEvent();
+
+  if(m_hold == HOLD_STILL)
   return NEXTSTREAM_RETRY;
+
+  m_hold = HOLD_DATA;
+  return NEXTSTREAM_OPEN;
 }
 
 void CDVDInputStreamBluray::UserInput(bd_vk_key_e vk)
@@ -892,9 +1024,21 @@
 {
   if(m_bd == NULL || !m_navmode)
     return false;
-  if(m_planes[BD_OVERLAY_IG].o.size() > 0)
+  if(m_menu || m_planes[BD_OVERLAY_IG].o.size() > 0)
     return true;
   return false;
 }
 
+void CDVDInputStreamBluray::SkipStill()
+{
+  if(m_bd == NULL || !m_navmode)
+    return;
+
+  if(m_hold == HOLD_STILL)
+  {
+    m_hold = HOLD_HELD;
+    m_dll->bd_read_skip_still(m_bd);
+  }
+}
+
 #endif
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamBluray.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamBluray.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamBluray.h	2013-02-16 18:48:38.424392643 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamBluray.h	2013-04-05 11:38:43.946814081 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -81,6 +81,10 @@
   virtual bool OnMouseMove(const CPoint &point)  { return false; }
   virtual bool OnMouseClick(const CPoint &point) { return false; }
   virtual double GetTimeStampCorrection()        { return 0.0; }
+  virtual void SkipStill();
+  virtual bool GetState(std::string &xmlstate)         { return false; }
+  virtual bool SetState(const std::string &xmlstate)   { return false; }
+
 
   void UserInput(bd_vk_key_e vk);
 
@@ -96,17 +100,31 @@
   void GetStreamInfo(int pid, char* language);
 
   void OverlayCallback(const BD_OVERLAY * const);
+#ifdef HAVE_LIBBLURAY_BDJ
+  void OverlayCallbackARGB(const struct bd_argb_overlay_s * const);
+#endif
 
   BLURAY_TITLE_INFO* GetTitleLongest();
   BLURAY_TITLE_INFO* GetTitleFile(const std::string& name);
 
+  void ProcessEvent();
+
 protected:
+  struct SPlane;
+
+  void OverlayFlush(int64_t pts);
+  void OverlayClose();
+  static void OverlayClear(SPlane& plane, int x, int y, int w, int h);
+  static void OverlayInit (SPlane& plane, int w, int h);
+
   IDVDPlayer*   m_player;
   DllLibbluray *m_dll;
   BLURAY* m_bd;
   BLURAY_TITLE_INFO* m_title;
-  bool               m_title_playing;
+  uint32_t           m_playlist;
   uint32_t           m_clip;
+  uint32_t           m_angle;
+  bool               m_menu;
   bool m_navmode;
 
   typedef boost::shared_ptr<CDVDOverlayImage> SOverlay;
@@ -128,8 +146,11 @@
   enum EHoldState {
     HOLD_NONE = 0,
     HOLD_HELD,
-    HOLD_SKIP,
     HOLD_DATA,
+    HOLD_STILL,
   } m_hold;
   BD_EVENT m_event;
+#ifdef HAVE_LIBBLURAY_BDJ
+  struct bd_argb_buffer_s m_argb;
+#endif
 };
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFFmpeg.cpp xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFFmpeg.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFFmpeg.cpp	2013-02-16 18:48:38.424392643 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFFmpeg.cpp	2013-04-01 11:36:51.978805669 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -43,6 +43,21 @@
   if (!CDVDInputStream::Open(strFile, content))
     return false;
 
+  m_can_pause = true;
+  m_can_seek  = true;
+
+  if(strnicmp(strFile, "udp://", 6) == 0
+  || strnicmp(strFile, "rtp://", 6) == 0)
+  {
+    m_can_pause = false;
+    m_can_seek  = false;
+  }
+
+  if(strnicmp(strFile, "tcp://", 6) == 0)
+  {
+    m_can_pause = true;
+    m_can_seek  = false;
+  }
   return true;
 }
 
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFFmpeg.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFFmpeg.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFFmpeg.h	2013-02-16 18:48:38.424392643 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFFmpeg.h	2013-04-01 11:36:51.978805669 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -22,7 +22,9 @@
 
 #include "DVDInputStream.h"
 
-class CDVDInputStreamFFmpeg : public CDVDInputStream
+class CDVDInputStreamFFmpeg
+  : public CDVDInputStream
+  , public CDVDInputStream::ISeekable
 {
 public:
   CDVDInputStreamFFmpeg();
@@ -35,5 +37,10 @@
   virtual bool IsEOF();
   virtual int64_t GetLength();
 
+  bool            CanSeek()  { return m_can_seek; }
+  bool            CanPause() { return m_can_pause; }
+
 protected:
+  bool m_can_pause;
+  bool m_can_seek;
 };
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFile.cpp xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFile.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFile.cpp	2013-04-05 17:12:13.777112929 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFile.cpp	2013-04-05 17:19:30.059106595 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFile.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFile.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFile.h	2013-02-16 18:48:38.424392643 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFile.h	2013-02-10 14:23:18.596513656 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHTSP.cpp xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHTSP.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHTSP.cpp	2013-02-16 18:48:38.424392643 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHTSP.cpp	2013-04-05 11:38:43.946814081 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -181,14 +181,14 @@
 
 bool CDVDInputStreamHTSP::GetChannels(SChannelV &channels, SChannelV::iterator &it)
 {
-  for(SChannels::iterator it2 = m_channels.begin(); it2 != m_channels.end(); it2++)
+  for(SChannels::iterator it2 = m_channels.begin(); it2 != m_channels.end(); ++it2)
   {
     if(m_tag == 0 || it2->second.MemberOf(m_tag))
       channels.push_back(it2->second);
   }
   sort(channels.begin(), channels.end());
 
-  for(it = channels.begin(); it != channels.end(); it++)
+  for(it = channels.begin(); it != channels.end(); ++it)
     if(it->id == m_channel)
       return true;
   return false;
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHTSP.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHTSP.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHTSP.h	2013-02-16 18:48:38.444392246 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHTSP.h	2013-02-10 14:23:18.596513656 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHttp.cpp xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHttp.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHttp.cpp	2013-02-16 18:48:38.444392246 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHttp.cpp	2013-02-10 14:23:18.596513656 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHttp.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHttp.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHttp.h	2013-02-16 18:48:38.444392246 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHttp.h	2013-02-10 14:23:18.606513461 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamMemory.cpp xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamMemory.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamMemory.cpp	2013-02-16 18:48:38.444392246 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamMemory.cpp	2013-02-10 14:23:18.606513461 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamMemory.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamMemory.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamMemory.h	2013-02-16 18:48:38.444392246 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamMemory.h	2013-02-10 14:23:18.606513461 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamNavigator.cpp xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamNavigator.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamNavigator.cpp	2013-02-16 18:48:38.444392246 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamNavigator.cpp	2013-04-05 11:38:43.946814081 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -27,6 +27,8 @@
 #include "utils/log.h"
 #include "guilib/Geometry.h"
 #include "utils/URIUtils.h"
+#include "utils/StringUtils.h"
+#include "guilib/LocalizeStrings.h"
 #if defined(TARGET_DARWIN)
 #include "osx/CocoaInterface.h"
 #endif
@@ -259,11 +261,10 @@
 
   int result;
   int len = 2048;
-  int iNavresult = NAVRESULT_NOP;
 
   // m_tempbuffer will be used for anything that isn't a normal data block
   uint8_t* buf = m_lastblock;
-  iNavresult = -1;
+  int iNavresult = -1;
 
   if(m_holdmode == HOLDMODE_HELD)
     return NAVRESULT_HOLD;
@@ -822,22 +823,36 @@
   return activeStream;
 }
 
-std::string CDVDInputStreamNavigator::GetSubtitleStreamLanguage(int iId)
+bool CDVDInputStreamNavigator::GetSubtitleStreamInfo(const int iId, DVDNavStreamInfo &info)
 {
-  if (!m_dvdnav) return NULL;
-
-  CStdString strLanguage;
+  if (!m_dvdnav) return false;
 
-  subp_attr_t subp_attributes;
   int streamId = ConvertSubtitleStreamId_XBMCToExternal(iId);
+  subp_attr_t subp_attributes;
+
   if( m_dll.dvdnav_get_stitle_info(m_dvdnav, streamId, &subp_attributes) == DVDNAV_STATUS_OK )
   {
+    SetSubtitleStreamName(info, subp_attributes);
+
+    char lang[3];
+    lang[2] = 0;
+    lang[1] = (subp_attributes.lang_code & 255);
+    lang[0] = (subp_attributes.lang_code >> 8) & 255;
+
+    CStdString temp;
+    g_LangCodeExpander.ConvertToThreeCharCode(temp, lang);
+    info.language = temp;
+
+    return true;
+  }
+  return false;
+}
 
+void CDVDInputStreamNavigator::SetSubtitleStreamName(DVDNavStreamInfo &info, const subp_attr_t subp_attributes)
+{
     if (subp_attributes.type == DVD_SUBPICTURE_TYPE_Language ||
         subp_attributes.type == DVD_SUBPICTURE_TYPE_NotSpecified)
     {
-      if (!g_LangCodeExpander.Lookup(strLanguage, subp_attributes.lang_code)) strLanguage = "Unknown";
-
       switch (subp_attributes.lang_extension)
       {
         case DVD_SUBPICTURE_LANG_EXT_NotSpecified:
@@ -849,25 +864,20 @@
         case DVD_SUBPICTURE_LANG_EXT_NormalCC:
         case DVD_SUBPICTURE_LANG_EXT_BigCC:
         case DVD_SUBPICTURE_LANG_EXT_ChildrensCC:
-          strLanguage+= " (CC)";
+      info.name += g_localizeStrings.Get(37011);
           break;
         case DVD_SUBPICTURE_LANG_EXT_Forced:
-          strLanguage+= " (Forced)";
+      info.name += g_localizeStrings.Get(37012);
           break;
         case DVD_SUBPICTURE_LANG_EXT_NormalDirectorsComments:
         case DVD_SUBPICTURE_LANG_EXT_BigDirectorsComments:
         case DVD_SUBPICTURE_LANG_EXT_ChildrensDirectorsComments:
-          strLanguage+= " (Directors Comments)";
+      info.name += g_localizeStrings.Get(37013);
+      break;
+    default:
           break;
       }
     }
-    else
-    {
-      strLanguage = "Unknown";
-    }
-  }
-
-  return strLanguage;
 }
 
 int CDVDInputStreamNavigator::GetSubTitleStreamCount()
@@ -925,37 +935,105 @@
   return activeStream;
 }
 
-std::string CDVDInputStreamNavigator::GetAudioStreamLanguage(int iId)
-{
-  if (!m_dvdnav) return NULL;
-
-  CStdString strLanguage;
-
-  audio_attr_t audio_attributes;
-  int streamId = ConvertAudioStreamId_XBMCToExternal(iId);
-  if( m_dll.dvdnav_get_audio_info(m_dvdnav, streamId, &audio_attributes) == DVDNAV_STATUS_OK )
+void CDVDInputStreamNavigator::SetAudioStreamName(DVDNavStreamInfo &info, const audio_attr_t audio_attributes)
   {
-    if (!g_LangCodeExpander.Lookup(strLanguage, audio_attributes.lang_code)) strLanguage = "Unknown";
-
-    switch( audio_attributes.lang_extension )
+  switch( audio_attributes.code_extension )
     {
       case DVD_AUDIO_LANG_EXT_VisuallyImpaired:
-        strLanguage+= " (Visually Impaired)";
+    info.name = g_localizeStrings.Get(37000);
         break;
       case DVD_AUDIO_LANG_EXT_DirectorsComments1:
-        strLanguage+= " (Directors Comments)";
+    info.name = g_localizeStrings.Get(37001);
         break;
       case DVD_AUDIO_LANG_EXT_DirectorsComments2:
-        strLanguage+= " (Directors Comments 2)";
+    info.name = g_localizeStrings.Get(37002);
         break;
       case DVD_AUDIO_LANG_EXT_NotSpecified:
       case DVD_AUDIO_LANG_EXT_NormalCaptions:
       default:
         break;
     }
+
+  switch(audio_attributes.audio_format)
+  {
+  case DVD_AUDIO_FORMAT_AC3:
+    info.name += " AC3";
+    break;
+  case DVD_AUDIO_FORMAT_UNKNOWN_1:
+    info.name += " UNKNOWN #1";
+    break;
+  case DVD_AUDIO_FORMAT_MPEG:
+    info.name += " MPEG AUDIO";
+    break;
+  case DVD_AUDIO_FORMAT_MPEG2_EXT:
+    info.name += " MP2 Ext.";
+    break;
+  case DVD_AUDIO_FORMAT_LPCM:
+    info.name += " LPCM";
+    break;
+  case DVD_AUDIO_FORMAT_UNKNOWN_5:
+    info.name += " UNKNOWN #5";
+    break;
+  case DVD_AUDIO_FORMAT_DTS:
+    info.name += " DTS";
+    break;
+  case DVD_AUDIO_FORMAT_SDDS:
+    info.name += " SDDS";
+    break;
+  default:
+    info.name += " Other";
+    break;
+  }
+
+  switch(audio_attributes.channels + 1)
+  {
+  case 1:
+    info.name += " Mono";
+    break;
+  case 2: 
+    info.name += " Stereo";
+    break;
+  case 6: 
+    info.name += " 5.1";
+    break;
+  case 7:
+    info.name += " 6.1";
+    break;
+  default:
+    char temp[32];
+    sprintf(temp, " %d-chs", audio_attributes.channels + 1);
+    info.name += temp;
+  }
+
+  StringUtils::TrimLeft(info.name);
+
   }
 
-  return strLanguage;
+bool CDVDInputStreamNavigator::GetAudioStreamInfo(const int iId, DVDNavStreamInfo &info)
+{
+  if (!m_dvdnav) return false;
+
+  int streamId = ConvertAudioStreamId_XBMCToExternal(iId);
+  audio_attr_t audio_attributes;
+
+  if( m_dll.dvdnav_get_audio_info(m_dvdnav, streamId, &audio_attributes) == DVDNAV_STATUS_OK )
+  {
+    SetAudioStreamName(info, audio_attributes);
+
+    char lang[3];
+    lang[2] = 0;
+    lang[1] = (audio_attributes.lang_code & 255);
+    lang[0] = (audio_attributes.lang_code >> 8) & 255;
+
+    CStdString temp;
+    g_LangCodeExpander.ConvertToThreeCharCode(temp, lang);
+    info.language = temp;
+
+    info.channels = audio_attributes.channels + 1;
+
+    return true;
+  }
+  return false;
 }
 
 int CDVDInputStreamNavigator::GetAudioStreamCount()
@@ -1144,7 +1222,7 @@
     return false;
 }
 
-bool CDVDInputStreamNavigator::GetNavigatorState(std::string &xmlstate)
+bool CDVDInputStreamNavigator::GetState(std::string &xmlstate)
 {
   if( !m_dvdnav )
     return false;
@@ -1165,7 +1243,7 @@
   return true;
 }
 
-bool CDVDInputStreamNavigator::SetNavigatorState(std::string &xmlstate)
+bool CDVDInputStreamNavigator::SetState(const std::string &xmlstate)
 {
   if( !m_dvdnav )
     return false;
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamNavigator.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamNavigator.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamNavigator.h	2013-02-16 18:48:38.464391849 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamNavigator.h	2013-04-05 11:38:43.956813901 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -24,6 +24,7 @@
 #include "../IDVDPlayer.h"
 #include "../DVDCodecs/Overlay/DVDOverlaySpu.h"
 #include <string>
+#include "guilib/Geometry.h"
 
 #include "DllDvdNav.h"
 
@@ -40,14 +41,26 @@
 class CDVDDemuxSPU;
 class CSPUInfo;
 class CDVDOverlayPicture;
-class CPoint;
 
 struct dvdnav_s;
 
+struct DVDNavStreamInfo
+{
+  std::string name;
+  std::string language;
+  int channels;
+
+  DVDNavStreamInfo() : channels(0) {}
+};
+
 class DVDNavResult
 {
 public:
-  DVDNavResult(){};
+  DVDNavResult() :
+      pData (NULL ),
+      type  (0    )
+  {
+  };
   DVDNavResult(void* p, int t) { pData = p; type = t; };
   void* pData;
   int type;
@@ -96,20 +109,20 @@
   bool IsInMenu() { return m_bInMenu; }
 
   int GetActiveSubtitleStream();
-  std::string GetSubtitleStreamLanguage(int iId);
   int GetSubTitleStreamCount();
+  bool GetSubtitleStreamInfo(const int iId, DVDNavStreamInfo &info);
 
   bool SetActiveSubtitleStream(int iId);
   void EnableSubtitleStream(bool bEnable);
   bool IsSubtitleStreamEnabled();
 
   int GetActiveAudioStream();
-  std::string GetAudioStreamLanguage(int iId);
   int GetAudioStreamCount();
   bool SetActiveAudioStream(int iId);
+  bool GetAudioStreamInfo(const int iId, DVDNavStreamInfo &info);
 
-  bool GetNavigatorState(std::string &xmlstate);
-  bool SetNavigatorState(std::string &xmlstate);
+  bool GetState(std::string &xmlstate);
+  bool SetState(const std::string &xmlstate);
 
   int GetChapter()      { return m_iPart; }      // the current part in the current title
   int GetChapterCount() { return m_iPartCount; } // the number of parts in the current title
@@ -145,6 +158,9 @@
   int ConvertSubtitleStreamId_XBMCToExternal(int id);
   int ConvertSubtitleStreamId_ExternalToXBMC(int id);
 
+  void SetAudioStreamName(DVDNavStreamInfo &info, const audio_attr_t audio_attributes);
+  void SetSubtitleStreamName(DVDNavStreamInfo &info, const subp_attr_t subp_attributes);
+
   DllDvdNav m_dll;
   bool m_bCheckButtons;
   bool m_bEOF;
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.cpp xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.cpp	2013-02-16 18:48:38.464391849 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.cpp	2013-04-05 11:38:43.956813901 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2012 Team XBMC
+ *      Copyright (C) 2012-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -387,7 +387,7 @@
   return false;
 }
 
-bool CDVDInputStreamPVRManager::SupportsChannelSwitch(void) const
+bool CDVDInputStreamPVRManager::SupportsChannelSwitch(void)
 {
   PVR_CLIENT client;
   return g_PVRClients->GetPlayingClient(client) &&
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.h	2013-02-16 18:48:38.464391849 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.h	2013-04-05 11:38:43.956813901 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2012 Team XBMC
+ *      Copyright (C) 2012-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -39,6 +39,7 @@
   : public CDVDInputStream
   , public CDVDInputStream::IChannel
   , public CDVDInputStream::IDisplayTime
+  , public CDVDInputStream::ISeekable
 {
 public:
   CDVDInputStreamPVRManager(IDVDPlayer* pPlayer);
@@ -88,7 +89,7 @@
   void ResetScanTimeout(unsigned int iTimeoutMs);
 protected:
   bool CloseAndOpen(const char* strFile);
-  bool SupportsChannelSwitch(void) const;
+  static bool SupportsChannelSwitch(void);
 
   IDVDPlayer*               m_pPlayer;
   CDVDInputStream*          m_pOtherStream;
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamRTMP.cpp xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamRTMP.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamRTMP.cpp	2013-02-16 18:48:38.464391849 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamRTMP.cpp	2013-02-10 14:23:18.616513267 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamRTMP.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamRTMP.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamRTMP.h	2013-02-16 18:48:38.464391849 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamRTMP.h	2013-02-10 14:23:18.616513267 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamStack.cpp xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamStack.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamStack.cpp	2013-02-16 18:48:38.474391651 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamStack.cpp	2013-04-05 11:38:43.956813901 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -88,7 +88,7 @@
     m_files.push_back(segment);
   }
 
-  if(m_files.size() == 0)
+  if(m_files.empty())
     return false;
 
   m_file = m_files[0].file;
@@ -147,7 +147,7 @@
     return -1;
 
   len = 0;
-  for(TSegVec::iterator it = m_files.begin(); it != m_files.end(); it++)
+  for(TSegVec::iterator it = m_files.begin(); it != m_files.end(); ++it)
   {
     if(len + it->length > pos)
     {
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamStack.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamStack.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamStack.h	2013-02-16 18:48:38.474391651 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamStack.h	2013-02-10 14:23:18.616513267 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamTV.cpp xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamTV.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamTV.cpp	2013-02-16 18:48:38.474391651 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamTV.cpp	2013-02-10 14:23:18.616513267 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamTV.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamTV.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamTV.h	2013-02-16 18:48:38.474391651 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamTV.h	2013-04-05 11:38:43.956813901 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -54,7 +54,7 @@
   int             GetTotalTime();
   int             GetTime();
 
-  bool            SeekTime(int iTimeInMsec);
+  static bool            SeekTime(int iTimeInMsec);
 
   bool            CanRecord();
   bool            IsRecording();
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDStateSerializer.cpp xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDStateSerializer.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDStateSerializer.cpp	2013-02-16 18:48:38.474391651 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDStateSerializer.cpp	2013-02-10 14:23:18.626513074 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDStateSerializer.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDStateSerializer.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DVDStateSerializer.h	2013-02-16 18:48:38.474391651 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DVDStateSerializer.h	2013-02-10 14:23:18.626513074 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DllDvdNav.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DllDvdNav.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DllDvdNav.h	2013-02-16 18:48:38.474391651 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DllDvdNav.h	2013-02-10 14:23:18.626513074 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DllLibRTMP.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DllLibRTMP.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/DllLibRTMP.h	2013-02-16 18:48:38.474391651 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/DllLibRTMP.h	2013-02-10 14:23:18.626513074 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/config.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/config.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/config.h	2013-02-16 18:48:38.504391056 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/config.h	2013-02-10 14:23:18.626513074 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/decoder.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/decoder.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/decoder.h	2013-02-16 18:48:38.504391056 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/decoder.h	2013-02-08 20:31:25.625872844 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000, 2001 Martin Norbck, Hkan Hjort
+ * Copyright (C) 2000, 2001 Martin Norbck, Hkan Hjort
  * 
  * This file is part of libdvdnav, a DVD navigation library. It is modified
  * from a file originally part of the Ogle DVD player.
@@ -14,16 +14,13 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
- *
- * $Id$
- *
+ * You should have received a copy of the GNU General Public License along
+ * with libdvdnav; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
-#ifndef DECODER_H_INCLUDED
-#define DECODER_H_INCLUDED
+#ifndef LIBDVDNAV_DECODER_H
+#define LIBDVDNAV_DECODER_H
 
 //#include <inttypes.h>
 //#include <sys/time.h>
@@ -115,4 +112,4 @@
 void vm_print_registers( registers_t *registers );
 #endif
 
-#endif /* DECODER_H_INCLUDED */
+#endif /* LIBDVDNAV_DECODER_H */
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/dvd_reader.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/dvd_reader.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/dvd_reader.h	2013-02-16 18:48:38.504391056 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/dvd_reader.h	2013-02-08 20:31:25.635872649 +0000
@@ -1,26 +1,28 @@
-#ifndef DVD_READER_H_INCLUDED
-#define DVD_READER_H_INCLUDED
-
 /*
  * Copyright (C) 2001, 2002 Billy Biggs <vektor@dumbterm.net>,
- *                          Hkan Hjort <d95hjort@dtek.chalmers.se>,
- *                          Bjrn Englund <d4bjorn@dtek.chalmers.se>
+ *                          Hkan Hjort <d95hjort@dtek.chalmers.se>,
+ *                          Bjrn Englund <d4bjorn@dtek.chalmers.se>
+ *
+ * This file is part of libdvdread.
  *
- * This program is free software; you can redistribute it and/or modify
+ * libdvdread is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or (at
- * your option) any later version.
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
  *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * libdvdread is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libdvdread; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
+#ifndef LIBDVDREAD_DVD_READER_H
+#define LIBDVDREAD_DVD_READER_H
+
 #ifdef _MSC_VER
 #include "config.h"
 
@@ -68,6 +70,15 @@
 typedef struct dvd_file_s dvd_file_t;
 
 /**
+ * Public type that is used to provide statistics on a handle.
+ */
+typedef struct {
+  off_t size;          /**< Total size of file in bytes */
+  int nr_parts;        /**< Number of file parts */
+  off_t parts_size[9]; /**< Size of each part in bytes */
+} dvd_stat_t;
+
+/**
  * Opens a block device of a DVD-ROM file, or an image file, or a directory
  * name for a mounted DVD or HD copy of a DVD.
  *
@@ -115,6 +126,33 @@
 } dvd_read_domain_t;
 
 /**
+ * Stats a file on the DVD given the title number and domain.
+ * The information about the file is stored in a dvd_stat_t
+ * which contains information about the size of the file and
+ * the number of parts in case of a multipart file and the respective
+ * sizes of the parts.
+ * A multipart file is for instance VTS_02_1.VOB, VTS_02_2.VOB, VTS_02_3.VOB
+ * The size of VTS_02_1.VOB will be stored in stat->parts_size[0],
+ * VTS_02_2.VOB in stat->parts_size[1], ...
+ * The total size (sum of all parts) is stored in stat->size and
+ * stat->nr_parts will hold the number of parts.
+ * Only DVD_READ_TITLE_VOBS (VTS_??_[1-9].VOB) can be multipart files.
+ *
+ * This function is only of use if you want to get the size of each file
+ * in the filesystem. These sizes are not needed to use any other
+ * functions in libdvdread.
+ *
+ * @param dvd  A dvd read handle.
+ * @param titlenum Which Video Title Set should be used, VIDEO_TS is 0.
+ * @param domain Which domain.
+ * @param stat Pointer to where the result is stored.
+ * @return If successful 0, otherwise -1.
+ *
+ * int DVDFileStat(dvd, titlenum, domain, stat);
+ */
+int DVDFileStat(dvd_reader_t *, int, dvd_read_domain_t, dvd_stat_t *);
+
+/**
  * Opens a file on the DVD given the title number and domain.
  *
  * If the title number is 0, the video manager information is opened
@@ -229,6 +267,8 @@
 int DVDUDFVolumeInfo( dvd_reader_t *, char *, unsigned int,
 		      unsigned char *, unsigned int );
 
+int DVDFileSeekForce( dvd_file_t *, int offset, int force_size);
+
 /**
  * Get the ISO9660 VolumeIdentifier and VolumeSetIdentifier
  *
@@ -268,6 +308,6 @@
 int DVDUDFCacheLevel( dvd_reader_t *, int );
 
 #ifdef __cplusplus
-}
+};
 #endif
-#endif /* DVD_READER_H_INCLUDED */
+#endif /* LIBDVDREAD_DVD_READER_H */
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/dvd_types.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/dvd_types.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/dvd_types.h	2013-02-16 18:48:38.504391056 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/dvd_types.h	2013-04-02 23:19:38.313455795 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000, 2001 Bjrn Englund, Hkan Hjort
+ * Copyright (C) 2000, 2001 Bjrn Englund, Hkan Hjort
  *
  * This file is part of libdvdnav, a DVD navigation library. It is a modified
  * file originally part of the Ogle DVD player project.
@@ -14,24 +14,20 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
- *
- * $Id$
- *
+ * You should have received a copy of the GNU General Public License along
+ * with libdvdnav; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
 /*
  * Various useful structs and enums for DVDs.
  */
 
-#ifndef DVD_H_INCLUDED
-#define DVD_H_INCLUDED
+#ifndef LIBDVDNAV_DVD_TYPES_H
+#define LIBDVDNAV_DVD_TYPES_H
 
 //#include <inttypes.h>
 
-
 /*
  * DVD Menu ID
  * (see dvdnav_menu_call())
@@ -168,14 +164,13 @@
 /* The audio format */
 typedef enum {
   DVD_AUDIO_FORMAT_AC3       = 0,
-  DVD_AUDIO_FORMAT_MPEG1     = 1,
-  DVD_AUDIO_FORMAT_MPEG1_DRC = 2,
-  DVD_AUDIO_FORMAT_MPEG2     = 3,
-  DVD_AUDIO_FORMAT_MPEG2_DRC = 4,
-  DVD_AUDIO_FORMAT_LPCM      = 5,
+  DVD_AUDIO_FORMAT_UNKNOWN_1  = 1,
+  DVD_AUDIO_FORMAT_MPEG       = 2,
+  DVD_AUDIO_FORMAT_MPEG2_EXT  = 3,
+  DVD_AUDIO_FORMAT_LPCM       = 4,
+  DVD_AUDIO_FORMAT_UNKNOWN_5  = 5,
   DVD_AUDIO_FORMAT_DTS       = 6,
-  DVD_AUDIO_FORMAT_SDDS      = 7,
-  DVD_AUDIO_FORMAT_Other     = 8
+  DVD_AUDIO_FORMAT_SDDS       = 7
 } DVDAudioFormat_t;
 
 /* Audio language extension */
@@ -199,7 +194,7 @@
   DVD_SUBPICTURE_LANG_EXT_Forced  = 9,
   DVD_SUBPICTURE_LANG_EXT_NormalDirectorsComments  = 13,
   DVD_SUBPICTURE_LANG_EXT_BigDirectorsComments  = 14,
-  DVD_SUBPICTURE_LANG_EXT_ChildrensDirectorsComments  = 15
+  DVD_SUBPICTURE_LANG_EXT_ChildrensDirectorsComments  = 15,
 } DVDSubpictureLangExt_t;  
 
 /* Karaoke Downmix mode */
@@ -264,6 +259,7 @@
 } DVDSubpictureAttributes_t;
 
 typedef int DVDVideoCompression_t;
+
 /* Video attributes */
 typedef struct {
   DVDBool_t PanscanPermitted;
@@ -278,7 +274,6 @@
   int more_to_come;
 } DVDVideoAttributes_t;
 
-
 #endif
 
-#endif /* DVD_H_INCLUDED */
+#endif /* LIBDVDNAV_DVD_TYPES_H */
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/dvdnav.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/dvdnav.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/dvdnav.h	2013-02-16 18:48:38.504391056 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/dvdnav.h	2013-02-10 14:23:18.626513074 +0000
@@ -13,12 +13,9 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
- *
- * $Id$
- *
+ * You should have received a copy of the GNU General Public License along
+ * with libdvdnav; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
 /*
@@ -26,24 +23,20 @@
  * to access dvdnav functionality.
  */
 
-#ifndef DVDNAV_H_INCLUDED
-#define DVDNAV_H_INCLUDED
+#ifndef LIBDVDNAV_DVDNAV_H
+#define LIBDVDNAV_DVDNAV_H
+
+#define MP_DVDNAV 1
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#ifdef DVDNAV_COMPILE
-#  include "dvdnav_events.h"
 #  include "dvd_types.h"
 #  include "dvd_reader.h"
+#  include "nav_types.h"
 #  include "ifo_types.h" /* For vm_cmd_t */
-#else
-#  include <dvdnav/dvdnav_events.h>
-#  include <dvdnav/dvd_types.h>
-#  include <dvdnav/dvd_reader.h>
-#  include <dvdnav/ifo_types.h> /* For vm_cmd_t */
-#endif
+#  include "dvdnav_events.h"
 
 
 
@@ -182,7 +175,7 @@
  *********************************************************************/
 
 /*
- * These functions are used to poll the playback enginge and actually get data 
+ * These functions are used to poll the playback engine and actually get data
  * off the DVD.
  */
 
@@ -206,7 +199,7 @@
 /*
  * This basically does the same as dvdnav_get_next_block. The only difference is
  * that it avoids a memcopy, when the requested block was found in the cache.
- * I such a case (cache hit) this function will return a different pointer than
+ * In such a case (cache hit) this function will return a different pointer than
  * the one handed in, pointing directly into the relevant block in the cache.
  * Those pointers must _never_ be freed but instead returned to the library via
  * dvdnav_free_cache_block().
@@ -281,6 +274,20 @@
 dvdnav_status_t dvdnav_part_play(dvdnav_t *self, int32_t title, int32_t part);
 
 /*
+ * Plays the specified title, starting from the specified program
+ */
+dvdnav_status_t dvdnav_program_play(dvdnav_t *self, int32_t title, int32_t pgcn, int32_t pgn);
+
+/*
+ * Stores in *times an array (that the application *must* free) of
+ * dvdtimes corresponding to the chapter times for the chosen title.
+ * *duration will have the duration of the title
+ * The number of entries in *times is the result of the function.
+ * On error *times is NULL and the output is 0
+ */
+uint32_t dvdnav_describe_title_chapters(dvdnav_t *self, int32_t title, uint64_t **times, uint64_t *duration);
+
+/*
  * Play the specified amount of parts of the specified title of
  * the DVD then STOP.
  *
@@ -306,13 +313,20 @@
 
 /*
  * Return the title number and part currently being played.
- * A title of 0 indicates, we are in a menu. In this case, part
+ * A title of 0 indicates we are in a menu. In this case, part
  * is set to the current menu's ID.
  */
 dvdnav_status_t dvdnav_current_title_info(dvdnav_t *self, int32_t *title,
 					  int32_t *part);
 
 /*
+ * Return the title number, pgcn and pgn currently being played.
+ * A title of 0 indicates, we are in a menu.
+ */
+dvdnav_status_t dvdnav_current_title_program(dvdnav_t *self, int32_t *title,
+					  int32_t *pgcn, int32_t *pgn);
+
+/*
  * Return the current position (in blocks) within the current
  * title and the length (in blocks) of said title.
  * 
@@ -341,7 +355,7 @@
  * VOBU boundary before the given sector. The sector number is not
  * meant to be an absolute physical DVD sector, but a relative sector
  * in the current program. This function cannot leave the current
- * program and will fail, if asked to do so.
+ * program and will fail if asked to do so.
  *
  * If program chain based positioning is enabled
  * (see dvdnav_set_PGC_positioning_flag()), this will seek to the relative
@@ -354,6 +368,12 @@
 				     uint64_t offset, int32_t origin);
 
 /*
+ returns the current stream time in PTS ticks as reported by the IFO structures
+ divide it by 90000 to get the current play time in seconds
+ */
+int64_t dvdnav_get_current_time(dvdnav_t *self);
+
+/*
  * Stop playing the current position and start playback of the title
  * from the specified timecode.
  *
@@ -364,7 +384,7 @@
 
 /*
  * Stop playing current position and play the "GoUp"-program chain.
- * (which generally leads to the title menu or a higer-level menu).
+ * (which generally leads to the title menu or a higher-level menu).
  */
 dvdnav_status_t dvdnav_go_up(dvdnav_t *self);
 
@@ -404,12 +424,12 @@
 
 /*
  * Most functions related to highlights take a NAV PCI packet as a parameter.
- * While you can get the such a packet from libdvdnav, for players with internal
- * FIFOs, this will result in errors, because due to the FIFO length, libdvdnav will
- * be ahead in the stream compared to what the user is seeing on screen.
- * Therefore, player applications who have a NAV packet available, which is
- * better in sync with the actual playback should always pass this one to these
- * functions.
+ * While you can get such a packet from libdvdnav, this will result in
+ * errors for players with internal FIFOs because due to the FIFO length,
+ * libdvdnav will be ahead in the stream compared to what the user is
+ * seeing on screen.  Therefore, player applications who have a NAV
+ * packet available, which is better in sync with the actual playback,
+ * should always pass this one to these functions.
  */
 
 /*
@@ -466,7 +486,7 @@
 dvdnav_status_t dvdnav_button_select_and_activate(dvdnav_t *self, pci_t *pci, int32_t button);
 
 /*
- * Activate (press) a button and execute specified command.
+ * Activate ("press") a button and execute specified command.
  */
 dvdnav_status_t dvdnav_button_activate_cmd(dvdnav_t *self, int32_t button, vm_cmd_t *cmd);
 
@@ -516,7 +536,7 @@
 /*
  * Return a string describing the title of the DVD.
  * This is an ID string encoded on the disc by the author. In many cases
- * this is a descriptive string such as `THE_MATRIX' but sometimes is sigularly
+ * this is a descriptive string such as `THE_MATRIX' but sometimes is singularly
  * uninformative such as `PDVD-011421'. Some DVD authors even forget to set this,
  * so you may also read the default of the authoring software they used, like
  * `DVDVolume'.
@@ -524,6 +544,13 @@
 dvdnav_status_t dvdnav_get_title_string(dvdnav_t *self, const char **title_str);
 
 /*
+ * Returns a string containing the serial number of the DVD.
+ * This has a max of 15 characters and should be more unique than the
+ * title string.
+ */
+dvdnav_status_t dvdnav_get_serial_string(dvdnav_t *self, const char **serial_str);
+
+/*
  * Get video aspect code.
  * The aspect code does only change on VTS boundaries.
  * See the DVDNAV_VTS_CHANGE event.
@@ -533,6 +560,11 @@
 uint8_t dvdnav_get_video_aspect(dvdnav_t *self);
 
 /*
+ * Get video resolution.
+ */
+int dvdnav_get_video_resolution(dvdnav_t *self, uint32_t *width, uint32_t *height);
+
+/*
  * Get video scaling permissions.
  * The scaling permission does only change on VTS boundaries.
  * See the DVDNAV_VTS_CHANGE event.
@@ -548,6 +580,18 @@
 uint16_t dvdnav_audio_stream_to_lang(dvdnav_t *self, uint8_t stream);
 
 /*
+ * Returns the format of *logical* audio stream 'stream'
+ * (returns 0xffff if no such stream).
+ */
+uint16_t dvdnav_audio_stream_format(dvdnav_t *self, uint8_t stream);
+
+/*
+ * Returns number of channels in *logical* audio stream 'stream'
+ * (returns 0xffff if no such stream).
+ */
+uint16_t dvdnav_audio_stream_channels(dvdnav_t *self, uint8_t stream);
+
+/*
  * Converts a *logical* subpicture stream id into country code 
  * (returns 0xffff if no such stream).
  */
@@ -558,11 +602,23 @@
  */
 int8_t dvdnav_get_audio_logical_stream(dvdnav_t *self, uint8_t audio_num);
 
+#define HAVE_GET_AUDIO_ATTR
+/*
+ * Get audio attr
+ */
+dvdnav_status_t dvdnav_get_audio_attr(dvdnav_t *self, uint8_t audio_mum, audio_attr_t *audio_attr);
+
 /*
  * Converts a *physical* (MPEG) subpicture stream id into a logical stream number.
  */
 int8_t dvdnav_get_spu_logical_stream(dvdnav_t *self, uint8_t subp_num);
 
+#define HAVE_GET_SPU_ATTR
+/*
+ * Get spu attr
+ */
+dvdnav_status_t dvdnav_get_spu_attr(dvdnav_t *self, uint8_t audio_mum, subp_attr_t *subp_attr);
+
 /*
  * Get active audio stream.
  */
@@ -573,6 +629,13 @@
  */
 int8_t dvdnav_get_active_spu_stream(dvdnav_t *self);
 
+/*
+ * Get the set of user operations that are currently prohibited.
+ * There are potentially new restrictions right after
+ * DVDNAV_CHANNEL_HOP and DVDNAV_NAV_PACKET.
+ */
+user_ops_t dvdnav_get_restrictions(dvdnav_t *self);
+
 
 /*********************************************************************
  * multiple angles                                                   *
@@ -592,7 +655,7 @@
  */
 
 /*
- * Sets the current angle. If you try to follow a non existant angle
+ * Sets the current angle. If you try to follow a non existent angle
  * the call fails.
  */
 dvdnav_status_t dvdnav_angle_change(dvdnav_t *self, int32_t angle);
@@ -677,4 +740,4 @@
 }
 #endif
 
-#endif /* DVDNAV_H_INCLUDED */
+#endif /* LIBDVDNAV_DVDNAV_H */
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/dvdnav_events.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/dvdnav_events.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/dvdnav_events.h	2013-02-16 18:48:38.504391056 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/dvdnav_events.h	2013-02-08 20:31:25.635872649 +0000
@@ -13,26 +13,22 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
- *
- * $Id$
- *
+ * You should have received a copy of the GNU General Public License along
+ * with libdvdnav; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
 /*
  * This header defines events and event types 
  */
 
-#ifndef DVDNAV_EVENTS_H_INCLUDED
-#define DVDNAV_EVENTS_H_INCLUDED
+#ifndef LIBDVDNAV_DVDNAV_EVENTS_H
+#define LIBDVDNAV_DVDNAV_EVENTS_H
 
 #include "ifo_types.h"
 #include "dvd_reader.h"
 #include "nav_types.h"
 
-
 /*
  * DVDNAV_BLOCK_OK
  *
@@ -241,4 +237,4 @@
 #define DVDNAV_WAIT			13
 
 
-#endif /* DVDNAV_EVENTS_H_INCLUDED */
+#endif /* LIBDVDNAV_DVDNAV_EVENTS_H */
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/dvdnav_internal.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/dvdnav_internal.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/dvdnav_internal.h	2013-02-16 18:48:38.504391056 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/dvdnav_internal.h	2013-02-08 20:31:25.635872649 +0000
@@ -13,16 +13,13 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
- *
- * $Id$
- *
+ * You should have received a copy of the GNU General Public License along
+ * with libdvdnav; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
-#ifndef DVDNAV_INTERNAL_H_INCLUDED
-#define DVDNAV_INTERNAL_H_INCLUDED
+#ifndef LIBDVDNAV_DVDNAV_INTERNAL_H
+#define LIBDVDNAV_DVDNAV_INTERNAL_H
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -38,14 +35,16 @@
 
 /* pthread_mutex_* wrapper for win32 */
 #ifndef _LINUX
+#include <windows.h>
 #include <process.h>
 typedef CRITICAL_SECTION pthread_mutex_t;
 #define pthread_mutex_init(a, b) InitializeCriticalSection(a)
 #define pthread_mutex_lock(a)    EnterCriticalSection(a)
 #define pthread_mutex_unlock(a)  LeaveCriticalSection(a)
-#define pthread_mutex_destroy(a)
-#endif
+#define pthread_mutex_destroy(a) DeleteCriticalSection(a)
+#endif // !_LINUX
 
+#ifndef HAVE_GETTIMEOFDAY
 /* replacement gettimeofday implementation */
 #include <sys/timeb.h>
 static inline int _private_gettimeofday( struct timeval *tv, void *tz )
@@ -57,10 +56,12 @@
   return 0;
 }
 #define gettimeofday(TV, TZ) _private_gettimeofday((TV), (TZ))
+#endif
+
 #ifndef _LINUX
 #include <io.h> /* read() */
-#endif
 #define lseek64 _lseeki64
+#endif // !_LINUX
 
 #else
 
@@ -77,7 +78,7 @@
 #include "vmcmd.h"
 
 /* where should libdvdnav write its messages (stdout/stderr) */
-#define MSG_OUT stdout
+#define MSG_OUT stderr
 
 /* Maximum length of an error string */
 #define MAX_ERR_LEN 255
@@ -174,6 +175,7 @@
   int started;                    /* vm_start has been called? */
   int use_read_ahead;             /* 1 - use read-ahead cache, 0 - don't */
   int pgc_based;                  /* positioning works PGC based instead of PG based */
+  int cur_cell_time;              /* time expired since the beginning of the current cell, read from the dsi */
   
   /* VM */
   vm_t *vm;
@@ -186,6 +188,23 @@
   char err_str[MAX_ERR_LEN];
 };
 
+/** HELPER FUNCTIONS **/
+
+/* converts a dvd_time_t to PTS ticks */
+int64_t dvdnav_convert_time(dvd_time_t *time);
+
+/* XBMC added functions */
+/*
+ * Get current playback state
+ */
+dvdnav_status_t dvdnav_get_state(dvdnav_t *self, dvd_state_t *save_state);
+
+/*
+ * Resume playback state
+ */
+dvdnav_status_t dvdnav_set_state(dvdnav_t *self, dvd_state_t *save_state);
+/* end XBMC */
+
 /** USEFUL MACROS **/
 
 #ifdef __GNUC__
@@ -203,4 +222,4 @@
 #define printerr(str) \
 	do { if (this) strncpy(this->err_str, str, MAX_ERR_LEN - 1); } while (0)
 
-#endif /* DVDNAV_INTERNAL_H_INCLUDED */
+#endif /* LIBDVDNAV_DVDNAV_INTERNAL_H */
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/ifo_types.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/ifo_types.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/ifo_types.h	2013-02-16 18:48:38.524390659 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/ifo_types.h	2013-02-08 20:31:25.635872649 +0000
@@ -1,25 +1,27 @@
-#ifndef IFO_TYPES_H_INCLUDED
-#define IFO_TYPES_H_INCLUDED
-
 /*
- * Copyright (C) 2000, 2001 Bjrn Englund <d4bjorn@dtek.chalmers.se>,
- *                          Hkan Hjort <d95hjort@dtek.chalmers.se>
+ * Copyright (C) 2000, 2001 Bjrn Englund <d4bjorn@dtek.chalmers.se>,
+ *                          Hkan Hjort <d95hjort@dtek.chalmers.se>
+ *
+ * This file is part of libdvdread.
  *
- * This program is free software; you can redistribute it and/or modify
+ * libdvdread is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * This program is distributed in the hope that it will be useful,
+ * libdvdread is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * You should have received a copy of the GNU General Public License along
+ * with libdvdread; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
+#ifndef LIBDVDREAD_IFO_TYPES_H
+#define LIBDVDREAD_IFO_TYPES_H
+
 //#include <inttypes.h>
 #include "dvd_reader.h"
 
@@ -68,14 +70,13 @@
 typedef struct {
   uint8_t bytes[8];
 } ATTRIBUTE_PACKED vm_cmd_t;
-#define COMMAND_DATA_SIZE 8
+#define COMMAND_DATA_SIZE 8U
 
 
 /**
  * Video Attributes.
  */
 typedef struct {
-#ifdef WORDS_BIGENDIAN
   unsigned char mpeg_version         : 2;
   unsigned char video_format         : 2;
   unsigned char display_aspect_ratio : 2;
@@ -89,28 +90,12 @@
   unsigned char picture_size         : 2;
   unsigned char letterboxed          : 1;
   unsigned char film_mode            : 1;
-#else
-  unsigned char permitted_df         : 2;
-  unsigned char display_aspect_ratio : 2;
-  unsigned char video_format         : 2;
-  unsigned char mpeg_version         : 2;
-  
-  unsigned char film_mode            : 1;
-  unsigned char letterboxed          : 1;
-  unsigned char picture_size         : 2;
-  
-  unsigned char bit_rate             : 1;
-  unsigned char unknown1             : 1;
-  unsigned char line21_cc_2          : 1;
-  unsigned char line21_cc_1          : 1;
-#endif
 } ATTRIBUTE_PACKED video_attr_t;
 
 /**
  * Audio Attributes.
  */
 typedef struct {
-#ifdef WORDS_BIGENDIAN
   unsigned char audio_format           : 3;
   unsigned char multichannel_extension : 1;
   unsigned char lang_type              : 2;
@@ -120,49 +105,24 @@
   unsigned char sample_frequency       : 2;
   unsigned char unknown1               : 1;
   unsigned char channels               : 3;
-#else
-  unsigned char application_mode       : 2;
-  unsigned char lang_type              : 2;
-  unsigned char multichannel_extension : 1;
-  unsigned char audio_format           : 3;
-  
-  unsigned char channels               : 3;
-  unsigned char unknown1               : 1;
-  unsigned char sample_frequency       : 2;
-  unsigned char quantization           : 2;
-#endif
   uint16_t lang_code;
   uint8_t  lang_extension;
   uint8_t  code_extension;
   uint8_t unknown3;
   union {
     struct ATTRIBUTE_PACKED {
-#ifdef WORDS_BIGENDIAN
       unsigned char unknown4           : 1;
       unsigned char channel_assignment : 3;
       unsigned char version            : 2;
       unsigned char mc_intro           : 1; /* probably 0: true, 1:false */
       unsigned char mode               : 1; /* Karaoke mode 0: solo 1: duet */
-#else
-      unsigned char mode               : 1;
-      unsigned char mc_intro           : 1;
-      unsigned char version            : 2;
-      unsigned char channel_assignment : 3;
-      unsigned char unknown4           : 1;
-#endif
     } karaoke;
     struct ATTRIBUTE_PACKED {
-#ifdef WORDS_BIGENDIAN
       unsigned char unknown5           : 4;
       unsigned char dolby_encoded      : 1; /* suitable for surround decoding */
       unsigned char unknown6           : 3;
-#else
-      unsigned char unknown6           : 3;
-      unsigned char dolby_encoded      : 1;
-      unsigned char unknown5           : 4;
-#endif
     } surround;
-  } app_info;
+  } ATTRIBUTE_PACKED app_info;
 } ATTRIBUTE_PACKED audio_attr_t;
 
 
@@ -170,7 +130,6 @@
  * MultiChannel Extension
  */
 typedef struct {
-#ifdef WORDS_BIGENDIAN
   unsigned int zero1      : 7;
   unsigned int ach0_gme   : 1;
 
@@ -194,31 +153,6 @@
   unsigned int ach4_gv2e  : 1;
   unsigned int ach4_gmBe  : 1;
   unsigned int ach4_seBe  : 1;
-#else
-  unsigned char ach0_gme   : 1;
-  unsigned char zero1      : 7;
-
-  unsigned char ach1_gme   : 1;
-  unsigned char zero2      : 7;
-
-  unsigned char ach2_gm2e  : 1;
-  unsigned char ach2_gm1e  : 1;
-  unsigned char ach2_gv2e  : 1;
-  unsigned char ach2_gv1e  : 1;
-  unsigned char zero3      : 4;
-
-  unsigned char ach3_se2e  : 1;
-  unsigned char ach3_gmAe  : 1;
-  unsigned char ach3_gv2e  : 1;
-  unsigned char ach3_gv1e  : 1;
-  unsigned char zero4      : 4;
-
-  unsigned char ach4_seBe  : 1;
-  unsigned char ach4_gmBe  : 1;
-  unsigned char ach4_gv2e  : 1;
-  unsigned char ach4_gv1e  : 1;
-  unsigned char zero5      : 4;
-#endif
   uint8_t zero6[19];
 } ATTRIBUTE_PACKED multichannel_ext_t;
 
@@ -237,15 +171,9 @@
    * language: indicates language if type == 1
    * lang extension: if type == 1 contains the lang extension
    */
-#ifdef WORDS_BIGENDIAN
   unsigned char code_mode : 3;
   unsigned char zero1     : 3;
   unsigned char type      : 2;
-#else
-  unsigned char type      : 2;
-  unsigned char zero1     : 3;
-  unsigned char code_mode : 3;
-#endif
   uint8_t  zero2;
   uint16_t lang_code;
   uint8_t  lang_extension;
@@ -266,7 +194,7 @@
   vm_cmd_t *post_cmds;
   vm_cmd_t *cell_cmds;
 } ATTRIBUTE_PACKED pgc_command_tbl_t;
-#define PGC_COMMAND_TBL_SIZE 8
+#define PGC_COMMAND_TBL_SIZE 8U
 
 /**
  * PGC Program Map
@@ -277,7 +205,6 @@
  * Cell Playback Information.
  */
 typedef struct {
-#ifdef WORDS_BIGENDIAN
   unsigned int block_mode       : 2;
   unsigned int block_type       : 2;
   unsigned int seamless_play    : 1;
@@ -288,18 +215,6 @@
   unsigned int playback_mode    : 1;  /**< When set, enter StillMode after each VOBU */
   unsigned int restricted       : 1;  /**< ?? drop out of fastforward? */
   unsigned int unknown2         : 6;
-#else
-  unsigned char seamless_angle   : 1;
-  unsigned char stc_discontinuity: 1;
-  unsigned char interleaved      : 1;
-  unsigned char seamless_play    : 1;
-  unsigned char block_type       : 2;
-  unsigned char block_mode       : 2;
-  
-  unsigned char unknown2         : 6;
-  unsigned char restricted       : 1;
-  unsigned char playback_mode    : 1;
-#endif
   uint8_t still_time;
   uint8_t cell_cmd_nr;
   dvd_time_t playback_time;
@@ -330,7 +245,6 @@
  * User Operations.
  */
 typedef struct {
-#ifdef WORDS_BIGENDIAN
   unsigned int zero                           : 7; /* 25-31 */
   unsigned int video_pres_mode_change         : 1; /* 24 */
   
@@ -360,37 +274,6 @@
   unsigned int title_play                     : 1;
   unsigned int chapter_search_or_play         : 1;
   unsigned int title_or_time_play             : 1; /* 0 */
-#else
-  unsigned int video_pres_mode_change         : 1; /* 24 */
-  unsigned int zero                           : 7; /* 25-31 */
-  
-  unsigned int resume                         : 1; /* 16 */
-  unsigned int button_select_or_activate      : 1;
-  unsigned int still_off                      : 1;
-  unsigned int pause_on                       : 1;
-  unsigned int audio_stream_change            : 1;
-  unsigned int subpic_stream_change           : 1;
-  unsigned int angle_change                   : 1;
-  unsigned int karaoke_audio_pres_mode_change : 1; /* 23 */
-  
-  unsigned int forward_scan                   : 1; /* 8 */
-  unsigned int backward_scan                  : 1;
-  unsigned int title_menu_call                : 1;
-  unsigned int root_menu_call                 : 1;
-  unsigned int subpic_menu_call               : 1;
-  unsigned int audio_menu_call                : 1;
-  unsigned int angle_menu_call                : 1;
-  unsigned int chapter_menu_call              : 1; /* 15 */
-  
-  unsigned int title_or_time_play             : 1; /* 0 */
-  unsigned int chapter_search_or_play         : 1;
-  unsigned int title_play                     : 1;
-  unsigned int stop                           : 1;
-  unsigned int go_up                          : 1;
-  unsigned int time_or_chapter_search         : 1;
-  unsigned int prev_or_top_pg_search          : 1;
-  unsigned int next_pg_search                 : 1; /* 7 */
-#endif
 } ATTRIBUTE_PACKED user_ops_t;
 
 /**
@@ -419,27 +302,21 @@
   cell_playback_t *cell_playback;
   cell_position_t *cell_position;
 } ATTRIBUTE_PACKED pgc_t;
-#define PGC_SIZE 236
+#define PGC_SIZE 236U
 
 /**
  * Program Chain Information Search Pointer.
  */
 typedef struct {
   uint8_t  entry_id;
-#ifdef WORDS_BIGENDIAN
   unsigned int block_mode : 2;
   unsigned int block_type : 2;
   unsigned int unknown1   : 4;
-#else
-  unsigned char unknown1   : 4;
-  unsigned char block_type : 2;
-  unsigned char block_mode : 2;
-#endif  
   uint16_t ptl_id_mask;
   uint32_t pgc_start_byte;
   pgc_t *pgc;
 } ATTRIBUTE_PACKED pgci_srp_t;
-#define PGCI_SRP_SIZE 8
+#define PGCI_SRP_SIZE 8U
 
 /**
  * Program Chain Information Table.
@@ -450,7 +327,7 @@
   uint32_t last_byte;
   pgci_srp_t *pgci_srp;
 } ATTRIBUTE_PACKED pgcit_t;
-#define PGCIT_SIZE 8
+#define PGCIT_SIZE 8U
 
 /**
  * Menu PGCI Language Unit.
@@ -462,7 +339,7 @@
   uint32_t lang_start_byte;
   pgcit_t *pgcit;
 } ATTRIBUTE_PACKED pgci_lu_t;
-#define PGCI_LU_SIZE 8
+#define PGCI_LU_SIZE 8U
 
 /**
  * Menu PGCI Unit Table.
@@ -473,7 +350,7 @@
   uint32_t last_byte;
   pgci_lu_t *lu;
 } ATTRIBUTE_PACKED pgci_ut_t;
-#define PGCI_UT_SIZE 8
+#define PGCI_UT_SIZE 8U
 
 /**
  * Cell Address Information.
@@ -495,7 +372,7 @@
   uint32_t last_byte;
   cell_adr_t *cell_adr_table;  /* No explicit size given. */
 } ATTRIBUTE_PACKED c_adt_t;
-#define C_ADT_SIZE 8
+#define C_ADT_SIZE 8U
 
 /**
  * VOBU Address Map.
@@ -504,7 +381,7 @@
   uint32_t last_byte;
   uint32_t *vobu_start_sectors;
 } ATTRIBUTE_PACKED vobu_admap_t;
-#define VOBU_ADMAP_SIZE 4
+#define VOBU_ADMAP_SIZE 4U
 
 
 
@@ -559,7 +436,6 @@
 } ATTRIBUTE_PACKED vmgi_mat_t;
 
 typedef struct {
-#ifdef WORDS_BIGENDIAN
   unsigned int zero_1                    : 1;
   unsigned int multi_or_random_pgc_title : 1; /* 0: one sequential pgc title */
   unsigned int jlc_exists_in_cell_cmd    : 1;
@@ -568,16 +444,6 @@
   unsigned int jlc_exists_in_tt_dom      : 1;
   unsigned int chapter_search_or_play    : 1; /* UOP 1 */
   unsigned int title_or_time_play        : 1; /* UOP 0 */
-#else
-  unsigned char title_or_time_play        : 1;
-  unsigned char chapter_search_or_play    : 1;
-  unsigned char jlc_exists_in_tt_dom      : 1;
-  unsigned char jlc_exists_in_button_cmd  : 1;
-  unsigned char jlc_exists_in_prepost_cmd : 1;
-  unsigned char jlc_exists_in_cell_cmd    : 1;
-  unsigned char multi_or_random_pgc_title : 1;
-  unsigned char zero_1                    : 1;
-#endif
 } ATTRIBUTE_PACKED playback_type_t;
 
 /**
@@ -602,14 +468,15 @@
   uint32_t last_byte;
   title_info_t *title;
 } ATTRIBUTE_PACKED tt_srpt_t;
-#define TT_SRPT_SIZE 8
+#define TT_SRPT_SIZE 8U
 
 
 /**
  * Parental Management Information Unit Table.
  * Level 1 (US: G), ..., 7 (US: NC-17), 8
  */
-typedef uint16_t pf_level_t[8];
+#define PTL_MAIT_NUM_LEVEL 8
+typedef uint16_t pf_level_t[PTL_MAIT_NUM_LEVEL];
 
 /**
  * Parental Management Information Unit Table.
@@ -621,7 +488,7 @@
   uint16_t zero_2;
   pf_level_t *pf_ptl_mai; /* table of (nr_of_vtss + 1), video_ts is first */
 } ATTRIBUTE_PACKED ptl_mait_country_t;
-#define PTL_MAIT_COUNTRY_SIZE 8
+#define PTL_MAIT_COUNTRY_SIZE 8U
 
 /**
  * Parental Management Information Table.
@@ -632,7 +499,7 @@
   uint32_t last_byte;
   ptl_mait_country_t *countries;
 } ATTRIBUTE_PACKED ptl_mait_t;
-#define PTL_MAIT_SIZE 8
+#define PTL_MAIT_SIZE 8U
 
 /**
  * Video Title Set Attributes.
@@ -663,8 +530,8 @@
   uint8_t  nr_of_vtstt_subp_streams;
   subp_attr_t vtstt_subp_attr[32];
 } ATTRIBUTE_PACKED vts_attributes_t;
-#define VTS_ATTRIBUTES_SIZE 542
-#define VTS_ATTRIBUTES_MIN_SIZE 356
+#define VTS_ATTRIBUTES_SIZE 542U
+#define VTS_ATTRIBUTES_MIN_SIZE 356U
 
 /**
  * Video Title Set Attribute Table.
@@ -676,7 +543,7 @@
   vts_attributes_t *vts;
   uint32_t *vts_atrt_offsets; /* offsets table for each vts_attributes */
 } ATTRIBUTE_PACKED vts_atrt_t;
-#define VTS_ATRT_SIZE 8
+#define VTS_ATRT_SIZE 8U
 
 /**
  * Text Data. (Incomplete)
@@ -709,7 +576,7 @@
   uint32_t txtdt_start_byte;  /* prt, rel start of vmg_txtdt_mgi  */
   txtdt_t  *txtdt;
 } ATTRIBUTE_PACKED txtdt_lu_t;
-#define TXTDT_LU_SIZE 8
+#define TXTDT_LU_SIZE 8U
 
 /**
  * Text Data Manager Information. (Incomplete)
@@ -720,7 +587,7 @@
   uint32_t last_byte;
   txtdt_lu_t *lu;
 } ATTRIBUTE_PACKED txtdt_mgi_t;
-#define TXTDT_MGI_SIZE 20
+#define TXTDT_MGI_SIZE 20U
 
 
 /**
@@ -812,7 +679,7 @@
   ttu_t  *title;
   uint32_t *ttu_offset; /* offset table for each ttu */
 } ATTRIBUTE_PACKED vts_ptt_srpt_t;
-#define VTS_PTT_SRPT_SIZE 8
+#define VTS_PTT_SRPT_SIZE 8U
 
 
 /**
@@ -830,7 +697,7 @@
   uint16_t nr_of_entries;
   map_ent_t *map_ent;
 } ATTRIBUTE_PACKED vts_tmap_t;
-#define VTS_TMAP_SIZE 4
+#define VTS_TMAP_SIZE 4U
 
 /**
  * Time Map Table.
@@ -842,7 +709,7 @@
   vts_tmap_t *tmap;
   uint32_t *tmap_offset; /* offset table for each tmap */
 } ATTRIBUTE_PACKED vts_tmapt_t;
-#define VTS_TMAPT_SIZE 8
+#define VTS_TMAPT_SIZE 8U
 
 
 #if PRAGMA_PACK
@@ -881,4 +748,4 @@
   vobu_admap_t   *vts_vobu_admap;
 } ifo_handle_t;
 
-#endif /* IFO_TYPES_H_INCLUDED */
+#endif /* LIBDVDREAD_IFO_TYPES_H */
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/nav_types.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/nav_types.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/nav_types.h	2013-02-16 18:48:38.524390659 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/nav_types.h	2013-02-08 20:31:25.635872649 +0000
@@ -1,8 +1,5 @@
-#ifndef NAV_TYPES_H_INCLUDED
-#define NAV_TYPES_H_INCLUDED
-
 /*
- * Copyright (C) 2000, 2001, 2002 Hkan Hjort <d95hjort@dtek.chalmers.se>
+ * Copyright (C) 2000, 2001, 2002 Hkan Hjort <d95hjort@dtek.chalmers.se>
  *
  * The data structures in this file should represent the layout of the
  * pci and dsi packets as they are stored in the stream.  Information
@@ -24,11 +21,13 @@
  * the GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
- * USA
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
+#ifndef LIBDVDREAD_NAV_TYPES_H
+#define LIBDVDREAD_NAV_TYPES_H
+
 //#include <inttypes.h>
 #include "ifo_types.h" /* only dvd_time_t, vm_cmd_t and user_ops_t */
 
@@ -217,7 +216,7 @@
 } ATTRIBUTE_PACKED sml_pbi_t;
 
 /**
- * Seamless Angle Infromation for one angle
+ * Seamless Angle Information for one angle
  */
 typedef struct {
     uint32_t address; /**< offset to next ILVU, high bit is before/after */
@@ -225,7 +224,7 @@
 } ATTRIBUTE_PACKED sml_agl_data_t;
 
 /**
- * Seamless Angle Infromation
+ * Seamless Angle Information
  */
 typedef struct {
   sml_agl_data_t data[9];
@@ -270,4 +269,4 @@
 #pragma pack()
 #endif
 
-#endif /* NAV_TYPES_H_INCLUDED */
+#endif /* LIBDVDREAD_NAV_TYPES_H */
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/remap.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/remap.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/remap.h	2013-02-16 18:48:38.524390659 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/remap.h	2013-02-08 20:31:25.635872649 +0000
@@ -11,15 +11,13 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
- *
- * $Id$
+ * You should have received a copy of the GNU General Public License along
+ * with libdvdnav; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
-#ifndef __REMAP__H
-#define __REMAP__H
+#ifndef LIBDVDNAV_REMAP_H
+#define LIBDVDNAV_REMAP_H
 typedef struct block_s block_t;
 
 typedef struct remap_s remap_t;
@@ -30,4 +28,4 @@
 	remap_t *map, int domain, int title, int program, 
 	unsigned long cblock, unsigned long offset);
 
-#endif
+#endif /* LIBDVDNAV_REMAP_H */
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/vm.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/vm.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/vm.h	2013-02-16 18:48:38.524390659 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/vm.h	2013-02-08 20:31:25.645872455 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000, 2001 Hkan Hjort
+ * Copyright (C) 2000, 2001 Hkan Hjort
  * Copyright (C) 2001 Rich Wareham <richwareham@users.sourceforge.net>
  * 
  * This file is part of libdvdnav, a DVD navigation library. It is modified
@@ -15,16 +15,13 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
- *
- * $Id$
- *
+ * You should have received a copy of the GNU General Public License along
+ * with libdvdnav; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
-#ifndef VM_H_INCLUDED
-#define VM_H_INCLUDED
+#ifndef LIBDVDNAV_VM_H
+#define LIBDVDNAV_VM_H
 
 #include "remap.h"
 #include "dvdnav_internal.h"
@@ -88,6 +85,7 @@
   dvd_state_t   state;
   int32_t       hop_channel;
   char          dvd_name[50];
+  char          dvd_serial[15];
   remap_t      *map;
   int           stopped;
 } vm_t;
@@ -144,6 +142,7 @@
 int vm_jump_pg(vm_t *vm, int pg);
 int vm_jump_cell_block(vm_t *vm, int cell, int block);
 int vm_jump_title_part(vm_t *vm, int title, int part);
+int vm_jump_title_program(vm_t *vm, int title, int pgcn, int pgn);
 int vm_jump_top_pg(vm_t *vm);
 int vm_jump_next_pg(vm_t *vm);
 int vm_jump_prev_pg(vm_t *vm);
@@ -168,7 +167,14 @@
 video_attr_t vm_get_video_attr(vm_t *vm);
 audio_attr_t vm_get_audio_attr(vm_t *vm, int streamN);
 subp_attr_t  vm_get_subp_attr(vm_t *vm, int streamN);
+ifo_handle_t *vm_get_title_ifo(vm_t *vm, uint32_t title);
+void vm_ifo_close(ifo_handle_t *ifo);
+
+int vm_get_state(vm_t *vm, dvd_state_t *save_state);
+int vm_set_state(vm_t *vm, dvd_state_t *save_state);
 
+/* Uncomment for VM command tracing */
+/* #define TRACE */
 #ifdef TRACE
 /* Debug */
 void vm_position_print(vm_t *vm, vm_position_t *position);
@@ -177,8 +183,4 @@
 /* XBMC added functions */
 vm_t* dvdnav_get_vm(dvdnav_t *self);
 
-dvdnav_status_t dvdnav_get_state(dvdnav_t *self, dvd_state_t *save_state);
-
-dvdnav_status_t dvdnav_set_state(dvdnav_t *self, dvd_state_t *save_state);
-
-#endif /* VM_HV_INCLUDED */
+#endif /* LIBDVDNAV_VM_H */
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/vmcmd.h xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/vmcmd.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/vmcmd.h	2013-02-16 18:48:38.524390659 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDInputStreams/dvdnav/vmcmd.h	2013-02-08 20:31:25.645872455 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000, 2001 Martin Norbck, Hkan Hjort
+ * Copyright (C) 2000, 2001 Martin Norbck, Hkan Hjort
  * 
  * This file is part of libdvdnav, a DVD navigation library. It is modified
  * from a file originally part of the Ogle DVD player.
@@ -14,20 +14,17 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
- *
- * $Id$
- *
+ * You should have received a copy of the GNU General Public License along
+ * with libdvdnav; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
-#ifndef VMCMD_H_INCLUDED
-#define VMCMD_H_INCLUDED
+#ifndef LIBDVDNAV_VMCMD_H
+#define LIBDVDNAV_VMCMD_H
 
 //#include <inttypes.h>
 
 void vm_print_mnemonic(vm_cmd_t *command);
 void vm_print_cmd(int row, vm_cmd_t *command);
 
-#endif /* VMCMD_H_INCLUDED */
+#endif /* LIBDVDNAV_VMCMD_H */
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDMessage.cpp xbmc/xbmc/cores/dvdplayer/DVDMessage.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDMessage.cpp	2013-02-16 18:48:38.524390659 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDMessage.cpp	2013-02-10 14:23:18.636512880 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDMessage.h xbmc/xbmc/cores/dvdplayer/DVDMessage.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDMessage.h	2013-02-16 18:48:38.524390659 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDMessage.h	2013-04-05 11:38:43.956813901 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -73,6 +73,8 @@
     PLAYER_CHANNEL_SELECT,          // switches to the provided channel
     PLAYER_STARTED,                 // sent whenever a sub player has finished it's first frame after open
 
+    PLAYER_DISPLAYTIME,             // display time struct from av players
+
     // demuxer related messages
 
     DEMUXER_PACKET,                 // data packet
@@ -209,7 +211,7 @@
 class CDVDMsgPlayerSetState : public CDVDMsg
 {
 public:
-  CDVDMsgPlayerSetState(std::string& state) : CDVDMsg(PLAYER_SET_STATE) { m_state = state; }
+  CDVDMsgPlayerSetState(std::string& state) : CDVDMsg(PLAYER_SET_STATE), m_state(state) {}
   std::string GetState()                { return m_state; }
 private:
   std::string m_state;
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDMessageQueue.cpp xbmc/xbmc/cores/dvdplayer/DVDMessageQueue.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDMessageQueue.cpp	2013-02-16 18:48:38.524390659 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDMessageQueue.cpp	2013-04-05 11:38:43.956813901 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -27,9 +27,8 @@
 
 using namespace std;
 
-CDVDMessageQueue::CDVDMessageQueue(const string &owner) : m_hEvent(true)
+CDVDMessageQueue::CDVDMessageQueue(const string &owner) : m_hEvent(true), m_owner(owner)
 {
-  m_owner = owner;
   m_iDataSize     = 0;
   m_bAbortRequest = false;
   m_bInitialized  = false;
@@ -67,7 +66,7 @@
     if (it->message->IsType(type) ||  type == CDVDMsg::NONE)
       it = m_list.erase(it);
     else
-      it++;
+      ++it;
   }
 
   if (type == CDVDMsg::DEMUXER_PACKET ||  type == CDVDMsg::NONE)
@@ -121,7 +120,7 @@
   {
     if(priority <= it->priority)
       break;
-    it++;
+    ++it;
   }
   m_list.insert(it, DVDMessageListItem(pMsg, priority));
 
@@ -230,7 +229,7 @@
     return 0;
 
   unsigned count = 0;
-  for(SList::iterator it = m_list.begin(); it != m_list.end();it++)
+  for(SList::iterator it = m_list.begin(); it != m_list.end();++it)
   {
     if(it->message->IsType(type))
       count++;
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDMessageQueue.h xbmc/xbmc/cores/dvdplayer/DVDMessageQueue.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDMessageQueue.h	2013-02-16 18:48:38.534390462 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDMessageQueue.h	2013-02-10 14:23:18.636512880 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDMessageTracker.cpp xbmc/xbmc/cores/dvdplayer/DVDMessageTracker.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDMessageTracker.cpp	2013-02-16 18:48:38.534390462 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDMessageTracker.cpp	2013-04-05 11:38:43.956813901 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -76,7 +76,7 @@
       delete pItem;
       break;
     }
-    iter++;
+    ++iter;
   }
 
 }
@@ -108,7 +108,7 @@
           pItem->m_debug_logged = true;
         }
       }
-      iter++;
+      ++iter;
     }
 
   }
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDMessageTracker.h xbmc/xbmc/cores/dvdplayer/DVDMessageTracker.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDMessageTracker.h	2013-02-16 18:48:38.534390462 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDMessageTracker.h	2013-02-10 14:23:18.636512880 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDOverlayContainer.cpp xbmc/xbmc/cores/dvdplayer/DVDOverlayContainer.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDOverlayContainer.cpp	2013-02-16 18:48:38.534390462 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDOverlayContainer.cpp	2013-04-05 11:38:43.966813722 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -121,14 +121,14 @@
         continue;
       }
     }
-    it++;
+    ++it;
   }
 
 }
 
 void CDVDOverlayContainer::Remove()
 {
-  if (m_overlays.size() > 0)
+  if (!m_overlays.empty())
   {
     CDVDOverlay* pOverlay;
 
@@ -144,7 +144,7 @@
 
 void CDVDOverlayContainer::Clear()
 {
-  while (m_overlays.size() > 0) Remove();
+  while (!m_overlays.empty()) Remove();
 }
 
 int CDVDOverlayContainer::GetSize()
@@ -162,7 +162,7 @@
   while (!result && it != m_overlays.end())
   {
     if (((CDVDOverlay*)*it)->IsOverlayType(type)) result = true;
-    it++;
+    ++it;
   }
 
   return result;
@@ -176,7 +176,7 @@
   CSingleLock lock(*this);
 
   //Update any forced overlays.
-  for(VecOverlays::iterator it = m_overlays.begin(); it != m_overlays.end(); it++ )
+  for(VecOverlays::iterator it = m_overlays.begin(); it != m_overlays.end(); ++it )
   {
     if ((*it)->IsOverlayType(DVDOVERLAY_TYPE_SPU))
     {
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDOverlayContainer.h xbmc/xbmc/cores/dvdplayer/DVDOverlayContainer.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDOverlayContainer.h	2013-02-16 18:48:38.534390462 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDOverlayContainer.h	2013-02-10 14:23:18.646512685 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDOverlayRenderer.cpp xbmc/xbmc/cores/dvdplayer/DVDOverlayRenderer.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDOverlayRenderer.cpp	2013-02-16 18:48:38.534390462 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDOverlayRenderer.cpp	2013-02-10 14:23:18.646512685 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDOverlayRenderer.h xbmc/xbmc/cores/dvdplayer/DVDOverlayRenderer.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDOverlayRenderer.h	2013-02-16 18:48:38.534390462 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDOverlayRenderer.h	2013-02-10 14:23:18.646512685 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDPerformanceCounter.cpp xbmc/xbmc/cores/dvdplayer/DVDPerformanceCounter.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDPerformanceCounter.cpp	2013-02-16 18:48:38.534390462 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDPerformanceCounter.cpp	2013-02-10 14:23:18.646512685 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDPerformanceCounter.h xbmc/xbmc/cores/dvdplayer/DVDPerformanceCounter.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDPerformanceCounter.h	2013-02-16 18:48:38.534390462 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDPerformanceCounter.h	2013-04-05 11:38:43.966813722 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -42,7 +42,7 @@
   ~CDVDPerformanceCounter();
 
   bool Initialize();
-  void DeInitialize();
+  static void DeInitialize();
 
   void EnableAudioQueue(CDVDMessageQueue* pQueue)     { CSingleLock lock(m_critSection); m_pAudioQueue = pQueue; }
   void DisableAudioQueue()                            { CSingleLock lock(m_critSection); m_pAudioQueue = NULL;  }
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayer.cpp xbmc/xbmc/cores/dvdplayer/DVDPlayer.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayer.cpp	2013-04-05 17:12:13.797112563 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDPlayer.cpp	2013-04-05 17:19:30.079106228 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -41,6 +41,7 @@
 #include "DVDFileInfo.h"
 
 #include "utils/LangCodeExpander.h"
+#include "guilib/Key.h"
 #include "guilib/LocalizeStrings.h"
 
 #include "utils/URIUtils.h"
@@ -63,6 +64,7 @@
 #include "settings/AdvancedSettings.h"
 #include "FileItem.h"
 #include "settings/GUISettings.h"
+#include "settings/MediaSettings.h"
 #include "GUIUserMessages.h"
 #include "settings/Settings.h"
 #include "utils/log.h"
@@ -103,14 +105,6 @@
   }
 }
 
-void CDVDPlayer::GetAudioStreamLanguage(int iStream, CStdString &strLanguage)
-{
-  strLanguage = "";
-  SelectionStream& s = m_SelectionStreams.Get(STREAM_AUDIO, iStream);
-  if(s.language.length() > 0)
-    strLanguage = s.language;
-}
-
 SelectionStream& CSelectionStreams::Get(StreamType type, int index)
 {
   CSingleLock lock(m_section);
@@ -145,8 +139,8 @@
 
 static bool PredicateAudioPriority(const SelectionStream& lh, const SelectionStream& rh)
 {
-  PREDICATE_RETURN(lh.type_index == g_settings.m_currentVideoSettings.m_AudioStream
-                 , rh.type_index == g_settings.m_currentVideoSettings.m_AudioStream);
+  PREDICATE_RETURN(lh.type_index == CMediaSettings::Get().GetCurrentVideoSettings().m_AudioStream
+                 , rh.type_index == CMediaSettings::Get().GetCurrentVideoSettings().m_AudioStream);
 
   if(!g_guiSettings.GetString("locale.audiolanguage").Equals("original"))
   {
@@ -168,14 +162,14 @@
 
 static bool PredicateSubtitlePriority(const SelectionStream& lh, const SelectionStream& rh)
 {
-  if(!g_settings.m_currentVideoSettings.m_SubtitleOn)
+  if(!CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleOn)
   {
     PREDICATE_RETURN(lh.flags & CDemuxStream::FLAG_FORCED
                    , rh.flags & CDemuxStream::FLAG_FORCED);
   }
 
-  PREDICATE_RETURN(lh.type_index == g_settings.m_currentVideoSettings.m_SubtitleStream
-                 , rh.type_index == g_settings.m_currentVideoSettings.m_SubtitleStream);
+  PREDICATE_RETURN(lh.type_index == CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleStream
+                 , rh.type_index == CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleStream);
 
   CStdString subtitle_language = g_langInfo.GetSubtitleLanguage();
   if(!g_guiSettings.GetString("locale.subtitlelanguage").Equals("original"))
@@ -325,10 +319,14 @@
       s.source   = source;
       s.type     = STREAM_AUDIO;
       s.id       = i;
-      s.name     = nav->GetAudioStreamLanguage(i);
       s.flags    = CDemuxStream::FLAG_NONE;
       s.filename = filename;
-      s.channels = 0;
+
+      DVDNavStreamInfo info;
+      nav->GetAudioStreamInfo(i, info);
+      s.name     = info.name;
+      s.language = info.language;
+      s.channels = info.channels;
       Update(s);
     }
 
@@ -339,10 +337,14 @@
       s.source   = source;
       s.type     = STREAM_SUBTITLE;
       s.id       = i;
-      s.name     = nav->GetSubtitleStreamLanguage(i);
       s.flags    = CDemuxStream::FLAG_NONE;
       s.filename = filename;
       s.channels = 0;
+
+      DVDNavStreamInfo info;
+      nav->GetSubtitleStreamInfo(i, info);
+      s.name     = info.name;
+      s.language = info.language;
       Update(s);
     }
   }
@@ -368,6 +370,14 @@
       s.type     = stream->type;
       s.id       = stream->iId;
       s.language = stream->language;
+
+      if (s.language.length() == 2)
+      {
+        CStdString lang;
+        g_LangCodeExpander.ConvertToThreeCharCode(lang, stream->language);
+        s.language = lang;
+      }
+
       s.flags    = stream->flags;
       s.filename = demuxer->GetFileName();
       stream->GetStreamName(s.name);
@@ -420,6 +430,8 @@
   m_offset_pts = 0.0;
   m_playSpeed = DVD_PLAYSPEED_NORMAL;
   m_caching = CACHESTATE_DONE;
+  m_HasVideo = false;
+  m_HasAudio = false;
 
   memset(&m_SpeedState, 0, sizeof(m_SpeedState));
 
@@ -519,6 +531,9 @@
   m_Edl.Clear();
   m_EdlAutoSkipMarkers.Clear();
 
+  m_HasVideo = false;
+  m_HasAudio = false;
+
   CLog::Log(LOGNOTICE, "DVDPlayer: finished waiting");
 #if defined(HAS_VIDEO_PLAYBACK)
   g_renderManager.UnInit();
@@ -619,11 +634,11 @@
       }
     } // end loop over all subtitle files
 
-    g_settings.m_currentVideoSettings.m_SubtitleCached = true;
+    CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleCached = true;
   }
 
-  SetAVDelay(g_settings.m_currentVideoSettings.m_AudioDelay);
-  SetSubTitleDelay(g_settings.m_currentVideoSettings.m_SubtitleDelay);
+  SetAVDelay(CMediaSettings::Get().GetCurrentVideoSettings().m_AudioDelay);
+  SetSubTitleDelay(CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleDelay);
   m_clock.Reset();
   m_dvd.Clear();
   m_errorCount = 0;
@@ -684,8 +699,9 @@
 
 void CDVDPlayer::OpenDefaultStreams(bool reset)
 {
-  // bypass for DVDs. The DVD Navigator has already dictated which streams to open.
-  if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
+  // if input stream dictate, we will open later
+  if(m_dvd.iSelectedAudioStream >= 0
+  || m_dvd.iSelectedSPUStream   >= 0)
     return;
 
   SelectionStreams streams;
@@ -718,7 +734,7 @@
     CloseAudioStream(true);
 
   // enable subtitles
-  m_dvdPlayerVideo.EnableSubtitle(g_settings.m_currentVideoSettings.m_SubtitleOn);
+  m_dvdPlayerVideo.EnableSubtitle(CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleOn);
 
   // open subtitle stream
   streams = m_SelectionStreams.Get(STREAM_SUBTITLE, PredicateSubtitlePriority);
@@ -789,6 +805,13 @@
         m_SelectionStreams.Clear(STREAM_NONE, STREAM_SOURCE_DEMUX);
         m_SelectionStreams.Update(m_pInputStream, m_pDemuxer);
         OpenDefaultStreams(false);
+
+        // reevaluate HasVideo/Audio, we may have switched from/to a radio channel
+        if(m_CurrentVideo.id < 0)
+          m_HasVideo = false;
+        if(m_CurrentAudio.id < 0)
+          m_HasAudio = false;
+
         return true;
     }
 
@@ -866,6 +889,9 @@
   if(m_PlayerOptions.video_only && current.type != STREAM_VIDEO)
     return false;
 
+  if(stream->disabled)
+    return false;
+
   if (m_pInputStream && ( m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD)
                        || m_pInputStream->IsStreamType(DVDSTREAM_TYPE_BLURAY) ) )
   {
@@ -895,9 +921,6 @@
     && stream->iId    == current.id)
       return false;
 
-    if(stream->disabled)
-      return false;
-
     if(stream->type != current.type)
       return false;
 
@@ -918,18 +941,17 @@
     return;
   }
 
-  if(m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
+  if (CDVDInputStream::IMenus* ptr = dynamic_cast<CDVDInputStream::IMenus*>(m_pInputStream))
   {
-    CLog::Log(LOGNOTICE, "DVDPlayer: playing a dvd with menu's");
+    CLog::Log(LOGNOTICE, "DVDPlayer: playing a file with menu's");
     m_PlayerOptions.starttime = 0;
 
-
     if(m_PlayerOptions.state.size() > 0)
-      ((CDVDInputStreamNavigator*)m_pInputStream)->SetNavigatorState(m_PlayerOptions.state);
-    else
-      ((CDVDInputStreamNavigator*)m_pInputStream)->EnableSubtitleStream(g_settings.m_currentVideoSettings.m_SubtitleOn);
+      ptr->SetState(m_PlayerOptions.state);
+    else if(CDVDInputStreamNavigator* nav = dynamic_cast<CDVDInputStreamNavigator*>(m_pInputStream))
+      nav->EnableSubtitleStream(CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleOn);
 
-    g_settings.m_currentVideoSettings.m_SubtitleCached = true;
+    CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleCached = true;
   }
 
   if(!OpenDemuxStream())
@@ -1061,6 +1083,10 @@
 
       OpenDefaultStreams();
 
+      // never allow first frames after open to be skipped
+      if( m_dvdPlayerVideo.IsInited() )
+        m_dvdPlayerVideo.SendMessage(new CDVDMsg(CDVDMsg::VIDEO_NOSKIP));
+
       if (CachePVRStream())
         SetCaching(CACHESTATE_PVR);
 
@@ -1110,10 +1136,8 @@
         continue;
 
       // check for a still frame state
-      if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
+      if (CDVDInputStream::IMenus* pStream = dynamic_cast<CDVDInputStream::IMenus*>(m_pInputStream))
       {
-        CDVDInputStreamNavigator* pStream = static_cast<CDVDInputStreamNavigator*>(m_pInputStream);
-
         // stills will be skipped
         if(m_dvd.state == DVDSTATE_STILL)
         {
@@ -1708,6 +1732,24 @@
     current.dur = 0.1 * (current.dur * 9 + (dts - current.dts));
 
   current.dts = dts;
+
+  /* send a playback state structure periodically */
+  if(current.dts_state == DVD_NOPTS_VALUE
+  || abs(current.dts - current.dts_state) > DVD_MSEC_TO_TIME(200))
+  {
+    current.dts_state = current.dts;
+    if (current.inited)
+    {
+      // make sure we send no outdated state to a/v players
+      UpdatePlayState(0);
+      SendPlayerMessage(new CDVDMsgType<SPlayerState>(CDVDMsg::PLAYER_DISPLAYTIME, m_StateInput), current.player);
+    }
+    else
+    {
+      CSingleLock lock(m_StateSection);
+      m_State = m_StateInput;
+    }
+  }
 }
 
 static void UpdateLimits(double& minimum, double& maximum, double dts)
@@ -2019,7 +2061,7 @@
 
         // if input streams doesn't support seektime we must convert back to clock
         if(dynamic_cast<CDVDInputStream::ISeekTime*>(m_pInputStream) == NULL)
-          time -= DVD_TIME_TO_MSEC(m_State.time_offset);
+          time -= DVD_TIME_TO_MSEC(m_State.time_offset - m_offset_pts);
 
         CLog::Log(LOGDEBUG, "demuxer seek to: %d", time);
         if (m_pDemuxer && m_pDemuxer->SeekTime(time, msg.GetBackward(), &start))
@@ -2030,6 +2072,9 @@
             if(!m_pSubtitleDemuxer->SeekTime(time, msg.GetBackward()))
               CLog::Log(LOGDEBUG, "failed to seek subtitle demuxer: %d, success", time);
           }
+          // dts after successful seek
+          m_StateInput.dts = start;
+
           FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate());
         }
         else
@@ -2137,14 +2182,15 @@
 
         CDVDMsgPlayerSetState* pMsgPlayerSetState = (CDVDMsgPlayerSetState*)pMsg;
 
-        if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
+        if (CDVDInputStream::IMenus* ptr = dynamic_cast<CDVDInputStream::IMenus*>(m_pInputStream))
+        {
+          if(ptr->SetState(pMsgPlayerSetState->GetState()))
         {
-          std::string s = pMsgPlayerSetState->GetState();
-          ((CDVDInputStreamNavigator*)m_pInputStream)->SetNavigatorState(s);
           m_dvd.state = DVDSTATE_NORMAL;
           m_dvd.iDVDStillStartTime = 0;
           m_dvd.iDVDStillTime = 0;
         }
+        }
 
         g_infoManager.SetDisplayAfterSeek();
       }
@@ -2278,6 +2324,24 @@
           m_CurrentVideo.started = true;
         CLog::Log(LOGDEBUG, "CDVDPlayer::HandleMessages - player started %d", player);
       }
+      else if (pMsg->IsType(CDVDMsg::PLAYER_DISPLAYTIME))
+      {
+        CDVDPlayer::SPlayerState& state = ((CDVDMsgType<CDVDPlayer::SPlayerState>*)pMsg)->m_value;
+
+        CSingleLock lock(m_StateSection);
+        /* prioritize data from video player, but only accept data        *
+         * after it has been started to avoid race conditions after seeks */
+        if(m_CurrentVideo.started)
+        {
+          if(state.player == DVDPLAYER_VIDEO)
+            m_State = state;
+        }
+        else if(m_CurrentAudio.started)
+        {
+          if(state.player == DVDPLAYER_AUDIO)
+            m_State = state;
+        }
+      }
     }
     catch (...)
     {
@@ -2376,14 +2440,12 @@
 
 bool CDVDPlayer::HasVideo() const
 {
-  if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD)) return true;
-
-  return m_SelectionStreams.Count(STREAM_VIDEO) > 0 ? true : false;
+  return m_HasVideo;
 }
 
 bool CDVDPlayer::HasAudio() const
 {
-  return m_SelectionStreams.Count(STREAM_AUDIO) > 0 ? true : false;
+  return m_HasAudio;
 }
 
 bool CDVDPlayer::IsPassthrough() const
@@ -2534,17 +2596,17 @@
 void CDVDPlayer::GetAudioInfo(CStdString& strAudioInfo)
 {
   { CSingleLock lock(m_StateSection);
-    strAudioInfo.Format("D(%s)", m_State.demux_audio.c_str());
+    strAudioInfo.Format("D(%s)", m_StateInput.demux_audio.c_str());
   }
-  strAudioInfo.AppendFormat(" P(%s)", m_dvdPlayerAudio.GetPlayerInfo().c_str());
+  strAudioInfo.AppendFormat("\nP(%s)", m_dvdPlayerAudio.GetPlayerInfo().c_str());
 }
 
 void CDVDPlayer::GetVideoInfo(CStdString& strVideoInfo)
 {
   { CSingleLock lock(m_StateSection);
-    strVideoInfo.Format("D(%s)", m_State.demux_video.c_str());
+    strVideoInfo.Format("D(%s)", m_StateInput.demux_video.c_str());
   }
-  strVideoInfo.AppendFormat(" P(%s)", m_dvdPlayerVideo.GetPlayerInfo().c_str());
+  strVideoInfo.AppendFormat("\nP(%s)", m_dvdPlayerVideo.GetPlayerInfo().c_str());
 }
 
 void CDVDPlayer::GetGeneralInfo(CStdString& strGeneralInfo)
@@ -2565,7 +2627,7 @@
 
     CStdString strBuf;
     CSingleLock lock(m_StateSection);
-    if(m_State.cache_bytes >= 0)
+    if(m_StateInput.cache_bytes >= 0)
     {
       strBuf.AppendFormat(" cache:%s %2.0f%%"
                          , StringUtils::SizeToString(m_State.cache_bytes).c_str()
@@ -2609,7 +2671,7 @@
 float CDVDPlayer::GetCachePercentage()
 {
   CSingleLock lock(m_StateSection);
-  return m_State.cache_offset * 100; // NOTE: Percentage returned is relative
+  return m_StateInput.cache_offset * 100; // NOTE: Percentage returned is relative
 }
 
 void CDVDPlayer::SetAVDelay(float fValue)
@@ -2645,24 +2707,19 @@
   return m_SelectionStreams.IndexOf(STREAM_SUBTITLE, *this);
 }
 
-void CDVDPlayer::GetSubtitleName(int iStream, CStdString &strStreamName)
+void CDVDPlayer::GetSubtitleStreamInfo(int index, SPlayerSubtitleStreamInfo &info)
 {
-  strStreamName = "";
-  SelectionStream& s = m_SelectionStreams.Get(STREAM_SUBTITLE, iStream);
+  if (index < 0 || index > (int) GetSubtitleCount() - 1)
+    return;
+
+  SelectionStream& s = m_SelectionStreams.Get(STREAM_SUBTITLE, index);
   if(s.name.length() > 0)
-    strStreamName = s.name;
-  else
-    strStreamName = g_localizeStrings.Get(13205); // Unknown
+    info.name = s.name;
 
   if(s.type == STREAM_NONE)
-    strStreamName += "(Invalid)";
-}
+    info.name += "(Invalid)";
 
-void CDVDPlayer::GetSubtitleLanguage(int iStream, CStdString &strStreamLang)
-{
-  SelectionStream& s = m_SelectionStreams.Get(STREAM_SUBTITLE, iStream);
-  if (!g_LangCodeExpander.Lookup(strStreamLang, s.language))
-    strStreamLang = g_localizeStrings.Get(13205); // Unknown
+  info.language = s.language;
 }
 
 void CDVDPlayer::SetSubtitle(int iStream)
@@ -2676,7 +2733,7 @@
   {
     CDVDInputStreamNavigator* pStream = (CDVDInputStreamNavigator*)m_pInputStream;
     if(pStream->IsInMenu())
-      return g_settings.m_currentVideoSettings.m_SubtitleOn;
+      return CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleOn;
     else
       return pStream->IsSubtitleStreamEnabled();
   }
@@ -2686,7 +2743,7 @@
 
 void CDVDPlayer::SetSubtitleVisible(bool bVisible)
 {
-  g_settings.m_currentVideoSettings.m_SubtitleOn = bVisible;
+  CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleOn = bVisible;
   m_messenger.Put(new CDVDMsgBool(CDVDMsg::PLAYER_SET_SUBTITLESTREAM_VISIBLE, bVisible));
 }
 
@@ -2702,19 +2759,6 @@
   return m_SelectionStreams.IndexOf(STREAM_AUDIO, *this);
 }
 
-void CDVDPlayer::GetAudioStreamName(int iStream, CStdString& strStreamName)
-{
-  strStreamName = "";
-  SelectionStream& s = m_SelectionStreams.Get(STREAM_AUDIO, iStream);
-  if(s.name.length() > 0)
-    strStreamName += s.name;
-  else
-    strStreamName += "Unknown";
-
-  if(s.type == STREAM_NONE)
-    strStreamName += " (Invalid)";
-}
-
 void CDVDPlayer::SetAudioStream(int iStream)
 {
   m_messenger.Put(new CDVDMsgPlayerSetAudioStream(iStream));
@@ -2750,12 +2794,13 @@
 {
   CSingleLock lock(m_StateSection);
   double offset = 0;
+  const double limit  = DVD_MSEC_TO_TIME(200);
   if(m_State.timestamp > 0)
   {
     offset  = CDVDClock::GetAbsoluteClock() - m_State.timestamp;
     offset *= m_playSpeed / DVD_PLAYSPEED_NORMAL;
-    if(offset >  1000) offset =  1000;
-    if(offset < -1000) offset = -1000;
+    if(offset >  limit) offset =  limit;
+    if(offset < -limit) offset = -limit;
   }
   return llrint(m_State.time + DVD_TIME_TO_MSEC(offset));
 }
@@ -2829,6 +2874,7 @@
   m_CurrentAudio.hint = hint;
   m_CurrentAudio.stream = (void*)pStream;
   m_CurrentAudio.started = false;
+  m_HasAudio = true;
 
   /* we are potentially going to be waiting on this */
   m_dvdPlayerAudio.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
@@ -2901,6 +2947,7 @@
   m_CurrentVideo.hint = hint;
   m_CurrentVideo.stream = (void*)pStream;
   m_CurrentVideo.started = false;
+  m_HasVideo = true;
 
   /* we are potentially going to be waiting on this */
   m_dvdPlayerVideo.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
@@ -3198,6 +3245,11 @@
     if(pts != DVD_NOPTS_VALUE)
       m_clock.Discontinuity(pts);
     UpdatePlayState(0);
+
+    // update state, buffers are flushed and it may take some time until
+    // we get an update from players
+    CSingleLock lock(m_StateSection);
+    m_State = m_StateInput;
   }
 }
 
@@ -3216,6 +3268,29 @@
       m_dvd.iSelectedSPUStream   = *(int*)pData;
     else if(iMessage == 4)
       m_dvdPlayerVideo.EnableSubtitle(*(int*)pData ? true: false);
+    else if(iMessage == 5)
+    {
+      if (m_dvd.state != DVDSTATE_STILL)
+      {
+        // else notify the player we have received a still frame
+
+        m_dvd.iDVDStillTime      = *(int*)pData;
+        m_dvd.iDVDStillStartTime = XbmcThreads::SystemClockMillis();
+
+        /* adjust for the output delay in the video queue */
+        unsigned int time = 0;
+        if( m_CurrentVideo.stream && m_dvd.iDVDStillTime > 0 )
+        {
+          time = (unsigned int)(m_dvdPlayerVideo.GetOutputDelay() / ( DVD_TIME_BASE / 1000 ));
+          if( time < 10000 && time > 0 )
+            m_dvd.iDVDStillTime += time;
+        }
+        m_dvd.state = DVDSTATE_STILL;
+        CLog::Log(LOGDEBUG,
+                  "DVDNAV_STILL_FRAME - waiting %i sec, with delay of %d sec",
+                  m_dvd.iDVDStillTime, time / 1000);
+      }
+    }
 
     return 0;
   }
@@ -3454,7 +3529,7 @@
         pMenus->OnMenu();
         // send a message to everyone that we've gone to the menu
         CGUIMessage msg(GUI_MSG_VIDEO_MENU_STARTED, 0, 0);
-        g_windowManager.SendMessage(msg);
+        g_windowManager.SendThreadMessage(msg);
         return true;
       }
       break;
@@ -3517,7 +3592,7 @@
       case ACTION_MOUSE_LEFT_CLICK:
         {
           CRect rs, rd;
-          GetVideoRect(rs, rd);
+          m_dvdPlayerVideo.GetVideoRect(rs, rd);
           CPoint pt(action.GetAmount(), action.GetAmount(1));
           if (!rd.PtInRect(pt))
             return false; // out of bounds
@@ -3732,7 +3807,7 @@
 int CDVDPlayer::GetCacheLevel() const
 {
   CSingleLock lock(m_StateSection);
-  return (int)(m_State.cache_level * 100);
+  return (int)(m_StateInput.cache_level * 100);
 }
 
 double CDVDPlayer::GetQueueTime()
@@ -3742,14 +3817,16 @@
   return max(a, v) * 8000.0 / 100;
 }
 
-int CDVDPlayer::GetAudioBitrate()
+void CDVDPlayer::GetVideoStreamInfo(SPlayerVideoStreamInfo &info)
 {
-  return m_dvdPlayerAudio.GetAudioBitrate();
-}
+  info.bitrate = m_dvdPlayerVideo.GetVideoBitrate();
 
-int CDVDPlayer::GetVideoBitrate()
-{
-  return m_dvdPlayerVideo.GetVideoBitrate();
+  CStdString retVal;
+  if (m_pDemuxer && (m_CurrentVideo.id != -1))
+    m_pDemuxer->GetStreamCodecName(m_CurrentVideo.id, retVal);
+  info.videoCodecName = retVal;
+  info.videoAspectRatio = m_dvdPlayerVideo.GetAspectRatio();
+  m_dvdPlayerVideo.GetVideoRect(info.SrcRect, info.DestRect);
 }
 
 int CDVDPlayer::GetSourceBitrate()
@@ -3760,6 +3837,38 @@
   return 0;
 }
 
+void CDVDPlayer::GetAudioStreamInfo(int index, SPlayerAudioStreamInfo &info)
+{
+  if (index < 0 || index > GetAudioStreamCount() - 1 )
+    return;
+
+  if (index == GetAudioStream())
+    info.bitrate = m_dvdPlayerAudio.GetAudioBitrate();
+  else
+    info.bitrate = m_pDemuxer->GetStreamFromAudioId(index)->iBitRate;
+
+  SelectionStream& s = m_SelectionStreams.Get(STREAM_AUDIO, index);
+  if(s.language.length() > 0)
+    info.language = s.language;
+
+  if(s.name.length() > 0)
+    info.name = s.name;
+
+  if(s.type == STREAM_NONE)
+    info.name += " (Invalid)";
+
+  if (m_pDemuxer)
+  {
+    CDemuxStreamAudio* stream = static_cast<CDemuxStreamAudio*>(m_pDemuxer->GetStreamFromAudioId(index));
+    if (stream)
+    {
+      info.channels = stream->iChannels;
+      CStdString codecName;
+      m_pDemuxer->GetStreamCodecName(stream->iId, codecName);
+      info.audioCodecName = codecName;
+    }
+  }
+}
 
 int CDVDPlayer::AddSubtitleFile(const std::string& filename, const std::string& subfilename, CDemuxStream::EFlags flags)
 {
@@ -3798,18 +3907,16 @@
 
 void CDVDPlayer::UpdatePlayState(double timeout)
 {
-  if(m_State.timestamp != 0
-  && m_State.timestamp + DVD_MSEC_TO_TIME(timeout) > CDVDClock::GetAbsoluteClock())
+  if(m_StateInput.timestamp != 0
+  && m_StateInput.timestamp + DVD_MSEC_TO_TIME(timeout) > CDVDClock::GetAbsoluteClock())
     return;
 
-  SPlayerState state(m_State);
+  SPlayerState state(m_StateInput);
 
   if     (m_CurrentVideo.dts != DVD_NOPTS_VALUE)
     state.dts = m_CurrentVideo.dts;
   else if(m_CurrentAudio.dts != DVD_NOPTS_VALUE)
     state.dts = m_CurrentAudio.dts;
-  else
-    state.dts = m_clock.GetClock();
 
   if(m_pDemuxer)
   {
@@ -3817,11 +3924,17 @@
     state.chapter_count = m_pDemuxer->GetChapterCount();
     m_pDemuxer->GetChapterName(state.chapter_name);
 
-    state.time       = DVD_TIME_TO_MSEC(m_clock.GetClock() + m_offset_pts);
+    if(state.dts == DVD_NOPTS_VALUE)
+      state.time     = 0;
+    else
+      state.time     = DVD_TIME_TO_MSEC(state.dts + m_offset_pts);
     state.time_total = m_pDemuxer->GetStreamLength();
     state.time_src   = ETIMESOURCE_CLOCK;
   }
 
+  state.canpause     = true;
+  state.canseek      = true;
+
   if(m_pInputStream)
   {
     // override from input stream if needed
@@ -3840,8 +3953,11 @@
       state.time_src   = ETIMESOURCE_INPUT;
     }
 
-    if (dynamic_cast<CDVDInputStream::IMenus*>(m_pInputStream))
+    if (CDVDInputStream::IMenus* ptr = dynamic_cast<CDVDInputStream::IMenus*>(m_pInputStream))
     {
+      if(!ptr->GetState(state.player_state))
+        state.player_state = "";
+
       if(m_dvd.state == DVDSTATE_STILL)
       {
         state.time       = XbmcThreads::SystemClockMillis() - m_dvd.iDVDStillStartTime;
@@ -3850,16 +3966,10 @@
       }
     }
 
-    if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+    if (CDVDInputStream::ISeekable* ptr = dynamic_cast<CDVDInputStream::ISeekable*>(m_pInputStream))
     {
-      CDVDInputStreamPVRManager* pvrinputstream = static_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
-      state.canpause = pvrinputstream->CanPause();
-      state.canseek  = pvrinputstream->CanSeek();
-    }
-    else
-    {
-      state.canseek  = state.time_total > 0 ? true : false;
-      state.canpause = true;
+      state.canpause = ptr->CanPause();
+      state.canseek  = ptr->CanSeek();
     }
   }
 
@@ -3869,16 +3979,12 @@
     state.time_total  = m_Edl.RemoveCutTime(llrint(state.time_total));
   }
 
-  state.player_state = "";
-  if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
-  {
-    if(!((CDVDInputStreamNavigator*)m_pInputStream)->GetNavigatorState(state.player_state))
-      state.player_state = "";
-  }
+  if(state.time_total <= 0)
+    state.canseek  = false;
 
   if (state.time_src == ETIMESOURCE_CLOCK)
-    state.time_offset = 0;
-  else
+    state.time_offset = m_offset_pts;
+  else if (state.dts != DVD_NOPTS_VALUE)
     state.time_offset = DVD_MSEC_TO_TIME(state.time) - state.dts;
 
   if (m_CurrentAudio.id >= 0 && m_pDemuxer)
@@ -3926,7 +4032,7 @@
   state.timestamp = CDVDClock::GetAbsoluteClock();
 
   CSingleLock lock(m_StateSection);
-  m_State = state;
+  m_StateInput = state;
 }
 
 void CDVDPlayer::UpdateApplication(double timeout)
@@ -3971,33 +4077,6 @@
   return false;
 }
 
-int CDVDPlayer::GetChannels()
-{
-  if (m_pDemuxer && (m_CurrentAudio.id != -1))
-  {
-    CDemuxStreamAudio* stream = static_cast<CDemuxStreamAudio*>(m_pDemuxer->GetStream(m_CurrentAudio.id));
-    if (stream)
-      return stream->iChannels;
-  }
-  return -1;
-}
-
-CStdString CDVDPlayer::GetAudioCodecName()
-{
-  CStdString retVal;
-  if (m_pDemuxer && (m_CurrentAudio.id != -1))
-    m_pDemuxer->GetStreamCodecName(m_CurrentAudio.id, retVal);
-  return retVal;
-}
-
-CStdString CDVDPlayer::GetVideoCodecName()
-{
-  CStdString retVal;
-  if (m_pDemuxer && (m_CurrentVideo.id != -1))
-    m_pDemuxer->GetStreamCodecName(m_CurrentVideo.id, retVal);
-  return retVal;
-}
-
 int CDVDPlayer::GetPictureWidth()
 {
   if (m_pDemuxer && (m_CurrentVideo.id != -1))
@@ -4027,8 +4106,18 @@
     bool result=CDVDFileInfo::DemuxerToStreamDetails(m_pInputStream, m_pDemuxer, details);
     if (result && details.GetStreamCount(CStreamDetail::VIDEO) > 0) // this is more correct (dvds in particular)
     {
-      GetVideoAspectRatio(((CStreamDetailVideo*)details.GetNthStream(CStreamDetail::VIDEO,0))->m_fAspect);
-      ((CStreamDetailVideo*)details.GetNthStream(CStreamDetail::VIDEO,0))->m_iDuration = GetTotalTime() / 1000;
+      /* 
+       * We can only obtain the aspect & duration from dvdplayer when the Process() thread is running
+       * and UpdatePlayState() has been called at least once. In this case dvdplayer duration/AR will
+       * return 0 and we'll have to fallback to the (less accurate) info from the demuxer.
+       */
+      float aspect = m_dvdPlayerVideo.GetAspectRatio();
+      if (aspect > 0.0f)
+        ((CStreamDetailVideo*)details.GetNthStream(CStreamDetail::VIDEO,0))->m_fAspect = aspect;
+
+      int64_t duration = GetTotalTime() / 1000;
+      if (duration > 0)
+        ((CStreamDetailVideo*)details.GetNthStream(CStreamDetail::VIDEO,0))->m_iDuration = duration;
     }
     return result;
   }
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayer.h xbmc/xbmc/cores/dvdplayer/DVDPlayer.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayer.h	2013-04-05 17:12:13.807112379 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDPlayer.h	2013-04-05 17:19:30.079106228 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -65,6 +65,7 @@
   int              source;
   double           dts;    // last dts from demuxer, used to find disncontinuities
   double           dur;    // last frame expected duration
+  double           dts_state; // when did we last send a playback state update
   CDVDStreamInfo   hint;   // stream hints, used to notice stream changes
   void*            stream; // pointer or integer, identifying stream playing. if it changes stream changed
   int              changes; // remembered counter from stream to track codec changes
@@ -87,6 +88,7 @@
     id     = -1;
     source = STREAM_SOURCE_NONE;
     dts    = DVD_NOPTS_VALUE;
+    dts_state = DVD_NOPTS_VALUE;
     dur    = DVD_NOPTS_VALUE;
     hint.Clear();
     stream = NULL;
@@ -191,8 +193,6 @@
   virtual void GetVideoInfo(CStdString& strVideoInfo);
   virtual void GetGeneralInfo( CStdString& strVideoInfo);
   virtual void Update(bool bPauseDrawing)                       { m_dvdPlayerVideo.Update(bPauseDrawing); }
-  virtual void GetVideoRect(CRect& SrcRect, CRect& DestRect)    { m_dvdPlayerVideo.GetVideoRect(SrcRect, DestRect); }
-  virtual void GetVideoAspectRatio(float& fAR)                  { fAR = m_dvdPlayerVideo.GetAspectRatio(); }
   virtual bool CanRecord();
   virtual bool IsRecording();
   virtual bool CanPause();
@@ -204,19 +204,15 @@
   virtual float GetSubTitleDelay();
   virtual int GetSubtitleCount();
   virtual int GetSubtitle();
-  virtual void GetSubtitleName(int iStream, CStdString &strStreamName);
-  virtual void GetSubtitleLanguage(int iStream, CStdString &strStreamLang);
+  virtual void GetSubtitleStreamInfo(int index, SPlayerSubtitleStreamInfo &info);
   virtual void SetSubtitle(int iStream);
   virtual bool GetSubtitleVisible();
   virtual void SetSubtitleVisible(bool bVisible);
-  virtual bool GetSubtitleExtension(CStdString &strSubtitleExtension) { return false; }
   virtual int  AddSubtitle(const CStdString& strSubPath);
 
   virtual int GetAudioStreamCount();
   virtual int GetAudioStream();
-  virtual void GetAudioStreamName(int iStream, CStdString &strStreamName);
   virtual void SetAudioStream(int iStream);
-  virtual void GetAudioStreamLanguage(int iStream, CStdString &strLanguage);
 
   virtual TextCacheStruct_t* GetTeletextCache();
   virtual void LoadPage(int p, int sp, unsigned char* buffer);
@@ -232,15 +228,13 @@
   virtual void ToFFRW(int iSpeed);
   virtual bool OnAction(const CAction &action);
   virtual bool HasMenu();
-  virtual int GetAudioBitrate();
-  virtual int GetVideoBitrate();
+
   virtual int GetSourceBitrate();
-  virtual int GetChannels();
-  virtual CStdString GetAudioCodecName();
-  virtual CStdString GetVideoCodecName();
+  virtual void GetVideoStreamInfo(SPlayerVideoStreamInfo &info);
   virtual int GetPictureWidth();
   virtual int GetPictureHeight();
   virtual bool GetStreamDetails(CStreamDetails &details);
+  virtual void GetAudioStreamInfo(int index, SPlayerAudioStreamInfo &info);
 
   virtual bool GetCurrentSubtitle(CStdString& strSubtitle);
 
@@ -407,11 +401,15 @@
     ETIMESOURCE_MENU,
   };
 
+  friend class CDVDPlayerVideo;
+  friend class CDVDPlayerAudio;
+
   struct SPlayerState
   {
     SPlayerState() { Clear(); }
     void Clear()
     {
+      player        = 0;
       timestamp     = 0;
       time          = 0;
       time_total    = 0;
@@ -434,6 +432,8 @@
       cache_offset  = 0.0;
     }
 
+    int    player;            // source of this data
+
     double timestamp;         // last time of update
     double time_offset;       // difference between time and pts
 
@@ -461,7 +461,7 @@
     double  cache_level;   // current estimated required cache level
     double  cache_delay;   // time until cache is expected to reach estimated level
     double  cache_offset;  // percentage of file ahead of current position
-  } m_State;
+  } m_State, m_StateInput;
   CCriticalSection m_StateSection;
 
   CEvent m_ready;
@@ -489,4 +489,7 @@
   } m_EdlAutoSkipMarkers;
 
   CPlayerOptions m_PlayerOptions;
+
+  bool m_HasVideo;
+  bool m_HasAudio;
 };
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp xbmc/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp	2013-02-16 18:48:38.554390065 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp	2013-04-05 11:38:43.966813722 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -63,7 +63,7 @@
   CSingleLock lock(m_sync);
 
   IT it = m_list.begin();
-  for(; it != m_list.end(); it++)
+  for(; it != m_list.end(); ++it)
   {
     if(bytes <= it->first)
     {
@@ -284,7 +284,7 @@
         CLog::Log(LOGERROR, "CDVDPlayerAudio:DecodeFrame - Codec tried to consume more data than available. Potential memory corruption");
         m_decode.Release();
         m_pAudioCodec->Reset();
-        assert(0);
+        return DECODE_FLAG_ERROR;
       }
 
       m_decode.data += len;
@@ -368,7 +368,7 @@
     if (ret == MSGQ_TIMEOUT)
       return DECODE_FLAG_TIMEOUT;
 
-    if (MSGQ_IS_ERROR(ret) || ret == MSGQ_ABORT)
+    if (MSGQ_IS_ERROR(ret))
       return DECODE_FLAG_ABORT;
 
     if (pMsg->IsType(CDVDMsg::DEMUXER_PACKET))
@@ -425,6 +425,17 @@
       if(m_started)
         m_messageParent.Put(new CDVDMsgInt(CDVDMsg::PLAYER_STARTED, DVDPLAYER_AUDIO));
     }
+    else if (pMsg->IsType(CDVDMsg::PLAYER_DISPLAYTIME))
+    {
+      CDVDPlayer::SPlayerState& state = ((CDVDMsgType<CDVDPlayer::SPlayerState>*)pMsg)->m_value;
+
+      if(state.time_src == CDVDPlayer::ETIMESOURCE_CLOCK)
+        state.time      = DVD_TIME_TO_MSEC(m_pClock->GetClock(state.timestamp) + state.time_offset);
+      else
+        state.timestamp = CDVDClock::GetAbsoluteClock();
+      state.player    = DVDPLAYER_AUDIO;
+      m_messageParent.Put(pMsg->Acquire());
+    }
     else if (pMsg->IsType(CDVDMsg::GENERAL_EOF))
     {
       CLog::Log(LOGDEBUG, "CDVDPlayerAudio - CDVDMsg::GENERAL_EOF");
@@ -769,12 +780,12 @@
   }
   else if (m_synctype == SYNC_RESAMPLE)
   {
-    double proportional = 0.0, proportionaldiv;
+    double proportional = 0.0;
 
     //on big errors use more proportional
     if (fabs(m_error / DVD_TIME_BASE) > 0.0)
     {
-      proportionaldiv = PROPORTIONAL * (PROPREF / fabs(m_error / DVD_TIME_BASE));
+      double proportionaldiv = PROPORTIONAL * (PROPREF / fabs(m_error / DVD_TIME_BASE));
       if (proportionaldiv < PROPDIVMIN) proportionaldiv = PROPDIVMIN;
       else if (proportionaldiv > PROPDIVMAX) proportionaldiv = PROPDIVMAX;
 
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayerAudio.h xbmc/xbmc/cores/dvdplayer/DVDPlayerAudio.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayerAudio.h	2013-02-16 18:48:38.554390065 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDPlayerAudio.h	2013-02-10 14:23:18.666512296 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayerAudioResampler.cpp xbmc/xbmc/cores/dvdplayer/DVDPlayerAudioResampler.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayerAudioResampler.cpp	2013-02-16 18:48:38.554390065 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDPlayerAudioResampler.cpp	2013-04-05 11:38:43.966813722 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -142,11 +142,29 @@
 {
   if (m_buffersize < nrframes)
   {
-    m_buffersize = nrframes * 2;
-    m_buffer = (float*)realloc(m_buffer, m_buffersize * m_nrchannels * sizeof(float));
-    m_ptsbuffer = (double*)realloc(m_ptsbuffer, m_buffersize * sizeof(double));
+    int newBufferSize = nrframes * 2;
+    float* newBuffer = (float*)realloc(m_buffer, newBufferSize * m_nrchannels * sizeof(float));
+    if (newBuffer)
+    {
+      m_buffer = newBuffer;
+      m_buffersize = newBufferSize;
+
+      double* newPtsBuffer = (double*)realloc(m_ptsbuffer, m_buffersize * sizeof(double));
+      if (newPtsBuffer)
+      {
+        m_ptsbuffer = newPtsBuffer;
     CLog::Log(LOGDEBUG, "CDVDPlayerResampler: resized buffers to hold %i frames", m_buffersize);
   }
+      else
+      {
+        CLog::Log(LOGERROR, "ResizeSampleBuffer - %s - failed : could not realloc the buffer m_ptsbuffer", __FUNCTION__);
+      }
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "ResizeSampleBuffer - %s - failed : could not realloc the buffer m_buffer", __FUNCTION__);
+    }
+  }
 }
 
 void CDVDPlayerResampler::SetRatio(double ratio)
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayerAudioResampler.h xbmc/xbmc/cores/dvdplayer/DVDPlayerAudioResampler.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayerAudioResampler.h	2013-02-16 18:48:38.564389866 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDPlayerAudioResampler.h	2013-02-10 14:23:18.666512296 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayerSubtitle.cpp xbmc/xbmc/cores/dvdplayer/DVDPlayerSubtitle.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayerSubtitle.cpp	2013-03-11 02:09:46.450993799 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDPlayerSubtitle.cpp	2013-04-05 11:38:43.966813722 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -246,7 +246,7 @@
   VecOverlays* pOverlays = m_pOverlayContainer->GetOverlays();
   if (pOverlays)
   {
-    for(vector<CDVDOverlay*>::iterator it = pOverlays->begin();it != pOverlays->end();it++)
+    for(vector<CDVDOverlay*>::iterator it = pOverlays->begin();it != pOverlays->end();++it)
     {
       CDVDOverlay* pOverlay = *it;
 
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayerSubtitle.h xbmc/xbmc/cores/dvdplayer/DVDPlayerSubtitle.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayerSubtitle.h	2013-02-16 18:48:38.564389866 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDPlayerSubtitle.h	2013-02-10 14:23:18.676512102 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayerTeletext.cpp xbmc/xbmc/cores/dvdplayer/DVDPlayerTeletext.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayerTeletext.cpp	2013-02-16 18:48:38.564389866 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDPlayerTeletext.cpp	2013-04-05 11:38:43.976813542 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -254,7 +254,7 @@
       continue;
     }
 
-    if (MSGQ_IS_ERROR(ret) || ret == MSGQ_ABORT)
+    if (MSGQ_IS_ERROR(ret))
     {
       CLog::Log(LOGERROR, "Got MSGQ_ABORT or MSGO_IS_ERROR return true (%i)", ret);
       break;
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayerTeletext.h xbmc/xbmc/cores/dvdplayer/DVDPlayerTeletext.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayerTeletext.h	2013-02-16 18:48:38.564389866 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDPlayerTeletext.h	2013-02-10 14:23:18.676512102 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp xbmc/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp	2013-02-16 18:48:38.574389668 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp	2013-04-05 11:38:43.976813542 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -23,6 +23,7 @@
 #include "windowing/WindowingFactory.h"
 #include "settings/AdvancedSettings.h"
 #include "settings/GUISettings.h"
+#include "settings/MediaSettings.h"
 #include "settings/Settings.h"
 #include "video/VideoReferenceClock.h"
 #include "utils/MathUtils.h"
@@ -91,7 +92,7 @@
 
   bool enabled()
   {
-    return m_pattern.size() > 0;
+    return !m_pattern.empty();
   }
 private:
   double                     m_duration;
@@ -336,7 +337,7 @@
     CDVDMsg* pMsg;
     MsgQueueReturnCode ret = m_messageQueue.Get(&pMsg, iQueueTimeOut, iPriority);
 
-    if (MSGQ_IS_ERROR(ret) || ret == MSGQ_ABORT)
+    if (MSGQ_IS_ERROR(ret))
     {
       CLog::Log(LOGERROR, "Got MSGQ_ABORT or MSGO_IS_ERROR return true");
       break;
@@ -465,12 +466,25 @@
       m_speed = static_cast<CDVDMsgInt*>(pMsg)->m_value;
       if(m_speed == DVD_PLAYSPEED_PAUSE)
         m_iNrOfPicturesNotToSkip = 0;
+      if (m_pVideoCodec)
+        m_pVideoCodec->SetSpeed(m_speed);
     }
     else if (pMsg->IsType(CDVDMsg::PLAYER_STARTED))
     {
       if(m_started)
         m_messageParent.Put(new CDVDMsgInt(CDVDMsg::PLAYER_STARTED, DVDPLAYER_VIDEO));
     }
+    else if (pMsg->IsType(CDVDMsg::PLAYER_DISPLAYTIME))
+    {
+      CDVDPlayer::SPlayerState& state = ((CDVDMsgType<CDVDPlayer::SPlayerState>*)pMsg)->m_value;
+
+      if(state.time_src == CDVDPlayer::ETIMESOURCE_CLOCK)
+        state.time      = DVD_TIME_TO_MSEC(m_pClock->GetClock(state.timestamp) + state.time_offset);
+      else
+        state.timestamp = CDVDClock::GetAbsoluteClock();
+      state.player    = DVDPLAYER_VIDEO;
+      m_messageParent.Put(pMsg->Acquire());
+    }
     else if (pMsg->IsType(CDVDMsg::GENERAL_STREAMCHANGE))
     {
       CDVDMsgVideoCodecChange* msg(static_cast<CDVDMsgVideoCodecChange*>(pMsg));
@@ -522,8 +536,8 @@
       m_pVideoCodec->SetDropState(bRequestDrop);
 
       // ask codec to do deinterlacing if possible
-      EDEINTERLACEMODE mDeintMode = g_settings.m_currentVideoSettings.m_DeinterlaceMode;
-      EINTERLACEMETHOD mInt       = g_renderManager.AutoInterlaceMethod(g_settings.m_currentVideoSettings.m_InterlaceMethod);
+      EDEINTERLACEMODE mDeintMode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+      EINTERLACEMETHOD mInt       = g_renderManager.AutoInterlaceMethod(CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod);
 
       unsigned int     mFilters = 0;
 
@@ -645,7 +659,7 @@
               }
             }
 
-            if (g_settings.m_currentVideoSettings.m_PostProcess)
+            if (CMediaSettings::Get().GetCurrentVideoSettings().m_PostProcess)
             {
               if (!sPostProcessType.empty())
                 sPostProcessType += ",";
@@ -1283,19 +1297,19 @@
 
   if( m_speed != DVD_PLAYSPEED_NORMAL && limited )
   {
+    m_droptime += iFrameDuration;
+#ifndef PROFILE
     // calculate frame dropping pattern to render at this speed
     // we do that by deciding if this or next frame is closest
     // to the flip timestamp
     double current   = fabs(m_dropbase -  m_droptime);
     double next      = fabs(m_dropbase - (m_droptime + iFrameDuration));
-    double frametime = (double)DVD_TIME_BASE / maxfps;
 
-    m_droptime += iFrameDuration;
-#ifndef PROFILE
     if( next < current && !(pPicture->iFlags & DVP_FLAG_NOSKIP) )
       return result | EOS_DROPPED;
 #endif
 
+    double frametime = (double)DVD_TIME_BASE / maxfps;
     while(!m_bStop && m_dropbase < m_droptime)             m_dropbase += frametime;
     while(!m_bStop && m_dropbase - frametime > m_droptime) m_dropbase -= frametime;
 
@@ -1351,7 +1365,7 @@
   {
     RECT crop;
 
-    if (g_settings.m_currentVideoSettings.m_Crop)
+    if (CMediaSettings::Get().GetCurrentVideoSettings().m_Crop)
       AutoCrop(pPicture, crop);
     else
     { // reset to defaults
@@ -1373,16 +1387,16 @@
 
     //compare with hysteresis
 # define HYST(n, o) ((n) > (o) || (n) + 1 < (o))
-    if(HYST(g_settings.m_currentVideoSettings.m_CropLeft  , crop.left)
-    || HYST(g_settings.m_currentVideoSettings.m_CropRight , crop.right)
-    || HYST(g_settings.m_currentVideoSettings.m_CropTop   , crop.top)
-    || HYST(g_settings.m_currentVideoSettings.m_CropBottom, crop.bottom))
-    {
-      g_settings.m_currentVideoSettings.m_CropLeft   = crop.left;
-      g_settings.m_currentVideoSettings.m_CropRight  = crop.right;
-      g_settings.m_currentVideoSettings.m_CropTop    = crop.top;
-      g_settings.m_currentVideoSettings.m_CropBottom = crop.bottom;
-      g_renderManager.SetViewMode(g_settings.m_currentVideoSettings.m_ViewMode);
+    if(HYST(CMediaSettings::Get().GetCurrentVideoSettings().m_CropLeft  , crop.left)
+    || HYST(CMediaSettings::Get().GetCurrentVideoSettings().m_CropRight , crop.right)
+    || HYST(CMediaSettings::Get().GetCurrentVideoSettings().m_CropTop   , crop.top)
+    || HYST(CMediaSettings::Get().GetCurrentVideoSettings().m_CropBottom, crop.bottom))
+    {
+      CMediaSettings::Get().GetCurrentVideoSettings().m_CropLeft   = crop.left;
+      CMediaSettings::Get().GetCurrentVideoSettings().m_CropRight  = crop.right;
+      CMediaSettings::Get().GetCurrentVideoSettings().m_CropTop    = crop.top;
+      CMediaSettings::Get().GetCurrentVideoSettings().m_CropBottom = crop.bottom;
+      g_renderManager.SetViewMode(CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode);
     }
 # undef HYST
   }
@@ -1390,10 +1404,10 @@
 
 void CDVDPlayerVideo::AutoCrop(DVDVideoPicture *pPicture, RECT &crop)
 {
-  crop.left   = g_settings.m_currentVideoSettings.m_CropLeft;
-  crop.right  = g_settings.m_currentVideoSettings.m_CropRight;
-  crop.top    = g_settings.m_currentVideoSettings.m_CropTop;
-  crop.bottom = g_settings.m_currentVideoSettings.m_CropBottom;
+  crop.left   = CMediaSettings::Get().GetCurrentVideoSettings().m_CropLeft;
+  crop.right  = CMediaSettings::Get().GetCurrentVideoSettings().m_CropRight;
+  crop.top    = CMediaSettings::Get().GetCurrentVideoSettings().m_CropTop;
+  crop.bottom = CMediaSettings::Get().GetCurrentVideoSettings().m_CropBottom;
 
   int black  = 16; // what is black in the image
   int level  = 8;  // how high above this should we detect
@@ -1548,7 +1562,7 @@
   m_iFrameRateLength = 1;
   m_iFrameRateErr    = 0;
 
-  m_bAllowDrop       = (!m_bCalcFrameRate && g_settings.m_currentVideoSettings.m_ScalingMethod != VS_SCALINGMETHOD_AUTO) ||
+  m_bAllowDrop       = (!m_bCalcFrameRate && CMediaSettings::Get().GetCurrentVideoSettings().m_ScalingMethod != VS_SCALINGMETHOD_AUTO) ||
                         g_advancedSettings.m_videoFpsDetect == 0;
 }
 
@@ -1562,7 +1576,7 @@
 
   //only calculate the framerate if sync playback to display is on, adjust refreshrate is on,
   //or scaling method is set to auto
-  if (!m_bCalcFrameRate && g_settings.m_currentVideoSettings.m_ScalingMethod != VS_SCALINGMETHOD_AUTO)
+  if (!m_bCalcFrameRate && CMediaSettings::Get().GetCurrentVideoSettings().m_ScalingMethod != VS_SCALINGMETHOD_AUTO)
   {
     ResetFrameRateCalc();
     return;
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayerVideo.h xbmc/xbmc/cores/dvdplayer/DVDPlayerVideo.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDPlayerVideo.h	2013-02-16 18:48:38.574389668 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDPlayerVideo.h	2013-02-10 14:23:18.686511908 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDResource.h xbmc/xbmc/cores/dvdplayer/DVDResource.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDResource.h	2013-02-16 18:48:38.574389668 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDResource.h	2013-02-10 14:23:18.686511908 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDStreamInfo.cpp xbmc/xbmc/cores/dvdplayer/DVDStreamInfo.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDStreamInfo.cpp	2013-02-16 18:48:38.574389668 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDStreamInfo.cpp	2013-04-05 11:38:43.976813542 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -155,6 +155,8 @@
   forced_aspect = right.forced_aspect;
   orientation = right.orientation;
   bitsperpixel = right.bitsperpixel;
+  vfr = right.vfr;
+  software = right.software;
 
   // AUDIO
   channels      = right.channels;
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDStreamInfo.h xbmc/xbmc/cores/dvdplayer/DVDStreamInfo.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDStreamInfo.h	2013-02-16 18:48:38.574389668 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDStreamInfo.h	2013-04-05 11:38:43.976813542 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -96,6 +96,9 @@
 
   bool operator==(const CDVDStreamInfo& right)      { return Equal(right, true);}
   bool operator!=(const CDVDStreamInfo& right)      { return !Equal(right, true);}
+
+  //'CDVDStreamInfo::operator=' should return 'CDVDStreamInfo &'.
+  // Is this intended? It looks more like a copy,cf. extradata, what happens if info = info?
   void operator=(const CDVDStreamInfo& right)       { Assign(right, true); }
 
   bool operator==(const CDemuxStream& right)      { return Equal( CDVDStreamInfo(right, true), true);}
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDFactorySubtitle.cpp xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDFactorySubtitle.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDFactorySubtitle.cpp	2013-02-16 18:48:38.574389668 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDFactorySubtitle.cpp	2013-02-10 14:23:18.686511908 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDFactorySubtitle.h xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDFactorySubtitle.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDFactorySubtitle.h	2013-02-16 18:48:38.574389668 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDFactorySubtitle.h	2013-02-10 14:23:18.686511908 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleLineCollection.cpp xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleLineCollection.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleLineCollection.cpp	2013-02-16 18:48:38.574389668 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleLineCollection.cpp	2013-02-10 14:23:18.696511714 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleLineCollection.h xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleLineCollection.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleLineCollection.h	2013-02-16 18:48:38.584389470 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleLineCollection.h	2013-02-10 14:23:18.696511714 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParser.h xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParser.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParser.h	2013-03-11 02:09:46.450993799 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParser.h	2013-04-05 11:38:43.976813542 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -42,10 +42,7 @@
   : public CDVDSubtitleParser
 {
 public:
-  CDVDSubtitleParserCollection(const std::string& strFile)
-  {
-    m_filename = strFile;
-  }
+  CDVDSubtitleParserCollection(const std::string& strFile) : m_filename(strFile) {}
   virtual ~CDVDSubtitleParserCollection() { }
   virtual CDVDOverlay* Parse(double iPts)
   {
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserMPL2.cpp xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserMPL2.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserMPL2.cpp	2013-02-16 18:48:38.584389470 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserMPL2.cpp	2013-02-10 14:23:18.696511714 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserMPL2.h xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserMPL2.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserMPL2.h	2013-02-16 18:48:38.584389470 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserMPL2.h	2013-02-10 14:23:18.696511714 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserMicroDVD.cpp xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserMicroDVD.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserMicroDVD.cpp	2013-02-16 18:48:38.584389470 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserMicroDVD.cpp	2013-02-10 14:23:18.696511714 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserMicroDVD.h xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserMicroDVD.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserMicroDVD.h	2013-02-16 18:48:38.584389470 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserMicroDVD.h	2013-02-10 14:23:18.696511714 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSSA.cpp xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSSA.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSSA.cpp	2013-02-16 18:48:38.584389470 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSSA.cpp	2013-02-10 14:23:18.696511714 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSSA.h xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSSA.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSSA.h	2013-02-16 18:48:38.584389470 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSSA.h	2013-02-10 14:23:18.696511714 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSami.cpp xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSami.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSami.cpp	2013-02-16 18:48:38.584389470 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSami.cpp	2013-02-10 14:23:18.696511714 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSami.h xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSami.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSami.h	2013-02-16 18:48:38.584389470 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSami.h	2013-02-10 14:23:18.706511520 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSubrip.cpp xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSubrip.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSubrip.cpp	2013-02-16 18:48:38.584389470 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSubrip.cpp	2013-02-10 14:23:18.706511520 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSubrip.h xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSubrip.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSubrip.h	2013-02-16 18:48:38.594389272 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserSubrip.h	2013-02-10 14:23:18.706511520 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserVplayer.cpp xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserVplayer.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserVplayer.cpp	2013-02-16 18:48:38.594389272 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserVplayer.cpp	2013-02-10 14:23:18.706511520 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserVplayer.h xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserVplayer.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserVplayer.h	2013-02-16 18:48:38.594389272 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleParserVplayer.h	2013-02-10 14:23:18.706511520 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleStream.cpp xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleStream.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleStream.cpp	2013-02-16 18:48:38.594389272 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleStream.cpp	2013-02-10 14:23:18.706511520 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleStream.h xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleStream.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleStream.h	2013-02-16 18:48:38.594389272 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleStream.h	2013-02-10 14:23:18.706511520 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagMicroDVD.cpp xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagMicroDVD.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagMicroDVD.cpp	2013-02-16 18:48:38.594389272 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagMicroDVD.cpp	2013-03-31 15:25:11.619996868 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -20,6 +20,7 @@
 
 #include "DVDSubtitleTagMicroDVD.h"
 #include "DVDCodecs/Overlay/DVDOverlayText.h"
+#include "utils/StdString.h"
 
 void CDVDSubtitleTagMicroDVD::ConvertLine(CDVDOverlayText* pOverlay, const char* line, int len)
 {
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagMicroDVD.h xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagMicroDVD.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagMicroDVD.h	2013-02-16 18:48:38.594389272 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagMicroDVD.h	2013-04-05 11:38:43.986813361 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -20,6 +20,7 @@
  *
  */
 #include <stdio.h>
+#include <string.h>
 
 #define FLAG_BOLD   0
 #define FLAG_ITALIC 1
@@ -33,6 +34,10 @@
 class CDVDSubtitleTagMicroDVD
 {
 public:
+  CDVDSubtitleTagMicroDVD()
+  {
+    memset(&m_flag, 0, sizeof(m_flag));
+  }
   void ConvertLine(CDVDOverlayText* pOverlay, const char* line, int len);
 
 private:
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagSami.cpp xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagSami.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagSami.cpp	2013-02-16 18:48:38.594389272 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagSami.cpp	2013-04-05 11:38:43.986813361 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -31,6 +31,8 @@
 
 bool CDVDSubtitleTagSami::Init()
 {
+  delete m_tags;
+  delete m_tagOptions;
   m_tags = new CRegExp(true);
   if (!m_tags->RegComp("(<[^>]*>|\\{[^\\}]*\\})"))
     return false;
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagSami.h xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagSami.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagSami.h	2013-02-16 18:48:38.604389074 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagSami.h	2013-02-10 14:23:18.716511326 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitlesLibass.cpp xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitlesLibass.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitlesLibass.cpp	2013-02-16 18:48:38.604389074 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitlesLibass.cpp	2013-02-10 14:23:18.716511326 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitlesLibass.h xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitlesLibass.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitlesLibass.h	2013-02-16 18:48:38.604389074 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitlesLibass.h	2013-02-10 14:23:18.716511326 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DllLibass.h xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DllLibass.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDSubtitles/DllLibass.h	2013-02-16 18:48:38.604389074 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDSubtitles/DllLibass.h	2013-02-10 14:23:18.716511326 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDTSCorrection.cpp xbmc/xbmc/cores/dvdplayer/DVDTSCorrection.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDTSCorrection.cpp	2013-02-16 18:48:38.604389074 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDTSCorrection.cpp	2013-04-05 11:38:43.986813361 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -176,7 +176,7 @@
     }
   }
 
-  bool checkexisting = m_pattern.size() > 0;
+  bool checkexisting = !m_pattern.empty();
 
   //we check for patterns to the length of DIFFRINGSIZE / 2
   for (int i = 1; i <= m_ringfill / 2; i++)
@@ -272,7 +272,7 @@
 bool CPullupCorrection::CheckPattern(std::vector<double>& pattern)
 {
   //if no pattern was detected or if the size of the patterns differ we don't have a match
-  if (pattern.size() != m_pattern.size() || pattern.size() < 1)
+  if (pattern.empty() || pattern.size() != m_pattern.size())
     return false;
 
   if (pattern.size() == 1)
@@ -299,7 +299,7 @@
 //calculate how long each frame should last from the saved pattern
 double CPullupCorrection::CalcFrameDuration()
 {
-  if (m_pattern.size() > 0)
+  if (!m_pattern.empty())
   {
     //take the average of all diffs in the pattern
     double frameduration = 0.0;
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/DVDTSCorrection.h xbmc/xbmc/cores/dvdplayer/DVDTSCorrection.h
--- xbmcfrodo/xbmc/cores/dvdplayer/DVDTSCorrection.h	2013-02-16 18:48:38.604389074 +0000
+++ xbmc/xbmc/cores/dvdplayer/DVDTSCorrection.h	2013-02-10 14:23:18.726511131 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/Edl.cpp xbmc/xbmc/cores/dvdplayer/Edl.cpp
--- xbmcfrodo/xbmc/cores/dvdplayer/Edl.cpp	2013-02-16 18:48:38.614388875 +0000
+++ xbmc/xbmc/cores/dvdplayer/Edl.cpp	2013-04-05 11:38:43.986813361 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -28,6 +28,8 @@
 #include "utils/XBMCTinyXML.h"
 #include "PlatformDefs.h"
 #include "URL.h"
+#include "pvr/recordings/PVRRecordings.h"
+#include "pvr/PVRManager.h"
 
 extern "C"
 {
@@ -152,6 +154,17 @@
     bFound |= ReadMythCutList(strMovie, fFramesPerSecond);
   }
 
+  /*
+   * PVR Recordings
+   */
+  else if (URIUtils::IsPVRRecording(strMovie))
+  {
+    CLog::Log(LOGDEBUG, "%s - Checking for edit decision list (EDL) for PVR recording: %s",
+      __FUNCTION__, strMovie.c_str());
+
+    bFound = ReadPvr(strMovie);
+  }
+
   if (bFound)
   {
     MergeShortCommBreaks();
@@ -585,6 +598,71 @@
   }
 }
 
+bool CEdl::ReadPvr(const CStdString &strMovie)
+{
+  if (!PVR::g_PVRManager.IsStarted())
+  {
+    CLog::Log(LOGERROR, "%s - PVR Manager not started, cannot read Edl for %s", __FUNCTION__, strMovie.c_str());
+    return false;
+  }
+
+  CFileItemPtr tag =  PVR::g_PVRRecordings->GetByPath(strMovie);
+  if (tag && tag->HasPVRRecordingInfoTag())
+  {
+    CLog::Log(LOGDEBUG, "%s - Reading Edl for recording: %s", __FUNCTION__, tag->GetPVRRecordingInfoTag()->m_strTitle.c_str());
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "%s - Unable to find PVR recording: %s", __FUNCTION__, strMovie.c_str());
+    return false;
+  }
+
+  std::vector<PVR_EDL_ENTRY> edl = tag->GetPVRRecordingInfoTag()->GetEdl();
+  std::vector<PVR_EDL_ENTRY>::const_iterator it;
+  for (it = edl.begin(); it != edl.end(); ++it)
+  {
+    Cut cut;
+    cut.start = it->start;
+    cut.end = it->end;
+
+    switch (it->type)
+    {
+    case PVR_EDL_TYPE_CUT:
+      cut.action = CUT;
+      break;
+    case PVR_EDL_TYPE_MUTE:
+      cut.action = MUTE;
+      break;
+    case PVR_EDL_TYPE_SCENE:
+      //cut.action = SCENE;
+      //break;
+      CLog::Log(LOGINFO, "%s - Ignoring entry of type SCENE", __FUNCTION__);
+      continue;
+    case PVR_EDL_TYPE_COMBREAK:
+      cut.action = COMM_BREAK;
+      break;
+    default:
+      CLog::Log(LOGINFO, "%s - Ignoring entry of unknown type: %d", __FUNCTION__, it->type);
+      continue;
+    }
+
+    if (AddCut(cut))
+    {
+      CLog::Log(LOGDEBUG, "%s - Added break [%s - %s] found in PVRRecording for: %s.",
+        __FUNCTION__, MillisecondsToTimeString(cut.start).c_str(),
+        MillisecondsToTimeString(cut.end).c_str(), strMovie.c_str());
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "%s - Invalid break [%s - %s] found in PVRRecording for: %s. Continuing anyway.",
+        __FUNCTION__, MillisecondsToTimeString(cut.start).c_str(),
+        MillisecondsToTimeString(cut.end).c_str(), strMovie.c_str());
+    }
+  }
+
+ return !edl.empty();
+}
+
 bool CEdl::AddCut(Cut& cut)
 {
   if (cut.action != CUT && cut.action != MUTE && cut.action != COMM_BREAK)
@@ -659,7 +737,7 @@
   else
   {
     vector<Cut>::iterator pCurrentCut;
-    for (pCurrentCut = m_vecCuts.begin(); pCurrentCut != m_vecCuts.end(); pCurrentCut++)
+    for (pCurrentCut = m_vecCuts.begin(); pCurrentCut != m_vecCuts.end(); ++pCurrentCut)
     {
       if (cut.start < pCurrentCut->start)
       {
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/Edl.h xbmc/xbmc/cores/dvdplayer/Edl.h
--- xbmcfrodo/xbmc/cores/dvdplayer/Edl.h	2013-02-16 18:48:38.614388875 +0000
+++ xbmc/xbmc/cores/dvdplayer/Edl.h	2013-03-07 01:49:47.752585154 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -74,6 +74,7 @@
   bool ReadComskip(const CStdString& strMovie, const float fFramesPerSecond);
   bool ReadVideoReDo(const CStdString& strMovie);
   bool ReadBeyondTV(const CStdString& strMovie);
+  bool ReadPvr(const CStdString& strMovie);
   bool ReadMythCommBreakList(const CStdString& strMovie, const float fFramesPerSecond);
   bool ReadMythCutList(const CStdString& strMovie, const float fFramesPerSecond);
 
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/IDVDPlayer.h xbmc/xbmc/cores/dvdplayer/IDVDPlayer.h
--- xbmcfrodo/xbmc/cores/dvdplayer/IDVDPlayer.h	2013-02-16 18:48:38.614388875 +0000
+++ xbmc/xbmc/cores/dvdplayer/IDVDPlayer.h	2013-02-10 14:23:18.726511131 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/dvdplayer/dvd_config.h xbmc/xbmc/cores/dvdplayer/dvd_config.h
--- xbmcfrodo/xbmc/cores/dvdplayer/dvd_config.h	2013-02-16 18:48:38.614388875 +0000
+++ xbmc/xbmc/cores/dvdplayer/dvd_config.h	2013-02-10 14:23:18.726511131 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/omxplayer/DllOMX.h xbmc/xbmc/cores/omxplayer/DllOMX.h
--- xbmcfrodo/xbmc/cores/omxplayer/DllOMX.h	2013-04-05 17:03:23.076628283 +0000
+++ xbmc/xbmc/cores/omxplayer/DllOMX.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,122 +0,0 @@
-#pragma once
-/*
- *      Copyright (C) 2005-2012 Team XBMC
- *      http://www.xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if defined(HAVE_OMXLIB)
-
-#if (defined HAVE_CONFIG_H) && (!defined WIN32)
-  #include "config.h"
-#endif
-#ifndef __GNUC__
-#pragma warning(push)
-#pragma warning(disable:4244)
-#endif
-
-#include "DynamicDll.h"
-#include "utils/log.h"
-
-#include <IL/OMX_Core.h>
-#include <IL/OMX_Component.h>
-#include <IL/OMX_Index.h>
-#include <IL/OMX_Image.h>
-#include <IL/OMX_Video.h>
-#include <IL/OMX_Broadcom.h>
-
-////////////////////////////////////////////////////////////////////////////////////////////
-
-class DllOMXInterface
-{
-public:
-  virtual ~DllOMXInterface() {}
-
-  virtual OMX_ERRORTYPE OMX_Init(void) = 0;
-  virtual OMX_ERRORTYPE OMX_Deinit(void) = 0;
-  virtual OMX_ERRORTYPE OMX_GetHandle(OMX_HANDLETYPE *pHandle, OMX_STRING cComponentName, OMX_PTR pAppData, OMX_CALLBACKTYPE *pCallBacks) = 0;
-  virtual OMX_ERRORTYPE OMX_FreeHandle(OMX_HANDLETYPE hComponent) = 0;
-  virtual OMX_ERRORTYPE OMX_GetComponentsOfRole(OMX_STRING role, OMX_U32 *pNumComps, OMX_U8 **compNames) = 0;
-  virtual OMX_ERRORTYPE OMX_GetRolesOfComponent(OMX_STRING compName, OMX_U32 *pNumRoles, OMX_U8 **roles) = 0;
-  virtual OMX_ERRORTYPE OMX_ComponentNameEnum(OMX_STRING cComponentName, OMX_U32 nNameLength, OMX_U32 nIndex) = 0;
-  virtual OMX_ERRORTYPE OMX_SetupTunnel(OMX_HANDLETYPE hOutput, OMX_U32 nPortOutput, OMX_HANDLETYPE hInput, OMX_U32 nPortInput) = 0;
-
-};
-
-#if (defined USE_EXTERNAL_OMX)
-class DllOMX : public DllDynamic, DllOMXInterface
-{
-public:
-  virtual OMX_ERRORTYPE OMX_Init(void) 
-    { return ::OMX_Init(); };
-  virtual OMX_ERRORTYPE OMX_Deinit(void) 
-    { return ::OMX_Deinit(); };
-  virtual OMX_ERRORTYPE OMX_GetHandle(OMX_HANDLETYPE *pHandle, OMX_STRING cComponentName, OMX_PTR pAppData, OMX_CALLBACKTYPE *pCallBacks)
-    { return ::OMX_GetHandle(pHandle, cComponentName, pAppData, pCallBacks); };
-  virtual OMX_ERRORTYPE OMX_FreeHandle(OMX_HANDLETYPE hComponent)
-    { return ::OMX_FreeHandle(hComponent); };
-  virtual OMX_ERRORTYPE OMX_GetComponentsOfRole(OMX_STRING role, OMX_U32 *pNumComps, OMX_U8 **compNames) 
-    { return ::OMX_GetComponentsOfRole(role, pNumComps, compNames); };
-  virtual OMX_ERRORTYPE OMX_GetRolesOfComponent(OMX_STRING compName, OMX_U32 *pNumRoles, OMX_U8 **roles)
-    { return ::OMX_GetRolesOfComponent(compName, pNumRoles, roles); };
-  virtual OMX_ERRORTYPE OMX_ComponentNameEnum(OMX_STRING cComponentName, OMX_U32 nNameLength, OMX_U32 nIndex)
-    { return ::OMX_ComponentNameEnum(cComponentName, nNameLength, nIndex); };
-  virtual OMX_ERRORTYPE OMX_SetupTunnel(OMX_HANDLETYPE hOutput, OMX_U32 nPortOutput, OMX_HANDLETYPE hInput, OMX_U32 nPortInput)
-    { return ::OMX_SetupTunnel(hOutput, nPortOutput, hInput, nPortInput); };
-  virtual bool ResolveExports() 
-    { return true; }
-  virtual bool Load() 
-  {
-    CLog::Log(LOGDEBUG, "DllOMX: Using omx system library");
-    return true;
-  }
-  virtual void Unload() {}
-};
-#else
-class DllOMX : public DllDynamic, DllOMXInterface
-{
-  //DECLARE_DLL_WRAPPER(DllLibOpenMax, "/usr/lib/libnvomx.so")
-  DECLARE_DLL_WRAPPER(DllOMX, "/opt/vc/lib/libopenmaxil.so")
-
-  DEFINE_METHOD0(OMX_ERRORTYPE, OMX_Init)
-  DEFINE_METHOD0(OMX_ERRORTYPE, OMX_Deinit)
-  DEFINE_METHOD4(OMX_ERRORTYPE, OMX_GetHandle, (OMX_HANDLETYPE *p1, OMX_STRING p2, OMX_PTR p3, OMX_CALLBACKTYPE *p4))
-  DEFINE_METHOD1(OMX_ERRORTYPE, OMX_FreeHandle, (OMX_HANDLETYPE p1))
-  DEFINE_METHOD3(OMX_ERRORTYPE, OMX_GetComponentsOfRole, (OMX_STRING p1, OMX_U32 *p2, OMX_U8 **p3))
-  DEFINE_METHOD3(OMX_ERRORTYPE, OMX_GetRolesOfComponent, (OMX_STRING p1, OMX_U32 *p2, OMX_U8 **p3))
-  DEFINE_METHOD3(OMX_ERRORTYPE, OMX_ComponentNameEnum, (OMX_STRING p1, OMX_U32 p2, OMX_U32 p3))
-  DEFINE_METHOD4(OMX_ERRORTYPE, OMX_SetupTunnel, (OMX_HANDLETYPE p1, OMX_U32 p2, OMX_HANDLETYPE p3, OMX_U32 p4));
-  BEGIN_METHOD_RESOLVE()
-    RESOLVE_METHOD(OMX_Init)
-    RESOLVE_METHOD(OMX_Deinit)
-    RESOLVE_METHOD(OMX_GetHandle)
-    RESOLVE_METHOD(OMX_FreeHandle)
-    RESOLVE_METHOD(OMX_GetComponentsOfRole)
-    RESOLVE_METHOD(OMX_GetRolesOfComponent)
-    RESOLVE_METHOD(OMX_ComponentNameEnum)
-    RESOLVE_METHOD(OMX_SetupTunnel)
-  END_METHOD_RESOLVE()
-
-public:
-  virtual bool Load()
-  {
-    return DllDynamic::Load();
-  }
-};
-#endif
-
-#endif
diff -ENwbur xbmcfrodo/xbmc/cores/omxplayer/OMXAudio.cpp xbmc/xbmc/cores/omxplayer/OMXAudio.cpp
--- xbmcfrodo/xbmc/cores/omxplayer/OMXAudio.cpp	2013-04-05 17:12:13.817112195 +0000
+++ xbmc/xbmc/cores/omxplayer/OMXAudio.cpp	2013-04-05 17:19:30.089106045 +0000
@@ -96,6 +96,7 @@
   m_Pause           (false  ),
   m_CanPause        (false  ),
   m_CurrentVolume   (0      ),
+  m_drc             (0      ),
   m_Passthrough     (false  ),
   m_HWDecode        (false  ),
   m_BytesPerSec     (0      ),
@@ -111,6 +112,7 @@
   m_eEncoding       (OMX_AUDIO_CodingPCM),
   m_extradata       (NULL   ),
   m_extrasize       (0      ),
+  m_vizBufferSamples(0      ),
   m_last_pts        (DVD_NOPTS_VALUE),
   m_omx_render      (NULL   )
 {
@@ -315,10 +317,7 @@
   m_pcm_input.nChannels             = m_format.m_channelLayout.Count();
   m_pcm_input.nSamplingRate         = m_format.m_sampleRate;
 
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  std::string componentName = "";
-
-  componentName = "OMX.broadcom.audio_render";
+  std::string componentName = "OMX.broadcom.audio_render";
 
   if(!m_omx_render)
     m_omx_render = new COMXCoreComponent();
@@ -335,7 +334,7 @@
   OMX_INIT_STRUCTURE(audioDest);
   strncpy((char *)audioDest.sName, device.c_str(), strlen(device.c_str()));
 
-  omx_err = m_omx_render->SetConfig(OMX_IndexConfigBrcmAudioDestination, &audioDest);
+  OMX_ERRORTYPE omx_err = m_omx_render->SetConfig(OMX_IndexConfigBrcmAudioDestination, &audioDest);
   if (omx_err != OMX_ErrorNone)
     return false;
 
@@ -707,7 +706,6 @@
   {
     double r = fVolume;
     const float* coeff = downmixing_coefficients_8;
-    int input_channels = 0;
 
     // normally we normalalise the levels, can be skipped (boosted) at risk of distortion
     if(!g_guiSettings.GetBool("audiooutput.normalizelevels"))
@@ -908,6 +906,7 @@
       omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
       if (omx_err == OMX_ErrorNone)
       {
+        //CLog::Log(LOGINFO, "AudiD: dts:%.0f pts:%.0f size:%d\n", dts, pts, len);
         break;
       }
       else
diff -ENwbur xbmcfrodo/xbmc/cores/omxplayer/OMXAudio.h xbmc/xbmc/cores/omxplayer/OMXAudio.h
--- xbmcfrodo/xbmc/cores/omxplayer/OMXAudio.h	2013-04-05 17:12:13.817112195 +0000
+++ xbmc/xbmc/cores/omxplayer/OMXAudio.h	2013-04-05 17:19:30.099105861 +0000
@@ -94,6 +94,7 @@
   unsigned int SyncAC3(BYTE* pData, unsigned int iSize);
 
   bool BadState() { return !m_Initialized; };
+  unsigned int GetAudioRenderingLatency();
 
 private:
   IAudioCallback* m_pCallback;
@@ -148,7 +149,6 @@
   CAEChannelInfo    GetChannelLayout(AEAudioFormat format);
 
   void CheckOutputBufferSize(void **buffer, int *oldSize, int newSize);
-  unsigned int GetAudioRenderingLatency();
   CCriticalSection m_critSection;
 };
 #endif
diff -ENwbur xbmcfrodo/xbmc/cores/omxplayer/OMXAudioCodec.h xbmc/xbmc/cores/omxplayer/OMXAudioCodec.h
--- xbmcfrodo/xbmc/cores/omxplayer/OMXAudioCodec.h	2013-04-05 17:03:23.476621158 +0000
+++ xbmc/xbmc/cores/omxplayer/OMXAudioCodec.h	2013-02-10 14:23:18.736510936 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp xbmc/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp
--- xbmcfrodo/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp	2013-04-05 17:03:23.476621158 +0000
+++ xbmc/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp	2013-04-05 11:38:43.996813180 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -84,6 +84,7 @@
   m_layout = 0;
   m_pFrame1 = NULL;
   m_iSampleFormat = AV_SAMPLE_FMT_NONE;
+  m_iBufferSize1 = 0;
 }
 
 COMXAudioCodecOMX::~COMXAudioCodecOMX()
diff -ENwbur xbmcfrodo/xbmc/cores/omxplayer/OMXAudioCodecOMX.h xbmc/xbmc/cores/omxplayer/OMXAudioCodecOMX.h
--- xbmcfrodo/xbmc/cores/omxplayer/OMXAudioCodecOMX.h	2013-04-05 17:03:23.476621158 +0000
+++ xbmc/xbmc/cores/omxplayer/OMXAudioCodecOMX.h	2013-04-05 11:38:43.996813180 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -32,7 +32,7 @@
 class COMXAudioCodecOMX
 {
 public:
-  void Upmix(void *input, unsigned int channelsInput,  void *output,
+  static void Upmix(void *input, unsigned int channelsInput,  void *output,
     unsigned int channelsOutput, unsigned int frames, AEDataFormat dataFormat);
   COMXAudioCodecOMX();
   virtual ~COMXAudioCodecOMX();
@@ -44,8 +44,8 @@
   int GetChannels();
   virtual CAEChannelInfo GetChannelMap();
   int GetSampleRate();
-  int GetBitsPerSample();
-  const char* GetName() { return "FFmpeg"; }
+  static int GetBitsPerSample();
+  static const char* GetName() { return "FFmpeg"; }
   int GetBufferSize() { return m_iBuffered; }
   int GetBitRate();
 
diff -ENwbur xbmcfrodo/xbmc/cores/omxplayer/OMXImage.cpp xbmc/xbmc/cores/omxplayer/OMXImage.cpp
--- xbmcfrodo/xbmc/cores/omxplayer/OMXImage.cpp	2013-04-05 17:03:23.486620981 +0000
+++ xbmc/xbmc/cores/omxplayer/OMXImage.cpp	2013-04-05 11:38:43.996813180 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -59,7 +59,6 @@
   m_width         = 0;
   m_height        = 0;
 
-  m_is_open       = false;
   m_decoded_buffer = NULL;
   m_encoded_buffer = NULL;
 
@@ -320,12 +319,12 @@
       else if(marker == M_APP1)
       {
         int readBits = 2;
-        bool bMotorolla = false;
-        bool bError = false;
 
         // Exif header
         if(CBitstreamConverter::read_bits(&br, 32) == 0x45786966)
         {
+          bool bMotorolla = false;
+          bool bError = false;
           CBitstreamConverter::skip_bits(&br, 8 * 2);
           readBits += 2;
         
@@ -485,7 +484,7 @@
 
 bool COMXImage::ClampLimits(unsigned int &width, unsigned int &height)
 {
-  RESOLUTION_INFO& res_info =  g_settings.m_ResInfo[g_graphicsContext.GetVideoResolution()];
+  RESOLUTION_INFO& res_info =  CDisplaySettings::Get().GetResolutionInfo(g_graphicsContext.GetVideoResolution());
   const bool transposed = m_orientation & 4;
   const int gui_width  = transposed ? res_info.iHeight:res_info.iWidth;
   const int gui_height = transposed ? res_info.iWidth:res_info.iHeight;
@@ -733,8 +732,8 @@
     width = height * 16/9;
     if(!width || !height)
     {
-      width = g_settings.m_ResInfo[g_guiSettings.m_LookAndFeelResolution].iWidth;
-      height = g_settings.m_ResInfo[g_guiSettings.m_LookAndFeelResolution].iHeight;
+      width = CDisplaySettings::Get().GetCurrentResolutionInfo().iWidth;
+      height = CDisplaySettings::Get().GetCurrentResolutionInfo().iHeight;
     }
   }
 
diff -ENwbur xbmcfrodo/xbmc/cores/omxplayer/OMXImage.h xbmc/xbmc/cores/omxplayer/OMXImage.h
--- xbmcfrodo/xbmc/cores/omxplayer/OMXImage.h	2013-04-05 17:03:23.486620981 +0000
+++ xbmc/xbmc/cores/omxplayer/OMXImage.h	2013-02-10 14:23:18.746510742 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/omxplayer/OMXPlayer.cpp xbmc/xbmc/cores/omxplayer/OMXPlayer.cpp
--- xbmcfrodo/xbmc/cores/omxplayer/OMXPlayer.cpp	2013-04-05 17:03:23.496620803 +0000
+++ xbmc/xbmc/cores/omxplayer/OMXPlayer.cpp	2013-04-05 12:24:06.117796029 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -38,6 +38,7 @@
 #include "filesystem/SpecialProtocol.h"
 #include "guilib/GUIWindowManager.h"
 #include "settings/AdvancedSettings.h"
+#include "settings/MediaSettings.h"
 #include "settings/GUISettings.h"
 #include "settings/Settings.h"
 #include "threads/SingleLock.h"
@@ -52,6 +53,7 @@
 
 #include "utils/LangCodeExpander.h"
 #include "guilib/LocalizeStrings.h"
+#include "guilib/Key.h"
 
 #include "storage/MediaManager.h"
 #include "GUIUserMessages.h"
@@ -104,14 +106,6 @@
   }
 }
 
-void COMXPlayer::GetAudioStreamLanguage(int iStream, CStdString &strLanguage)
-{
-  strLanguage = "";
-  OMXSelectionStream& s = m_SelectionStreams.Get(STREAM_AUDIO, iStream);
-  if(s.language.length() > 0)
-    strLanguage = s.language;
-}
-
 OMXSelectionStream& COMXSelectionStreams::Get(StreamType type, int index)
 {
   CSingleLock lock(m_section);
@@ -146,8 +140,8 @@
 
 static bool PredicateAudioPriority(const OMXSelectionStream& lh, const OMXSelectionStream& rh)
 {
-  PREDICATE_RETURN(lh.type_index == g_settings.m_currentVideoSettings.m_AudioStream
-                 , rh.type_index == g_settings.m_currentVideoSettings.m_AudioStream);
+  PREDICATE_RETURN(lh.type_index == CMediaSettings::Get().GetCurrentVideoSettings().m_AudioStream
+                 , rh.type_index == CMediaSettings::Get().GetCurrentVideoSettings().m_AudioStream);
 
   if(!g_guiSettings.GetString("locale.audiolanguage").Equals("original"))
   {
@@ -169,14 +163,14 @@
 
 static bool PredicateSubtitlePriority(const OMXSelectionStream& lh, const OMXSelectionStream& rh)
 {
-  if(!g_settings.m_currentVideoSettings.m_SubtitleOn)
+  if(!CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleOn)
   {
     PREDICATE_RETURN(lh.flags & CDemuxStream::FLAG_FORCED
                    , rh.flags & CDemuxStream::FLAG_FORCED);
   }
 
-  PREDICATE_RETURN(lh.type_index == g_settings.m_currentVideoSettings.m_SubtitleStream
-                 , rh.type_index == g_settings.m_currentVideoSettings.m_SubtitleStream);
+  PREDICATE_RETURN(lh.type_index == CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleStream
+                 , rh.type_index == CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleStream);
 
   CStdString subtitle_language = g_langInfo.GetSubtitleLanguage();
   if(!g_guiSettings.GetString("locale.subtitlelanguage").Equals("original"))
@@ -326,10 +320,14 @@
       s.source   = source;
       s.type     = STREAM_AUDIO;
       s.id       = i;
-      s.name     = nav->GetAudioStreamLanguage(i);
       s.flags    = CDemuxStream::FLAG_NONE;
       s.filename = filename;
-      s.channels = 0;
+
+      DVDNavStreamInfo info;
+      nav->GetAudioStreamInfo(i, info);
+      s.name     = info.name;
+      s.language = info.language;
+      s.channels = info.channels;
       Update(s);
     }
 
@@ -340,10 +338,14 @@
       s.source   = source;
       s.type     = STREAM_SUBTITLE;
       s.id       = i;
-      s.name     = nav->GetSubtitleStreamLanguage(i);
       s.flags    = CDemuxStream::FLAG_NONE;
       s.filename = filename;
       s.channels = 0;
+
+      DVDNavStreamInfo info;
+      nav->GetSubtitleStreamInfo(i, info);
+      s.name     = info.name;
+      s.language = info.language;
       Update(s);
     }
   }
@@ -369,6 +371,14 @@
       s.type     = stream->type;
       s.id       = stream->iId;
       s.language = stream->language;
+
+      if (s.language.length() == 2)
+      {
+        CStdString lang;
+        g_LangCodeExpander.ConvertToThreeCharCode(lang, stream->language);
+        s.language = lang;
+      }
+
       s.flags    = stream->flags;
       s.filename = demuxer->GetFileName();
       stream->GetStreamName(s.name);
@@ -415,14 +425,14 @@
   m_UpdateApplication = 0;
   m_caching           = CACHESTATE_DONE;
   m_playSpeed         = DVD_PLAYSPEED_NORMAL;
+  m_HasVideo          = false;
+  m_HasAudio          = false;
 
-  m_State.Clear();
   m_dvd.Clear();
+  m_State.Clear();
   m_EdlAutoSkipMarkers.Clear();
 
   memset(&m_SpeedState, 0, sizeof(m_SpeedState));
-
-  m_messenger.Init();
 }
 
 COMXPlayer::~COMXPlayer()
@@ -474,7 +484,6 @@
     g_renderManager.PreInit();
 
     Create();
-
     if(!m_ready.WaitMSec(100))
     {
       CGUIDialogBusy* dialog = (CGUIDialogBusy*)g_windowManager.GetWindow(WINDOW_DIALOG_BUSY);
@@ -529,6 +538,9 @@
   m_Edl.Clear();
   m_EdlAutoSkipMarkers.Clear();
 
+  m_HasVideo = false;
+  m_HasAudio = false;
+
   g_renderManager.UnInit();
   return true;
 }
@@ -545,6 +557,8 @@
   m_CurrentSubtitle.Clear();
   m_CurrentTeletext.Clear();
 
+  m_messenger.Init();
+
   CUtil::ClearTempFonts();
 }
 
@@ -562,7 +576,7 @@
   {
     m_filename = g_mediaManager.TranslateDevicePath("");
   }
-retry:
+
   // before creating the input stream, if this is an HLS playlist then get the
   // most appropriate bitrate based on our network settings
   if (filename.Left(7) == "http://" && filename.Right(5) == ".m3u8")
@@ -590,11 +604,10 @@
     return false;
   }
 
-  if (m_pInputStream && ( m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD)
-                       || m_pInputStream->IsStreamType(DVDSTREAM_TYPE_BLURAY) ) )
+  if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD)
+                       || m_pInputStream->IsStreamType(DVDSTREAM_TYPE_BLURAY))
   {
     CLog::Log(LOGINFO, "COMXPlayer::OpenInputStream - DVD/BD not supported - Will try...");
-    // return false;
   }
 
   // find any available external subtitles for non dvd files
@@ -630,13 +643,12 @@
       }
     } // end loop over all subtitle files    
 
-    g_settings.m_currentVideoSettings.m_SubtitleCached = true;
+    CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleCached = true;
   }
 
-  SetAVDelay(g_settings.m_currentVideoSettings.m_AudioDelay);
-  SetSubTitleDelay(g_settings.m_currentVideoSettings.m_SubtitleDelay);
+  SetAVDelay(CMediaSettings::Get().GetCurrentVideoSettings().m_AudioDelay);
+  SetSubTitleDelay(CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleDelay);
   m_av_clock.Reset();
-  //m_av_clock.OMXReset();
   m_dvd.Clear();
   m_iChannelEntryTimeOut = 0;
 
@@ -695,8 +707,9 @@
 
 void COMXPlayer::OpenDefaultStreams(bool reset)
 {
-  // bypass for DVDs. The DVD Navigator has already dictated which streams to open.
-  if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
+  // if input stream dictate, we will open later
+  if(m_dvd.iSelectedAudioStream >= 0
+  || m_dvd.iSelectedSPUStream   >= 0)
     return;
 
   OMXSelectionStreams streams;
@@ -708,7 +721,7 @@
   for(OMXSelectionStreams::iterator it = streams.begin(); it != streams.end() && !valid; ++it)
   {
     if(OpenVideoStream(it->id, it->source, reset))
-      valid = true;;
+      valid = true;
   }
   if(!valid)
     CloseVideoStream(true);
@@ -729,7 +742,7 @@
     CloseAudioStream(true);
 
   // enable subtitles
-  m_player_video.EnableSubtitle(g_settings.m_currentVideoSettings.m_SubtitleOn);
+  m_player_video.EnableSubtitle(CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleOn);
 
   // open subtitle stream
   streams = m_SelectionStreams.Get(STREAM_SUBTITLE, PredicateSubtitlePriority);
@@ -747,20 +760,15 @@
     CloseSubtitleStream(true);
 
   // open teletext stream
-  /*
   streams = m_SelectionStreams.Get(STREAM_TELETEXT);
   valid   = false;
-  for(SelectionStreams::iterator it = streams.begin(); it != streams.end() && !valid; ++it)
+  for(OMXSelectionStreams::iterator it = streams.begin(); it != streams.end() && !valid; ++it)
   {
     if(OpenTeletextStream(it->id, it->source))
       valid = true;
   }
   if(!valid)
     CloseTeletextStream(true);
-  */
-
-  //m_av_clock.OMXStop();
-  //m_av_clock.OMXReset();
 }
 
 bool COMXPlayer::ReadPacket(DemuxPacket*& packet, CDemuxStream*& stream)
@@ -882,6 +890,9 @@
   if(m_PlayerOptions.video_only && current.type != STREAM_VIDEO)
     return false;
 
+  if(stream->disabled)
+    return false;
+
   if (m_pInputStream && ( m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD)
                        || m_pInputStream->IsStreamType(DVDSTREAM_TYPE_BLURAY) ) )
   {
@@ -911,9 +922,6 @@
     && stream->iId    == current.id)
       return false;
 
-    if(stream->disabled)
-      return false;
-
     if(stream->type != current.type)
       return false;
 
@@ -937,17 +945,17 @@
     return;
   }
 
-  if(m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
+  if (CDVDInputStream::IMenus* ptr = dynamic_cast<CDVDInputStream::IMenus*>(m_pInputStream))
   {
-    CLog::Log(LOGNOTICE, "OMXPlayer: playing a dvd with menu's");
+    CLog::Log(LOGNOTICE, "OMXPlayer: playing a file with menu's");
     m_PlayerOptions.starttime = 0;
 
     if(m_PlayerOptions.state.size() > 0)
-      ((CDVDInputStreamNavigator*)m_pInputStream)->SetNavigatorState(m_PlayerOptions.state);
-    else
-      ((CDVDInputStreamNavigator*)m_pInputStream)->EnableSubtitleStream(g_settings.m_currentVideoSettings.m_SubtitleOn);
+      ptr->SetState(m_PlayerOptions.state);
+    else if(CDVDInputStreamNavigator* nav = dynamic_cast<CDVDInputStreamNavigator*>(m_pInputStream))
+      nav->EnableSubtitleStream(CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleOn);
 
-    g_settings.m_currentVideoSettings.m_SubtitleCached = true;
+    CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleCached = true;
   }
 
   if(!OpenDemuxStream())
@@ -1043,11 +1051,8 @@
   if (!CachePVRStream())
     SetCaching(CACHESTATE_FLUSH);
 
-  // stop thumb jobs
-  CJobManager::GetInstance().Pause(kJobTypeMediaFlags);
-
   /*
-  if (CJobManager::GetInstance().IsProcessing(kJobTypeMediaFlags) > 0)
+  if (CJobManager::GetInstance().IsProcessing(CJob::PRIORITY_LOW))
   {
     if (!WaitForPausedThumbJobs(20000))
     {
@@ -1059,6 +1064,22 @@
 
   while (!m_bAbortRequest)
   {
+    #ifdef _DEBUG
+    char response[80];
+    static unsigned count;
+    if ((count++ & 15) == 0)
+    {
+      vc_gencmd(response, sizeof response, "render_bar 4 video_fifo %d %d %d %d",
+            m_player_video.GetDecoderBufferSize()-m_player_video.GetDecoderFreeSpace(),
+            0 , 0, m_player_video.GetDecoderBufferSize());
+      vc_gencmd(response, sizeof response, "render_bar 5 audio_fifo %d %d %d %d",
+            (int)(100.0*m_player_audio.GetDelay()), 0, 0, 100*AUDIO_BUFFER_SECONDS);
+      vc_gencmd(response, sizeof response, "render_bar 6 video_queue %d %d %d %d",
+            m_player_video.GetLevel(), 0, 0, 100);
+      vc_gencmd(response, sizeof response, "render_bar 7 audio_queue %d %d %d %d",
+            m_player_audio.GetLevel(), 0, 0, 100);
+    }
+    #endif
     // handle messages send to this thread, like seek or demuxer reset requests
     HandleMessages();
 
@@ -1070,6 +1091,7 @@
     {
       if (OpenInputStream() == false)
       {
+        CLog::Log(LOGERROR, "%s - Closing stream due to OpenInputStream()", __FUNCTION__);
         m_bAbortRequest = true;
         break;
       }
@@ -1086,12 +1108,17 @@
 
       if (OpenDemuxStream() == false)
       {
+        CLog::Log(LOGERROR, "%s - Closing stream due to OpenDemuxStream()", __FUNCTION__);
         m_bAbortRequest = true;
         break;
       }
 
       OpenDefaultStreams();
 
+      // never allow first frames after open to be skipped
+      if( m_player_video.IsInited() )
+        m_player_video.SendMessage(new CDVDMsg(CDVDMsg::VIDEO_NOSKIP));
+
       if (CachePVRStream())
         SetCaching(CACHESTATE_PVR);
 
@@ -1111,6 +1138,7 @@
     // OMX emergency exit
     if(HasAudio() && m_player_audio.BadState())
     {
+      CLog::Log(LOGERROR, "%s - Closing stream due to m_player_audio.BadState()", __FUNCTION__);
       m_bAbortRequest = true;
       break;
     }
@@ -1148,10 +1176,8 @@
         continue;
 
       // check for a still frame state
-      if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
+      if (CDVDInputStream::IMenus* pStream = dynamic_cast<CDVDInputStream::IMenus*>(m_pInputStream))
       {
-        CDVDInputStreamNavigator* pStream = static_cast<CDVDInputStreamNavigator*>(m_pInputStream);
-
         // stills will be skipped
         if(m_dvd.state == DVDSTATE_STILL)
         {
@@ -1273,9 +1299,6 @@
     // check if in a cut or commercial break that should be automatically skipped
     CheckAutoSceneSkip();
   }
-
-  // let thumbgen jobs resume.
-  CJobManager::GetInstance().UnPause(kJobTypeMediaFlags);
 }
 
 bool COMXPlayer::CheckDelayedChannelEntry(void)
@@ -1591,6 +1614,7 @@
   if(m_caching != caching)
     SetCaching(caching);
 
+
   if(GetPlaySpeed() != DVD_PLAYSPEED_NORMAL && GetPlaySpeed() != DVD_PLAYSPEED_PAUSE)
   {
     if (IsInMenu())
@@ -1746,6 +1770,7 @@
 
 void COMXPlayer::UpdateCorrection(DemuxPacket* pkt, double correction)
 {
+  //CLog::Log(LOGINFO,"%s: %d dts:%.0f pts:%.0f s:%d c:%.0f (%d,%d)", __func__, (int)pkt->iStreamId, pkt->dts, pkt->pts, pkt->iSize, correction, pkt->dts==DVD_NOPTS_VALUE, pkt->pts==DVD_NOPTS_VALUE);
   if(pkt->dts != DVD_NOPTS_VALUE) pkt->dts -= correction;
   if(pkt->pts != DVD_NOPTS_VALUE) pkt->pts -= correction;
 }
@@ -1766,6 +1791,24 @@
     current.dur = 0.1 * (current.dur * 9 + (dts - current.dts));
 
   current.dts = dts;
+
+  /* send a playback state structure periodically */
+  if(current.dts_state == DVD_NOPTS_VALUE
+  || abs(current.dts - current.dts_state) > DVD_MSEC_TO_TIME(200))
+  {
+    current.dts_state = current.dts;
+    if (current.inited)
+    {
+      // make sure we send no outdated state to a/v players
+      UpdatePlayState(0);
+      SendPlayerMessage(new CDVDMsgType<SPlayerState>(CDVDMsg::PLAYER_DISPLAYTIME, m_StateInput), current.player);
+    }
+    else
+    {
+      CSingleLock lock(m_StateSection);
+      m_State = m_StateInput;
+    }
+  }
 }
 
 void COMXPlayer::UpdateLimits(double& minimum, double& maximum, double dts)
@@ -2076,15 +2119,23 @@
         double start = DVD_NOPTS_VALUE;
 
         int time = msg.GetRestore() ? (int)m_Edl.RestoreCutTime(msg.GetTime()) : msg.GetTime();
+
+        // if input streams doesn't support seektime we must convert back to clock
+        if(dynamic_cast<CDVDInputStream::ISeekTime*>(m_pInputStream) == NULL)
+          time -= DVD_TIME_TO_MSEC(m_State.time_offset - m_offset_pts);
+
         CLog::Log(LOGDEBUG, "demuxer seek to: %d", time);
         if (m_pDemuxer && m_pDemuxer->SeekTime(time, msg.GetBackward(), &start))
         {
-          CLog::Log(LOGDEBUG, "demuxer seek to: %d, success", time);
+          CLog::Log(LOGDEBUG, "demuxer seek to: %.0f, success", start);
           if(m_pSubtitleDemuxer)
           {
             if(!m_pSubtitleDemuxer->SeekTime(time, msg.GetBackward()))
               CLog::Log(LOGDEBUG, "failed to seek subtitle demuxer: %d, success", time);
           }
+          // dts after successful seek
+          m_StateInput.dts = start;
+
           FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate());
         }
         else
@@ -2142,7 +2193,6 @@
             {
               m_dvd.iSelectedAudioStream = -1;
               CloseAudioStream(false);
-              // TODO : check //CloseVideoStream(false);
               m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), true, true, true, true, true));
             }
           }
@@ -2193,14 +2243,15 @@
 
         CDVDMsgPlayerSetState* pMsgPlayerSetState = (CDVDMsgPlayerSetState*)pMsg;
 
-        if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
+        if (CDVDInputStream::IMenus* ptr = dynamic_cast<CDVDInputStream::IMenus*>(m_pInputStream))
+        {
+          if(ptr->SetState(pMsgPlayerSetState->GetState()))
         {
-          std::string s = pMsgPlayerSetState->GetState();
-          ((CDVDInputStreamNavigator*)m_pInputStream)->SetNavigatorState(s);
           m_dvd.state = DVDSTATE_NORMAL;
           m_dvd.iDVDStillStartTime = 0;
           m_dvd.iDVDStillTime = 0;
         }
+        }
 
         g_infoManager.SetDisplayAfterSeek();
       }
@@ -2240,7 +2291,7 @@
         }
 
         // if playspeed is different then DVD_PLAYSPEED_NORMAL or DVD_PLAYSPEED_PAUSE
-        // audioplayer, stops outputing audio to audiorendere, but still tries to
+        // audioplayer, stops outputing audio to audiorender, but still tries to
         // sleep an correct amount for each packet
         // videoplayer just plays faster after the clock speed has been increased
         // 1. disable audio
@@ -2337,6 +2388,24 @@
           m_CurrentVideo.started = true;
         CLog::Log(LOGDEBUG, "COMXPlayer::HandleMessages - player started %d", player);
       }
+      else if (pMsg->IsType(CDVDMsg::PLAYER_DISPLAYTIME))
+      {
+        COMXPlayer::SPlayerState& state = ((CDVDMsgType<COMXPlayer::SPlayerState>*)pMsg)->m_value;
+
+        CSingleLock lock(m_StateSection);
+        /* prioritize data from video player, but only accept data        *
+         * after it has been started to avoid race conditions after seeks */
+        if(m_CurrentVideo.started)
+        {
+          if(state.player == DVDPLAYER_VIDEO)
+            m_State = state;
+        }
+        else if(m_CurrentAudio.started)
+        {
+          if(state.player == DVDPLAYER_AUDIO)
+            m_State = state;
+        }
+      }
     }
     catch (...)
     {
@@ -2345,6 +2414,7 @@
 
     pMsg->Release();
   }
+
 }
 
 void COMXPlayer::SetCaching(ECacheState state)
@@ -2437,14 +2507,12 @@
 
 bool COMXPlayer::HasVideo() const
 {
-  if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD)) return true;
-
-  return m_SelectionStreams.Count(STREAM_VIDEO) > 0 ? true : false;
+  return m_HasVideo;
 }
 
 bool COMXPlayer::HasAudio() const
 {
-  return m_SelectionStreams.Count(STREAM_AUDIO) > 0 ? true : false;
+  return m_HasAudio;
 }
 
 bool COMXPlayer::IsPassthrough() const
@@ -2586,17 +2654,17 @@
 void COMXPlayer::GetAudioInfo(CStdString &strAudioInfo)
 {
   { CSingleLock lock(m_StateSection);
-    strAudioInfo.Format("D(%s)", m_State.demux_audio.c_str());
+    strAudioInfo.Format("D(%s)", m_StateInput.demux_audio.c_str());
   }
-  strAudioInfo.AppendFormat(" P(%s)", m_player_audio.GetPlayerInfo().c_str());
+  strAudioInfo.AppendFormat("\nP(%s)", m_player_audio.GetPlayerInfo().c_str());
 }
 
 void COMXPlayer::GetVideoInfo(CStdString &strVideoInfo)
 {
   { CSingleLock lock(m_StateSection);
-    strVideoInfo.Format("D(%s)", m_State.demux_video.c_str());
+    strVideoInfo.Format("D(%s)", m_StateInput.demux_video.c_str());
   }
-  strVideoInfo.AppendFormat(" P(%s)", m_player_video.GetPlayerInfo().c_str());
+  strVideoInfo.AppendFormat("\nP(%s)", m_player_video.GetPlayerInfo().c_str());
 }
 
 void COMXPlayer::GetGeneralInfo(CStdString& strGeneralInfo)
@@ -2617,7 +2685,7 @@
 
     CStdString strBuf;
     CSingleLock lock(m_StateSection);
-    if(m_State.cache_bytes >= 0)
+    if(m_StateInput.cache_bytes >= 0)
     {
       strBuf.AppendFormat(" cache:%s %2.0f%%"
                          , StringUtils::SizeToString(m_State.cache_bytes).c_str()
@@ -2663,7 +2731,7 @@
 float COMXPlayer::GetCachePercentage()
 {
   CSingleLock lock(m_StateSection);
-  return m_State.cache_offset * 100; // NOTE: Percentage returned is relative
+  return m_StateInput.cache_offset * 100; // NOTE: Percentage returned is relative
 }
 
 void COMXPlayer::SetAVDelay(float fValue)
@@ -2686,6 +2754,7 @@
   return -m_player_video.GetSubtitleDelay() / DVD_TIME_BASE;
 }
 
+// priority: 1: libdvdnav, 2: external subtitles, 3: muxed subtitles
 int COMXPlayer::GetSubtitleCount()
 {
   OMXStreamLock lock(this);
@@ -2698,24 +2767,19 @@
   return m_SelectionStreams.IndexOf(STREAM_SUBTITLE, *this);
 }
 
-void COMXPlayer::GetSubtitleName(int iStream, CStdString &strStreamName)
+void COMXPlayer::GetSubtitleStreamInfo(int index, SPlayerSubtitleStreamInfo &info)
 {
-  strStreamName = "";
-  OMXSelectionStream& s = m_SelectionStreams.Get(STREAM_SUBTITLE, iStream);
+  if (index < 0 || index > (int) GetSubtitleCount() - 1)
+    return;
+
+  OMXSelectionStream& s = m_SelectionStreams.Get(STREAM_SUBTITLE, index);
   if(s.name.length() > 0)
-    strStreamName = s.name;
-  else
-    strStreamName = g_localizeStrings.Get(13205); // Unknown
+    info.name = s.name;
 
   if(s.type == STREAM_NONE)
-    strStreamName += "(Invalid)";
-}
+    info.name += "(Invalid)";
 
-void COMXPlayer::GetSubtitleLanguage(int iStream, CStdString &strStreamLang)
-{
-  OMXSelectionStream& s = m_SelectionStreams.Get(STREAM_SUBTITLE, iStream);
-  if (!g_LangCodeExpander.Lookup(strStreamLang, s.language))
-    strStreamLang = g_localizeStrings.Get(13205); // Unknown
+  info.language = s.language;
 }
 
 void COMXPlayer::SetSubtitle(int iStream)
@@ -2729,7 +2793,7 @@
   {
     CDVDInputStreamNavigator* pStream = (CDVDInputStreamNavigator*)m_pInputStream;
     if(pStream->IsInMenu())
-      return g_settings.m_currentVideoSettings.m_SubtitleOn;
+      return CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleOn;
     else
       return pStream->IsSubtitleStreamEnabled();
   }
@@ -2739,7 +2803,7 @@
 
 void COMXPlayer::SetSubtitleVisible(bool bVisible)
 {
-  g_settings.m_currentVideoSettings.m_SubtitleOn = bVisible;
+  CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleOn = bVisible;
   m_messenger.Put(new CDVDMsgBool(CDVDMsg::PLAYER_SET_SUBTITLESTREAM_VISIBLE, bVisible));
 }
 
@@ -2755,19 +2819,6 @@
   return m_SelectionStreams.IndexOf(STREAM_AUDIO, *this);
 }
 
-void COMXPlayer::GetAudioStreamName(int iStream, CStdString &strStreamName)
-{
-  strStreamName = "";
-  OMXSelectionStream& s = m_SelectionStreams.Get(STREAM_AUDIO, iStream);
-  if(s.name.length() > 0)
-    strStreamName += s.name;
-  else
-    strStreamName += "Unknown";
-
-  if(s.type == STREAM_NONE)
-    strStreamName += " (Invalid)";
-}
- 
 void COMXPlayer::SetAudioStream(int iStream)
 {
   m_messenger.Put(new CDVDMsgPlayerSetAudioStream(iStream));
@@ -2803,13 +2854,15 @@
 {
   CSingleLock lock(m_StateSection);
   double offset = 0;
+  const double limit  = DVD_MSEC_TO_TIME(200);
   if(m_State.timestamp > 0)
   {
     offset  = m_av_clock.GetAbsoluteClock() - m_State.timestamp;
     offset *= m_playSpeed / DVD_PLAYSPEED_NORMAL;
-    if(offset >  1000) offset =  1000;
-    if(offset < -1000) offset = -1000;
+    if(offset >  limit) offset =  limit;
+    if(offset < -limit) offset = -limit;
   }
+  //{CLog::Log(LOGINFO, "%s: time:%.2f stamp:%.2f dts:%d m:%d (p:%d,c:%d) =%llu", __func__, (double)m_State.time, (double)m_State.timestamp, (int)DVD_TIME_TO_MSEC(m_State.dts + m_offset_pts), (int)DVD_TIME_TO_MSEC(m_av_clock.OMXMediaTime()), (int)m_playSpeed, (int)m_caching, llrint(m_State.time + DVD_TIME_TO_MSEC(offset)));}
   return llrint(m_State.time + DVD_TIME_TO_MSEC(offset));
 }
 
@@ -2844,11 +2897,17 @@
   CLog::Log(LOGNOTICE, "Opening audio stream: %i source: %i", iStream, source);
 
   if (!m_pDemuxer)
+  {
+    CLog::Log(LOGWARNING, "Opening audio stream: no demuxer");
     return false;
+  }
 
   CDemuxStream* pStream = m_pDemuxer->GetStream(iStream);
   if (!pStream || pStream->disabled)
+  {
+    CLog::Log(LOGWARNING, "Opening audio stream: pStream=%p disabled=%d", pStream, pStream ? pStream->disabled:0);
     return false;
+  }
 
   if( m_CurrentAudio.id < 0 &&  m_CurrentVideo.id >= 0 )
   {
@@ -2889,6 +2948,7 @@
   m_CurrentAudio.hint = hint;
   m_CurrentAudio.stream = (void*)pStream;
   m_CurrentAudio.started = false;
+  m_HasAudio = true;
 
   /* we are potentially going to be waiting on this */
   m_player_audio.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
@@ -2904,11 +2964,17 @@
   CLog::Log(LOGNOTICE, "Opening video stream: %i source: %i", iStream, source);
 
   if (!m_pDemuxer)
+  {
+    CLog::Log(LOGWARNING, "Opening video stream: no demuxer");
     return false;
+  }
 
   CDemuxStream* pStream = m_pDemuxer->GetStream(iStream);
   if(!pStream || pStream->disabled)
+  {
+    CLog::Log(LOGWARNING, "Opening video stream: pStream=%p disabled=%d", pStream, pStream ? pStream->disabled:0);
     return false;
+  }
   pStream->SetDiscard(AVDISCARD_NONE);
 
   CDVDStreamInfo hint(*pStream, true);
@@ -2970,6 +3036,7 @@
   m_CurrentVideo.hint = hint;
   m_CurrentVideo.stream = (void*)pStream;
   m_CurrentVideo.started = false;
+  m_HasVideo = true;
 
   /* we are potentially going to be waiting on this */
   m_player_video.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
@@ -3188,6 +3255,9 @@
 void COMXPlayer::FlushBuffers(bool queued, double pts, bool accurate)
 {
   double startpts;
+
+  CLog::Log(LOGNOTICE, "FlushBuffers: q:%d pts:%.0f a:%d", queued, pts, accurate);
+
   if(accurate)
     startpts = pts;
   else
@@ -3256,7 +3326,15 @@
     if(pts != DVD_NOPTS_VALUE)
       m_av_clock.Discontinuity(pts);
     UpdatePlayState(0);
+
+    // update state, buffers are flushed and it may take some time until
+    // we get an update from players
+    CSingleLock lock(m_StateSection);
+    m_State = m_StateInput;
   }
+  // let clock know the new time so progress bar updates immediately
+  if(startpts != DVD_NOPTS_VALUE)
+    m_av_clock.OMXMediaTime(startpts);
 }
 
 // since we call ffmpeg functions to decode, this is being called in the same thread as ::Process() is
@@ -3274,6 +3352,29 @@
       m_dvd.iSelectedSPUStream   = *(int*)pData;
     else if(iMessage == 4)
       m_player_video.EnableSubtitle(*(int*)pData ? true: false);
+    else if(iMessage == 5)
+    {
+      if (m_dvd.state != DVDSTATE_STILL)
+      {
+        // else notify the player we have received a still frame
+
+        m_dvd.iDVDStillTime      = *(int*)pData;
+        m_dvd.iDVDStillStartTime = XbmcThreads::SystemClockMillis();
+
+        /* adjust for the output delay in the video queue */
+        unsigned int time = 0;
+        if( m_CurrentVideo.stream && m_dvd.iDVDStillTime > 0 )
+        {
+          time = (unsigned int)(m_player_video.GetOutputDelay() / ( DVD_TIME_BASE / 1000 ));
+          if( time < 10000 && time > 0 )
+            m_dvd.iDVDStillTime += time;
+        }
+        m_dvd.state = DVDSTATE_STILL;
+        CLog::Log(LOGDEBUG,
+                  "DVDNAV_STILL_FRAME - waiting %i sec, with delay of %d sec",
+                  m_dvd.iDVDStillTime, time / 1000);
+      }
+    }
 
     return 0;
   }
@@ -3512,11 +3613,12 @@
         pMenus->OnMenu();
         // send a message to everyone that we've gone to the menu
         CGUIMessage msg(GUI_MSG_VIDEO_MENU_STARTED, 0, 0);
-        g_windowManager.SendMessage(msg);
+        g_windowManager.SendThreadMessage(msg);
         return true;
       }
       break;
     }
+
     if (pMenus->IsInMenu())
     {
       switch (action.GetID())
@@ -3574,7 +3676,7 @@
       case ACTION_MOUSE_LEFT_CLICK:
         {
           CRect rs, rd;
-          GetVideoRect(rs, rd);
+          g_renderManager.GetVideoRect(rs, rd);
           CPoint pt(action.GetAmount(), action.GetAmount(1));
           if (!rd.PtInRect(pt))
             return false; // out of bounds
@@ -3714,7 +3816,7 @@
   if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
     return false;
 
-  double pts = m_av_clock.OMXMediaTime(false, false);
+  double pts = m_av_clock.OMXMediaTime(false);
 
   m_player_subtitle.GetCurrentSubtitle(strSubtitle, pts - m_player_video.GetSubtitleDelay());
 
@@ -3789,7 +3891,7 @@
 int COMXPlayer::GetCacheLevel() const
 {
   CSingleLock lock(m_StateSection);
-  return (int)(m_State.cache_level * 100);
+  return (int)(m_StateInput.cache_level * 100);
 }
 
 double COMXPlayer::GetQueueTime()
@@ -3799,14 +3901,16 @@
   return max(a, v) * 8000.0 / 100;
 }
 
-int COMXPlayer::GetAudioBitrate()
+void COMXPlayer::GetVideoStreamInfo(SPlayerVideoStreamInfo &info)
 {
-  return m_player_audio.GetAudioBitrate();
-}
+  info.bitrate = m_player_video.GetVideoBitrate();
 
-int COMXPlayer::GetVideoBitrate()
-{
-  return m_player_video.GetVideoBitrate();
+  CStdString retVal;
+  if (m_pDemuxer && (m_CurrentVideo.id != -1))
+    m_pDemuxer->GetStreamCodecName(m_CurrentVideo.id, retVal);
+  info.videoCodecName = retVal;
+  info.videoAspectRatio = g_renderManager.GetAspectRatio();
+  g_renderManager.GetVideoRect(info.SrcRect, info.DestRect);
 }
 
 int COMXPlayer::GetSourceBitrate()
@@ -3817,6 +3921,39 @@
   return 0;
 }
 
+void COMXPlayer::GetAudioStreamInfo(int index, SPlayerAudioStreamInfo &info)
+{
+  if (index < 0 || index > GetAudioStreamCount() - 1)
+    return;
+
+  if (index == GetAudioStream())
+    info.bitrate = m_player_audio.GetAudioBitrate();
+  else
+    info.bitrate = m_pDemuxer->GetStreamFromAudioId(index)->iBitRate;
+
+  OMXSelectionStream& s = m_SelectionStreams.Get(STREAM_AUDIO, index);
+  if(s.language.length() > 0)
+    info.language = s.language;
+
+  if(s.name.length() > 0)
+    info.name = s.name;
+
+  if(s.type == STREAM_NONE)
+    info.name += " (Invalid)";
+
+  if (m_pDemuxer)
+  {
+    CDemuxStreamAudio* stream = static_cast<CDemuxStreamAudio*>(m_pDemuxer->GetStreamFromAudioId(index));
+    if (stream)
+    {
+      info.channels = stream->iChannels;
+      CStdString codecName;
+      m_pDemuxer->GetStreamCodecName(stream->iId, codecName);
+      info.audioCodecName = codecName;
+    }
+  }
+}
+
 int COMXPlayer::AddSubtitleFile(const std::string& filename, const std::string& subfilename, CDemuxStream::EFlags flags)
 {
   std::string ext = URIUtils::GetExtension(filename);
@@ -3854,18 +3991,16 @@
 
 void COMXPlayer::UpdatePlayState(double timeout)
 {
-  if(m_State.timestamp != 0
-  && m_State.timestamp + DVD_MSEC_TO_TIME(timeout) > m_av_clock.GetAbsoluteClock())
+  if(m_StateInput.timestamp != 0
+  && m_StateInput.timestamp + DVD_MSEC_TO_TIME(timeout) > m_av_clock.GetAbsoluteClock())
     return;
 
-  SPlayerState state(m_State);
+  SPlayerState state(m_StateInput);
 
   if     (m_CurrentVideo.dts != DVD_NOPTS_VALUE)
     state.dts = m_CurrentVideo.dts;
   else if(m_CurrentAudio.dts != DVD_NOPTS_VALUE)
     state.dts = m_CurrentAudio.dts;
-  else
-    state.dts = m_av_clock.GetClock();
 
   if(m_pDemuxer)
   {
@@ -3873,15 +4008,21 @@
     state.chapter_count = m_pDemuxer->GetChapterCount();
     m_pDemuxer->GetChapterName(state.chapter_name);
 
+    if(state.dts == DVD_NOPTS_VALUE)
+      state.time     = 0;
+    else 
     // TODO : workaround until omx clock handling is rewritten
     if(m_playSpeed == DVD_PLAYSPEED_NORMAL)
-      state.time       = DVD_TIME_TO_MSEC(m_av_clock.OMXMediaTime(true, true));
+        state.time     = DVD_TIME_TO_MSEC(m_av_clock.OMXMediaTime(true));
     else
-      state.time       = DVD_TIME_TO_MSEC(m_av_clock.GetClock() + m_offset_pts);
+        state.time     = DVD_TIME_TO_MSEC(state.dts + m_offset_pts);
     state.time_total = m_pDemuxer->GetStreamLength();
-
+    state.time_src   = ETIMESOURCE_CLOCK;
   }
 
+  state.canpause     = true;
+  state.canseek      = true;
+
   if(m_pInputStream)
   {
     // override from input stream if needed
@@ -3897,27 +4038,26 @@
     {
       state.time       = pDisplayTime->GetTime();
       state.time_total = pDisplayTime->GetTotalTime();
+      state.time_src   = ETIMESOURCE_INPUT;
     }
 
-    if (dynamic_cast<CDVDInputStream::IMenus*>(m_pInputStream))
+    if (CDVDInputStream::IMenus* ptr = dynamic_cast<CDVDInputStream::IMenus*>(m_pInputStream))
     {
+      if(!ptr->GetState(state.player_state))
+        state.player_state = "";
+
       if(m_dvd.state == DVDSTATE_STILL)
       {
         state.time       = XbmcThreads::SystemClockMillis() - m_dvd.iDVDStillStartTime;
         state.time_total = m_dvd.iDVDStillTime;
+        state.time_src   = ETIMESOURCE_MENU;
       }
     }
 
-    if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
-    {
-      CDVDInputStreamPVRManager* pvrinputstream = static_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
-      state.canpause = pvrinputstream->CanPause();
-      state.canseek  = pvrinputstream->CanSeek();
-    }
-    else
+    if (CDVDInputStream::ISeekable* ptr = dynamic_cast<CDVDInputStream::ISeekable*>(m_pInputStream))
     {
-      state.canseek  = state.time_total > 0 ? true : false;
-      state.canpause = true;
+      state.canpause = ptr->CanPause();
+      state.canseek  = ptr->CanSeek();
     }
   }
 
@@ -3927,15 +4067,13 @@
     state.time_total  = m_Edl.RemoveCutTime(llrint(state.time_total));
   }
 
-  state.player_state = "";
-  if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
-  {
+  if(state.time_total <= 0)
+    state.canseek  = false;
+
+  if (state.time_src == ETIMESOURCE_CLOCK)
+    state.time_offset = m_offset_pts;
+  else if (state.dts != DVD_NOPTS_VALUE)
     state.time_offset = DVD_MSEC_TO_TIME(state.time) - state.dts;
-    if(!((CDVDInputStreamNavigator*)m_pInputStream)->GetNavigatorState(state.player_state))
-      state.player_state = "";
-  }
-  else
-    state.time_offset = 0;
 
   if (m_CurrentAudio.id >= 0 && m_pDemuxer)
   {
@@ -3980,9 +4118,10 @@
     state.cache_bytes = 0;
 
   state.timestamp = m_av_clock.GetAbsoluteClock();
+  //{CLog::Log(LOGINFO, "%s: time:%.2f stamp:%.2f dts:%d m:%d (p:%d,c:%d) =%llu", __func__, (double)state.time, (double)state.timestamp, (int)DVD_TIME_TO_MSEC(state.dts + m_offset_pts), (int)DVD_TIME_TO_MSEC(m_av_clock.OMXMediaTime()), (int)m_playSpeed, (int)m_caching, llrint(state.time + DVD_TIME_TO_MSEC(offset)));}
 
   CSingleLock lock(m_StateSection);
-  m_State = state;
+  m_StateInput = state;
 }
 
 void COMXPlayer::UpdateApplication(double timeout)
@@ -4027,33 +4166,6 @@
   return false;
 }
 
-int COMXPlayer::GetChannels()
-{
-  if (m_pDemuxer && (m_CurrentAudio.id != -1))
-  {
-    CDemuxStreamAudio* stream = static_cast<CDemuxStreamAudio*>(m_pDemuxer->GetStream(m_CurrentAudio.id));
-    if (stream)
-      return stream->iChannels;
-  }
-  return -1;
-}
-
-CStdString COMXPlayer::GetAudioCodecName()
-{
-  CStdString retVal;
-  if (m_pDemuxer && (m_CurrentAudio.id != -1))
-    m_pDemuxer->GetStreamCodecName(m_CurrentAudio.id, retVal);
-  return retVal;
-}
-
-CStdString COMXPlayer::GetVideoCodecName()
-{
-  CStdString retVal;
-  if (m_pDemuxer && (m_CurrentVideo.id != -1))
-    m_pDemuxer->GetStreamCodecName(m_CurrentVideo.id, retVal);
-  return retVal;
-}
-
 int COMXPlayer::GetPictureWidth()
 {
   if (m_pDemuxer && (m_CurrentVideo.id != -1))
@@ -4083,8 +4195,18 @@
     bool result=CDVDFileInfo::DemuxerToStreamDetails(m_pInputStream, m_pDemuxer, details);
     if (result && details.GetStreamCount(CStreamDetail::VIDEO) > 0) // this is more correct (dvds in particular)
     {
-      GetVideoAspectRatio(((CStreamDetailVideo*)details.GetNthStream(CStreamDetail::VIDEO,0))->m_fAspect);
-      ((CStreamDetailVideo*)details.GetNthStream(CStreamDetail::VIDEO,0))->m_iDuration = GetTotalTime() / 1000;
+      /* 
+       * We can only obtain the aspect & duration from dvdplayer when the Process() thread is running
+       * and UpdatePlayState() has been called at least once. In this case dvdplayer duration/AR will
+       * return 0 and we'll have to fallback to the (less accurate) info from the demuxer.
+       */
+      float aspect = m_player_video.GetAspectRatio();
+      if (aspect > 0.0f)
+        ((CStreamDetailVideo*)details.GetNthStream(CStreamDetail::VIDEO,0))->m_fAspect = aspect;
+
+      int64_t duration = GetTotalTime() / 1000;
+      if (duration > 0)
+        ((CStreamDetailVideo*)details.GetNthStream(CStreamDetail::VIDEO,0))->m_iDuration = duration;
     }
     return result;
   }
@@ -4132,11 +4254,6 @@
       g_advancedSettings.m_bPVRCacheInDvdPlayer;
 }
 
-void COMXPlayer::GetVideoRect(CRect& SrcRect, CRect& DestRect)
-{
-  g_renderManager.GetVideoRect(SrcRect, DestRect);
-}
-
 void COMXPlayer::SetMute(bool bOnOff)
 {
   m_current_mute = bOnOff;
@@ -4154,7 +4271,7 @@
   // use m_bStop and Sleep so we can get canceled.
   while (!m_bStop && (timeout_ms > 0))
   {
-    if (CJobManager::GetInstance().IsProcessing(kJobTypeMediaFlags) > 0)
+    if (CJobManager::GetInstance().IsProcessing(CJob::PRIORITY_LOW))
     {
       Sleep(100);
       timeout_ms -= 100;
@@ -4171,11 +4288,6 @@
   g_renderManager.Update(bPauseDrawing);
 }
 
-void COMXPlayer::GetVideoAspectRatio(float &fAR)
-{
-  fAR = g_renderManager.GetAspectRatio();
-}
-
 void COMXPlayer::GetRenderFeatures(std::vector<int> &renderFeatures)
 {
   renderFeatures.push_back(RENDERFEATURE_STRETCH);
diff -ENwbur xbmcfrodo/xbmc/cores/omxplayer/OMXPlayer.h xbmc/xbmc/cores/omxplayer/OMXPlayer.h
--- xbmcfrodo/xbmc/cores/omxplayer/OMXPlayer.h	2013-04-05 17:03:23.496620803 +0000
+++ xbmc/xbmc/cores/omxplayer/OMXPlayer.h	2013-04-03 14:20:37.318135583 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -74,6 +74,7 @@
   int              source;
   double           dts;    // last dts from demuxer, used to find disncontinuities
   double           dur;    // last frame expected duration
+  double           dts_state; // when did we last send a playback state update
   CDVDStreamInfo   hint;   // stream hints, used to notice stream changes
   void*            stream; // pointer or integer, identifying stream playing. if it changes stream changed
   int              changes; // remembered counter from stream to track codec changes
@@ -96,6 +97,7 @@
     id     = -1;
     source = STREAM_SOURCE_NONE;
     dts    = DVD_NOPTS_VALUE;
+    dts_state = DVD_NOPTS_VALUE;
     dur    = DVD_NOPTS_VALUE;
     hint.Clear();
     stream = NULL;
@@ -228,15 +230,13 @@
   virtual float GetCachePercentage();
 
   virtual void  SetMute(bool bOnOff);
-  virtual bool  ControlsVolume() {return true;}
   virtual void  SetVolume(float fVolume);
+  virtual bool  ControlsVolume() {return true;}
   virtual void  SetDynamicRangeCompression(long drc)              {}
   virtual void  GetAudioInfo(CStdString &strAudioInfo);
   virtual void  GetVideoInfo(CStdString &strVideoInfo);
   virtual void  GetGeneralInfo(CStdString &strVideoInfo);
   virtual void  Update(bool bPauseDrawing);
-  virtual void  GetVideoRect(CRect& SrcRect, CRect& DestRect);
-  virtual void  GetVideoAspectRatio(float &fAR);
   virtual void  UpdateApplication(double timeout);
   virtual bool  CanRecord();
   virtual bool  IsRecording();
@@ -249,19 +249,15 @@
   virtual float GetSubTitleDelay();
   virtual int   GetSubtitleCount();
   virtual int   GetSubtitle();
-  virtual void  GetSubtitleName(int iStream, CStdString &strStreamName);
-  virtual void  GetSubtitleLanguage(int iStream, CStdString &strStreamLang);
+  virtual void  GetSubtitleStreamInfo(int index, SPlayerSubtitleStreamInfo &info);
   virtual void  SetSubtitle(int iStream);
   virtual bool  GetSubtitleVisible();
   virtual void  SetSubtitleVisible(bool bVisible);
-  virtual bool  GetSubtitleExtension(CStdString &strSubtitleExtension) { return false; }
   virtual int   AddSubtitle(const CStdString& strSubPath);
 
   virtual int   GetAudioStreamCount();
   virtual int   GetAudioStream();
-  virtual void  GetAudioStreamName(int iStream, CStdString &strStreamName);
   virtual void  SetAudioStream(int iStream);
-  virtual void  GetAudioStreamLanguage(int iStream, CStdString &strLanguage);
 
   virtual TextCacheStruct_t* GetTeletextCache();
   virtual void  LoadPage(int p, int sp, unsigned char* buffer);
@@ -276,12 +272,9 @@
   virtual int64_t GetTime();
   virtual int64_t GetTotalTime();
   virtual void  ToFFRW(int iSpeed = 0);
-  virtual int   GetAudioBitrate();
-  virtual int   GetVideoBitrate();
+  virtual void  GetAudioStreamInfo(int index, SPlayerAudioStreamInfo &info);
+  virtual void  GetVideoStreamInfo(SPlayerVideoStreamInfo &info);
   virtual int   GetSourceBitrate();
-  virtual int   GetChannels();
-  virtual CStdString GetAudioCodecName();
-  virtual CStdString GetVideoCodecName();
   virtual int   GetPictureWidth();
   virtual int   GetPictureHeight();
   virtual bool  GetStreamDetails(CStreamDetails &details);
@@ -375,15 +368,27 @@
     int iSelectedAudioStream; // mpeg stream id, or -1 if disabled
   } m_dvd;
 
+  enum ETimeSource
+  {
+    ETIMESOURCE_CLOCK,
+    ETIMESOURCE_INPUT,
+    ETIMESOURCE_MENU,
+  };
+
+  friend class OMXPlayerVideo;
+  friend class OMXPlayerAudio;
+
   struct SPlayerState
   {
     SPlayerState() { Clear(); }
     void Clear()
     {
+      player        = 0;
       timestamp     = 0;
       time          = 0;
       time_total    = 0;
       time_offset   = 0;
+      time_src      = ETIMESOURCE_CLOCK;
       dts           = DVD_NOPTS_VALUE;
       player_state  = "";
       chapter       = 0;
@@ -401,11 +406,14 @@
       cache_offset  = 0.0;
     }
 
+    int    player;            // source of this data
+
     double timestamp;         // last time of update
     double time_offset;       // difference between time and pts
 
     double time;              // current playback time
     double time_total;        // total playback time
+    ETimeSource time_src;     // current time source
     double dts;               // last known dts
 
     std::string player_state;  // full player state
@@ -427,7 +435,7 @@
     double  cache_level;   // current estimated required cache level
     double  cache_delay;   // time until cache is expected to reach estimated level
     double  cache_offset;  // percentage of file ahead of current position
-  } m_State;
+  } m_State, m_StateInput;
   CCriticalSection m_StateSection;
 
   CEdl m_Edl;
@@ -490,4 +498,7 @@
   bool                    m_change_volume;
   CDVDOverlayContainer    m_overlayContainer;
   ECacheState             m_caching;
+
+  bool m_HasVideo;
+  bool m_HasAudio;
 };
diff -ENwbur xbmcfrodo/xbmc/cores/omxplayer/OMXPlayerAudio.cpp xbmc/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
--- xbmcfrodo/xbmc/cores/omxplayer/OMXPlayerAudio.cpp	2013-04-05 17:12:13.827112012 +0000
+++ xbmc/xbmc/cores/omxplayer/OMXPlayerAudio.cpp	2013-04-05 17:19:30.099105861 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -85,6 +85,21 @@
 
   m_messageQueue.SetMaxDataSize(3 * 1024 * 1024);
   m_messageQueue.SetMaxTimeSize(8.0);
+  m_use_passthrough = false;
+  m_passthrough = false;
+  m_use_hw_decode = false;
+  m_hw_decode = false;
+  m_silence = false;
+  m_error = 0.0;
+  m_errorbuff = 0.0;
+  m_errorcount = 0;
+  m_syncclock = false;
+  m_integral = 0.0;
+  m_skipdupcount = 0;
+  m_prevskipped = false;
+  m_flush = false;  
+  m_synctype = 0;
+
 }
 
 
@@ -213,7 +228,7 @@
     m_skipdupcount = 0;
     m_error = 0;
     m_syncclock = false;
-    m_errortime = m_av_clock->CurrentHostCounter();
+    m_errortime = CurrentHostCounter();
 
     return;
   }
@@ -225,12 +240,12 @@
     m_integral = 0;
     m_skipdupcount = 0;
     m_error = 0;
-    m_errortime = m_av_clock->CurrentHostCounter();
+    m_errortime = CurrentHostCounter();
     return;
   }
 
   //check if measured error for 1 second
-  now = m_av_clock->CurrentHostCounter();
+  now = CurrentHostCounter();
   if ((now - m_errortime) >= m_freq)
   {
     m_errortime = now;
@@ -373,7 +388,7 @@
         if(m_flush)
           break;
 
-        if(m_omxAudio.GetSpace() < (unsigned int)pkt->iSize)
+        if(m_omxAudio.GetSpace() < (unsigned int)decoded_size)
         {
           Sleep(10);
           continue;
@@ -493,6 +508,10 @@
       DemuxPacket* pPacket = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacket();
       bool bPacketDrop     = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacketDrop();
 
+      #ifdef _DEBUG
+      CLog::Log(LOGINFO, "Audio: dts:%.0f pts:%.0f size:%d (s:%d f:%d d:%d l:%d) s:%d %d/%d late:%d,%d", pPacket->dts, pPacket->pts,
+           (int)pPacket->iSize, m_started, m_flush, bPacketDrop, m_stalled, m_speed, 0, 0, (int)m_omxAudio.GetAudioRenderingLatency(), (int)m_hints_current.samplerate);
+      #endif
       if(Decode(pPacket, m_speed > DVD_PLAYSPEED_NORMAL || m_speed < 0 || bPacketDrop))
       {
         if (m_stalled && (m_omxAudio.GetCacheTime() > (AUDIO_BUFFER_SECONDS * 0.75f)))
@@ -506,7 +525,7 @@
       // hard unlock audio out buffering
       clock_gettime(CLOCK_REALTIME, &m_endtime);
       //int iLevel = min(99,m_messageQueue.GetLevel() + MathUtils::round_int(100.0/8.0*GetCacheTime()));
-      if(/*iLevel < 10 &&*/ m_stalled && (m_endtime.tv_sec - m_starttime.tv_sec) > 1)
+      if(/*iLevel < 10 &&*/ m_stalled && m_av_clock->OMXAudioBuffer() && (m_endtime.tv_sec - m_starttime.tv_sec) > 1)
       {
         m_stalled = false;
         if(m_av_clock->HasVideo() && m_av_clock->OMXAudioBuffer())
@@ -566,9 +585,22 @@
     }
     else if (pMsg->IsType(CDVDMsg::PLAYER_STARTED))
     {
+      CLog::Log(LOGDEBUG, "COMXPlayerAudio - CDVDMsg::PLAYER_STARTED %d", m_started);
       if(m_started)
         m_messageParent.Put(new CDVDMsgInt(CDVDMsg::PLAYER_STARTED, DVDPLAYER_AUDIO));
     }
+    else if (pMsg->IsType(CDVDMsg::PLAYER_DISPLAYTIME))
+    {
+      COMXPlayer::SPlayerState& state = ((CDVDMsgType<COMXPlayer::SPlayerState>*)pMsg)->m_value;
+
+      if(state.time_src == COMXPlayer::ETIMESOURCE_CLOCK)
+        state.time      = DVD_TIME_TO_MSEC(m_av_clock->OMXMediaTime(true));
+        //state.time      = DVD_TIME_TO_MSEC(m_av_clock->GetClock(state.timestamp) + state.time_offset);
+      else
+        state.timestamp = m_av_clock->GetAbsoluteClock();
+      state.player    = DVDPLAYER_AUDIO;
+      m_messageParent.Put(pMsg->Acquire());
+    }
     else if (pMsg->IsType(CDVDMsg::GENERAL_EOF))
     {
       CLog::Log(LOGDEBUG, "COMXPlayerAudio - CDVDMsg::GENERAL_EOF");
@@ -591,8 +623,11 @@
     }
     else if (pMsg->IsType(CDVDMsg::PLAYER_SETSPEED))
     {
-      CLog::Log(LOGDEBUG, "COMXPlayerAudio - CDVDMsg::PLAYER_SETSPEED");
+      if (m_speed != static_cast<CDVDMsgInt*>(pMsg)->m_value)
+      {
       m_speed = static_cast<CDVDMsgInt*>(pMsg)->m_value;
+        CLog::Log(LOGDEBUG, "COMXPlayerAudio - CDVDMsg::PLAYER_SETSPEED %d", m_speed);
+      }
       if (m_speed != DVD_PLAYSPEED_NORMAL)
       {
         m_syncclock = true;
diff -ENwbur xbmcfrodo/xbmc/cores/omxplayer/OMXPlayerAudio.h xbmc/xbmc/cores/omxplayer/OMXPlayerAudio.h
--- xbmcfrodo/xbmc/cores/omxplayer/OMXPlayerAudio.h	2013-04-05 17:03:23.506620625 +0000
+++ xbmc/xbmc/cores/omxplayer/OMXPlayerAudio.h	2013-04-05 12:24:06.117796029 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -57,7 +57,7 @@
   AEAudioFormat             m_format;
   CAEChannelInfo            m_channelLayout;
   COMXAudioCodecOMX         *m_pAudioCodec;
-  unsigned int              m_speed;
+  int                       m_speed;
   bool                      m_silence;
   double                    m_audioClock;
   double m_error;    //last average error
diff -ENwbur xbmcfrodo/xbmc/cores/omxplayer/OMXPlayerVideo.cpp xbmc/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
--- xbmcfrodo/xbmc/cores/omxplayer/OMXPlayerVideo.cpp	2013-04-05 17:03:23.516620447 +0000
+++ xbmc/xbmc/cores/omxplayer/OMXPlayerVideo.cpp	2013-04-05 12:24:06.117796029 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -42,6 +42,7 @@
 #include "DVDOverlayRenderer.h"
 #include "settings/GUISettings.h"
 #include "settings/Settings.h"
+#include "settings/MediaSettings.h"
 #include "cores/VideoRenderers/RenderFormats.h"
 #include "cores/VideoRenderers/RenderFlags.h"
 
@@ -68,6 +69,7 @@
                                CDVDMessageQueue& parent)
 : CThread("COMXPlayerVideo")
 , m_messageQueue("video")
+, m_codecname("")
 , m_messageParent(parent)
 {
   m_av_clock              = av_clock;
@@ -79,7 +81,6 @@
   m_hdmi_clock_sync       = false;
   m_speed                 = DVD_PLAYSPEED_NORMAL;
   m_stalled               = false;
-  m_codecname             = "";
   m_iSubtitleDelay        = 0;
   m_FlipTimeStamp         = 0.0;
   m_bRenderSubs           = false;
@@ -96,6 +97,12 @@
   m_messageQueue.SetMaxTimeSize(8.0);
 
   m_dst_rect.SetRect(0, 0, 0, 0);
+  m_iSleepEndTime = 0.0;
+  m_Deinterlace = false;
+  m_audio_count = 0;
+  m_started = false;
+  m_flush = false;
+  m_view_mode = 0;
 }
 
 OMXPlayerVideo::~OMXPlayerVideo()
@@ -111,7 +118,7 @@
   */
 
   m_hints       = hints;
-  m_Deinterlace = ( g_settings.m_currentVideoSettings.m_DeinterlaceMode == VS_DEINTERLACEMODE_OFF ) ? false : true;
+  m_Deinterlace = ( CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode == VS_DEINTERLACEMODE_OFF ) ? false : true;
   m_hdmi_clock_sync = (g_guiSettings.GetInt("videoplayer.adjustrefreshrate") != ADJUST_REFRESHRATE_OFF);
   m_started     = false;
   m_flush       = false;
@@ -350,7 +357,7 @@
   if (!CThread::m_bStop && m_av_clock->GetAbsoluteClock(false) < m_iSleepEndTime + DVD_MSEC_TO_TIME(500))
     return;
 
-  double pts_media = m_av_clock->OMXMediaTime(false, false);
+  double pts_media = m_av_clock->OMXMediaTime(false);
   ProcessOverlays(iGroupId, pts_media);
 
   g_renderManager.FlipPage(CThread::m_bStop, m_iSleepEndTime / DVD_TIME_BASE, -1, FS_NONE);
@@ -377,26 +384,11 @@
 
     if (MSGQ_IS_ERROR(ret) || ret == MSGQ_ABORT)
     {
-      CLog::Log(LOGERROR, "Got MSGQ_ABORT or MSGO_IS_ERROR return true");
+      CLog::Log(LOGERROR, "OMXPlayerVideo: Got MSGQ_IS_ERROR(%d) Aborting", (int)ret);
       break;
     }
     else if (ret == MSGQ_TIMEOUT)
     {
-      // if we only wanted priority messages, this isn't a stall
-      if( iPriority )
-        continue;
-
-      //Okey, start rendering at stream fps now instead, we are likely in a stillframe
-      if( !m_stalled )
-      {
-        if(m_started)
-          CLog::Log(LOGINFO, "COMXPlayerVideo - Stillframe detected, switching to forced %f fps", m_fFrameRate);
-        m_stalled = true;
-        pts += frametime*4;
-      }
-
-      pts += frametime;
-
       continue;
     }
 
@@ -454,8 +446,8 @@
     }
     else if (pMsg->IsType(CDVDMsg::VIDEO_SET_ASPECT))
     {
-      CLog::Log(LOGDEBUG, "COMXPlayerVideo - CDVDMsg::VIDEO_SET_ASPECT");
       m_fForcedAspectRatio = *((CDVDMsgDouble*)pMsg);
+      CLog::Log(LOGDEBUG, "COMXPlayerVideo - CDVDMsg::VIDEO_SET_ASPECT %.2f", m_fForcedAspectRatio);
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_RESET))
     {
@@ -483,13 +475,30 @@
     }
     else if (pMsg->IsType(CDVDMsg::PLAYER_SETSPEED))
     {
+      if (m_speed != static_cast<CDVDMsgInt*>(pMsg)->m_value)
+      {
       m_speed = static_cast<CDVDMsgInt*>(pMsg)->m_value;
+        CLog::Log(LOGDEBUG, "COMXPlayerVideo - CDVDMsg::PLAYER_SETSPEED %d", m_speed);
+      }
     }
     else if (pMsg->IsType(CDVDMsg::PLAYER_STARTED))
     {
+      CLog::Log(LOGDEBUG, "COMXPlayerVideo - CDVDMsg::PLAYER_STARTED %d", m_started);
       if(m_started)
         m_messageParent.Put(new CDVDMsgInt(CDVDMsg::PLAYER_STARTED, DVDPLAYER_VIDEO));
     }
+    else if (pMsg->IsType(CDVDMsg::PLAYER_DISPLAYTIME))
+    {
+      COMXPlayer::SPlayerState& state = ((CDVDMsgType<COMXPlayer::SPlayerState>*)pMsg)->m_value;
+
+      if(state.time_src == COMXPlayer::ETIMESOURCE_CLOCK)
+        state.time      = DVD_TIME_TO_MSEC(m_av_clock->OMXMediaTime(true));
+        //state.time      = DVD_TIME_TO_MSEC(m_av_clock->GetClock(state.timestamp) + state.time_offset);
+      else
+        state.timestamp = m_av_clock->GetAbsoluteClock();
+      state.player    = DVDPLAYER_VIDEO;
+      m_messageParent.Put(pMsg->Acquire());
+    }
     else if (pMsg->IsType(CDVDMsg::GENERAL_STREAMCHANGE))
     {
       COMXMsgVideoCodecChange* msg(static_cast<COMXMsgVideoCodecChange*>(pMsg));
@@ -506,6 +515,10 @@
       DemuxPacket* pPacket = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacket();
       bool bPacketDrop     = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacketDrop();
 
+      #ifdef _DEBUG
+      CLog::Log(LOGINFO, "Video: dts:%.0f pts:%.0f size:%d (s:%d f:%d d:%d l:%d) s:%d %d/%d late:%d\n", pPacket->dts, pPacket->pts, 
+          (int)pPacket->iSize, m_started, m_flush, bPacketDrop, m_stalled, m_speed, 0, 0, m_av_clock->OMXLateCount(1));
+      #endif
       if (m_messageQueue.GetDataSize() == 0
       ||  m_speed < 0)
       {
@@ -638,7 +651,6 @@
     CLog::Log(LOGINFO, "OMXPlayerVideo::OpenDecoder fps: %f %s\n", m_fFrameRate, command);
     m_DllBcmHost.vc_gencmd(response, sizeof response, command);
 
-    if(m_av_clock)
       m_av_clock->SetRefreshRate(m_fFrameRate);
   }
 
@@ -713,10 +725,10 @@
 void OMXPlayerVideo::SetVideoRect(const CRect &SrcRect, const CRect &DestRect)
 {
   // check if destination rect or video view mode has changed
-  if ((m_dst_rect != DestRect) || (m_view_mode != g_settings.m_currentVideoSettings.m_ViewMode))
+  if ((m_dst_rect != DestRect) || (m_view_mode != CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode))
   {
     m_dst_rect  = DestRect;
-    m_view_mode = g_settings.m_currentVideoSettings.m_ViewMode;
+    m_view_mode = CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode;
   }
   else
   {
@@ -727,8 +739,8 @@
   // to separate video plane that is at display size.
   CRect gui, display, dst_rect;
   RESOLUTION res = g_graphicsContext.GetVideoResolution();
-  gui.SetRect(0, 0, g_settings.m_ResInfo[res].iWidth, g_settings.m_ResInfo[res].iHeight);
-  display.SetRect(0, 0, g_settings.m_ResInfo[res].iScreenWidth, g_settings.m_ResInfo[res].iScreenHeight);
+  gui.SetRect(0, 0, CDisplaySettings::Get().GetResolutionInfo(res).iWidth, CDisplaySettings::Get().GetResolutionInfo(res).iHeight);
+  display.SetRect(0, 0, CDisplaySettings::Get().GetResolutionInfo(res).iScreenWidth, CDisplaySettings::Get().GetResolutionInfo(res).iScreenHeight);
   
   dst_rect = m_dst_rect;
   if (gui != display)
@@ -755,8 +767,8 @@
 void OMXPlayerVideo::ResolutionUpdateCallBack(uint32_t width, uint32_t height)
 {
   RESOLUTION res  = g_graphicsContext.GetVideoResolution();
-  uint32_t video_width   = g_settings.m_ResInfo[res].iScreenWidth;
-  uint32_t video_height  = g_settings.m_ResInfo[res].iScreenHeight;
+  uint32_t video_width   = CDisplaySettings::Get().GetResolutionInfo(res).iScreenWidth;
+  uint32_t video_height  = CDisplaySettings::Get().GetResolutionInfo(res).iScreenHeight;
 
   unsigned flags = 0;
   ERenderFormat format = RENDER_FMT_BYPASS;
diff -ENwbur xbmcfrodo/xbmc/cores/omxplayer/OMXPlayerVideo.h xbmc/xbmc/cores/omxplayer/OMXPlayerVideo.h
--- xbmcfrodo/xbmc/cores/omxplayer/OMXPlayerVideo.h	2013-04-05 17:03:23.516620447 +0000
+++ xbmc/xbmc/cores/omxplayer/OMXPlayerVideo.h	2013-04-03 14:20:37.328135393 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -38,6 +38,7 @@
 #include "DVDMessageQueue.h"
 #include "utils/BitstreamStats.h"
 #include "linux/DllBCM.h"
+#include "cores/VideoRenderers/RenderManager.h"
 
 using namespace std;
 
@@ -125,6 +126,7 @@
   void EnableSubtitle(bool bEnable)                 { m_bRenderSubs = bEnable; }
   bool IsSubtitleEnabled()                          { return m_bRenderSubs; }
   void EnableFullscreen(bool bEnable)               { m_bAllowFullscreen = bEnable; }
+  float GetAspectRatio()                            { return g_renderManager.GetAspectRatio(); }
   void SetFlags(unsigned flags)                     { m_flags = flags; };
   int GetFreeSpace();
   void  SetVideoRect(const CRect &SrcRect, const CRect &DestRect);
diff -ENwbur xbmcfrodo/xbmc/cores/omxplayer/OMXVideo.cpp xbmc/xbmc/cores/omxplayer/OMXVideo.cpp
--- xbmcfrodo/xbmc/cores/omxplayer/OMXVideo.cpp	2013-04-05 17:03:23.516620447 +0000
+++ xbmc/xbmc/cores/omxplayer/OMXVideo.cpp	2013-04-05 12:24:06.127795848 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -69,20 +69,29 @@
 #define OMX_MPEG2V_DECODER      OMX_VIDEO_DECODER
 #define OMX_VC1_DECODER         OMX_VIDEO_DECODER
 #define OMX_WMV3_DECODER        OMX_VIDEO_DECODER
+#define OMX_VP6_DECODER         OMX_VIDEO_DECODER
 #define OMX_VP8_DECODER         OMX_VIDEO_DECODER
+#define OMX_THEORA_DECODER      OMX_VIDEO_DECODER
+#define OMX_MJPEG_DECODER       OMX_VIDEO_DECODER
 
 #define MAX_TEXT_LENGTH 1024
 
-COMXVideo::COMXVideo()
+COMXVideo::COMXVideo() : m_video_codec_name("")
 {
   m_is_open           = false;
   m_Pause             = false;
   m_extradata         = NULL;
   m_extrasize         = 0;
   m_video_convert     = false;
-  m_video_codec_name  = "";
   m_deinterlace       = false;
   m_hdmi_clock_sync   = false;
+  m_drop_state        = false;
+  m_decoded_width     = 0;
+  m_decoded_height    = 0;
+  m_omx_clock         = NULL;
+  m_av_clock          = NULL;
+  m_res_callback      = NULL;
+  m_res_ctx           = NULL;
 }
 
 COMXVideo::~COMXVideo()
@@ -144,6 +153,7 @@
 
 bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, bool deinterlace, bool hdmi_clock_sync)
 {
+  bool vflip = false;
   Close();
 
   OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
@@ -250,6 +260,18 @@
       m_codingType = OMX_VIDEO_CodingMPEG4;
       m_video_codec_name = "omx-h263";
       break;
+    case CODEC_ID_VP6:
+      // this form is encoded upside down
+      vflip = true;
+      // fall through
+    case CODEC_ID_VP6F:
+    case CODEC_ID_VP6A:
+      // (role name) video_decoder.vp6
+      // VP6
+      decoder_name = OMX_VP6_DECODER;
+      m_codingType = OMX_VIDEO_CodingVP6;
+      m_video_codec_name = "omx-vp6";
+    break;
     case CODEC_ID_VP8:
       // (role name) video_decoder.vp8
       // VP8
@@ -257,6 +279,21 @@
       m_codingType = OMX_VIDEO_CodingVP8;
       m_video_codec_name = "omx-vp8";
     break;
+    case CODEC_ID_THEORA:
+      // (role name) video_decoder.theora
+      // theora
+      decoder_name = OMX_THEORA_DECODER;
+      m_codingType = OMX_VIDEO_CodingTheora;
+      m_video_codec_name = "omx-theora";
+    break;
+    case CODEC_ID_MJPEG:
+    case CODEC_ID_MJPEGB:
+      // (role name) video_decoder.mjpg
+      // mjpg
+      decoder_name = OMX_MJPEG_DECODER;
+      m_codingType = OMX_VIDEO_CodingMJPEG;
+      m_video_codec_name = "omx-mjpeg";
+    break;
     case CODEC_ID_VC1:
     case CODEC_ID_WMV3:
       // (role name) video_decoder.vc1
@@ -279,9 +316,7 @@
   if(m_deinterlace)
     CLog::Log(LOGDEBUG, "COMXVideo::Open : enable deinterlace\n");
 
-  std::string componentName = "";
-
-  componentName = decoder_name;
+  std::string componentName = decoder_name;
   if(!m_omx_decoder.Initialize((const std::string)componentName, OMX_IndexParamVideoInit))
     return false;
 
@@ -596,6 +631,8 @@
       configDisplay.transform = OMX_DISPLAY_ROT0;
       break;
   }
+  if (vflip)
+      configDisplay.transform = OMX_DISPLAY_MIRROR_ROT180;
 
   omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
   if(omx_err != OMX_ErrorNone)
@@ -802,6 +839,7 @@
         omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
         if (omx_err == OMX_ErrorNone)
         {
+          //CLog::Log(LOGINFO, "VideD: dts:%.0f pts:%.0f size:%d)\n", dts, pts, iSize);
           break;
         }
         else
@@ -962,11 +1000,11 @@
   // doesn't like negative coordinates on dest_rect. So adjust by increasing src_rect
   if (dx1 < 0.0f) {
     sx1 -= dx1 * sw;
-    dx1 -= dx1;
+    dx1 = 0;
   }
   if (dy1 < 0.0f) {
     sy1 -= dy1 * sh;
-    dy1 -= dy1;
+    dy1 = 0;
   }
 
   OMX_INIT_STRUCTURE(configDisplay);
diff -ENwbur xbmcfrodo/xbmc/cores/omxplayer/OMXVideo.h xbmc/xbmc/cores/omxplayer/OMXVideo.h
--- xbmcfrodo/xbmc/cores/omxplayer/OMXVideo.h	2013-04-05 17:03:23.526620269 +0000
+++ xbmc/xbmc/cores/omxplayer/OMXVideo.h	2013-03-01 05:57:24.499704607 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2010-2012 Team XBMC
+ *      Copyright (C) 2010-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/omxplayer/OMXVideoCodec.h xbmc/xbmc/cores/omxplayer/OMXVideoCodec.h
--- xbmcfrodo/xbmc/cores/omxplayer/OMXVideoCodec.h	2013-04-05 17:03:23.536620091 +0000
+++ xbmc/xbmc/cores/omxplayer/OMXVideoCodec.h	2013-02-10 14:23:18.776510160 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/ADPCMCodec.cpp xbmc/xbmc/cores/paplayer/ADPCMCodec.cpp
--- xbmcfrodo/xbmc/cores/paplayer/ADPCMCodec.cpp	2013-02-16 18:48:38.654388082 +0000
+++ xbmc/xbmc/cores/paplayer/ADPCMCodec.cpp	2013-02-10 14:23:18.776510160 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/ADPCMCodec.h xbmc/xbmc/cores/paplayer/ADPCMCodec.h
--- xbmcfrodo/xbmc/cores/paplayer/ADPCMCodec.h	2013-02-16 18:48:38.654388082 +0000
+++ xbmc/xbmc/cores/paplayer/ADPCMCodec.h	2013-02-10 14:23:18.776510160 +0000
@@ -1,7 +1,7 @@
 #ifndef ADPCM_CODEC_H_
 #define ADPCM_CODEC_H_
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/ASAPCodec.cpp xbmc/xbmc/cores/paplayer/ASAPCodec.cpp
--- xbmcfrodo/xbmc/cores/paplayer/ASAPCodec.cpp	2013-02-16 18:48:38.664387884 +0000
+++ xbmc/xbmc/cores/paplayer/ASAPCodec.cpp	2013-02-10 14:23:18.776510160 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/ASAPCodec.h xbmc/xbmc/cores/paplayer/ASAPCodec.h
--- xbmcfrodo/xbmc/cores/paplayer/ASAPCodec.h	2013-02-16 18:48:38.664387884 +0000
+++ xbmc/xbmc/cores/paplayer/ASAPCodec.h	2013-02-10 14:23:18.776510160 +0000
@@ -2,7 +2,7 @@
 #define ASAP_CODEC_H_
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/AudioDecoder.cpp xbmc/xbmc/cores/paplayer/AudioDecoder.cpp
--- xbmcfrodo/xbmc/cores/paplayer/AudioDecoder.cpp	2013-02-16 18:48:38.664387884 +0000
+++ xbmc/xbmc/cores/paplayer/AudioDecoder.cpp	2013-04-05 11:38:44.026812641 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -27,6 +27,8 @@
 #include "utils/log.h"
 #include <math.h>
 
+ReplayGainSettings CAudioDecoder::m_replayGainSettings;
+
 CAudioDecoder::CAudioDecoder()
 {
   m_codec = NULL;
@@ -35,6 +37,12 @@
 
   m_status = STATUS_NO_FILE;
   m_canPlay = false;
+
+  // output buffer (for transferring data from the Pcm Buffer to the rest of the audio chain)
+  memset(&m_outputBuffer, 0, OUTPUT_SAMPLES * sizeof(float));
+  memset(&m_pcmInputBuffer, 0, INPUT_SIZE * sizeof(BYTE));
+  memset(&m_inputBuffer, 0, INPUT_SAMPLES * sizeof(float));
+
 }
 
 CAudioDecoder::~CAudioDecoder()
@@ -235,42 +243,42 @@
 float CAudioDecoder::GetReplayGain()
 {
 #define REPLAY_GAIN_DEFAULT_LEVEL 89.0f
-  if (g_guiSettings.m_replayGain.iType == REPLAY_GAIN_NONE)
+  if (m_replayGainSettings.iType == REPLAY_GAIN_NONE)
     return 1.0f;
 
   // Compute amount of gain
-  float replaydB = (float)g_guiSettings.m_replayGain.iNoGainPreAmp;
+  float replaydB = (float)m_replayGainSettings.iNoGainPreAmp;
   float peak = 0.0f;
-  if (g_guiSettings.m_replayGain.iType == REPLAY_GAIN_ALBUM)
+  if (m_replayGainSettings.iType == REPLAY_GAIN_ALBUM)
   {
     if (m_codec->m_tag.HasReplayGainInfo() & REPLAY_GAIN_HAS_ALBUM_INFO)
     {
-      replaydB = (float)g_guiSettings.m_replayGain.iPreAmp + (float)m_codec->m_tag.GetReplayGainAlbumGain() * 0.01f;
+      replaydB = (float)m_replayGainSettings.iPreAmp + (float)m_codec->m_tag.GetReplayGainAlbumGain() * 0.01f;
       peak = m_codec->m_tag.GetReplayGainAlbumPeak();
     }
     else if (m_codec->m_tag.HasReplayGainInfo() & REPLAY_GAIN_HAS_TRACK_INFO)
     {
-      replaydB = (float)g_guiSettings.m_replayGain.iPreAmp + (float)m_codec->m_tag.GetReplayGainTrackGain() * 0.01f;
+      replaydB = (float)m_replayGainSettings.iPreAmp + (float)m_codec->m_tag.GetReplayGainTrackGain() * 0.01f;
       peak = m_codec->m_tag.GetReplayGainTrackPeak();
     }
   }
-  else if (g_guiSettings.m_replayGain.iType == REPLAY_GAIN_TRACK)
+  else if (m_replayGainSettings.iType == REPLAY_GAIN_TRACK)
   {
     if (m_codec->m_tag.HasReplayGainInfo() & REPLAY_GAIN_HAS_TRACK_INFO)
     {
-      replaydB = (float)g_guiSettings.m_replayGain.iPreAmp + (float)m_codec->m_tag.GetReplayGainTrackGain() * 0.01f;
+      replaydB = (float)m_replayGainSettings.iPreAmp + (float)m_codec->m_tag.GetReplayGainTrackGain() * 0.01f;
       peak = m_codec->m_tag.GetReplayGainTrackPeak();
     }
     else if (m_codec->m_tag.HasReplayGainInfo() & REPLAY_GAIN_HAS_ALBUM_INFO)
     {
-      replaydB = (float)g_guiSettings.m_replayGain.iPreAmp + (float)m_codec->m_tag.GetReplayGainAlbumGain() * 0.01f;
+      replaydB = (float)m_replayGainSettings.iPreAmp + (float)m_codec->m_tag.GetReplayGainAlbumGain() * 0.01f;
       peak = m_codec->m_tag.GetReplayGainAlbumPeak();
     }
   }
   // convert to a gain type
   float replaygain = pow(10.0f, (replaydB - REPLAY_GAIN_DEFAULT_LEVEL)* 0.05f);
   // check peaks
-  if (g_guiSettings.m_replayGain.bAvoidClipping)
+  if (m_replayGainSettings.bAvoidClipping)
   {
     if (fabs(peak * replaygain) > 1.0f)
       replaygain = 1.0f / fabs(peak);
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/AudioDecoder.h xbmc/xbmc/cores/paplayer/AudioDecoder.h
--- xbmcfrodo/xbmc/cores/paplayer/AudioDecoder.h	2013-02-16 18:48:38.664387884 +0000
+++ xbmc/xbmc/cores/paplayer/AudioDecoder.h	2013-04-04 22:52:33.207557280 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -50,12 +50,24 @@
 #define RET_SUCCESS 0
 #define RET_SLEEP 1
 
+// replay gain settings struct for quick access by the player multiple
+// times per second (saves doing settings lookup)
+struct ReplayGainSettings
+{
+  int iPreAmp;
+  int iNoGainPreAmp;
+  int iType;
+  bool bAvoidClipping;
+};
+
 class CAudioDecoder
 {
 public:
   CAudioDecoder();
   ~CAudioDecoder();
 
+  static ReplayGainSettings& GetReplayGainSettings() { return m_replayGainSettings; }
+
   bool Create(const CFileItem &file, int64_t seekOffset);
   void Destroy();
 
@@ -77,6 +89,8 @@
   float GetReplayGain();
 
 private:
+  static ReplayGainSettings m_replayGainSettings;
+
   // pcm buffer
   CRingBuffer m_pcmBuffer;
 
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/CDDAcodec.cpp xbmc/xbmc/cores/paplayer/CDDAcodec.cpp
--- xbmcfrodo/xbmc/cores/paplayer/CDDAcodec.cpp	2013-02-16 18:48:38.674387685 +0000
+++ xbmc/xbmc/cores/paplayer/CDDAcodec.cpp	2013-02-10 14:23:18.786509965 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/CDDAcodec.h xbmc/xbmc/cores/paplayer/CDDAcodec.h
--- xbmcfrodo/xbmc/cores/paplayer/CDDAcodec.h	2013-02-16 18:48:38.674387685 +0000
+++ xbmc/xbmc/cores/paplayer/CDDAcodec.h	2013-02-10 14:23:18.786509965 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/CachingCodec.h xbmc/xbmc/cores/paplayer/CachingCodec.h
--- xbmcfrodo/xbmc/cores/paplayer/CachingCodec.h	2013-02-16 18:48:38.674387685 +0000
+++ xbmc/xbmc/cores/paplayer/CachingCodec.h	2013-02-10 14:23:18.786509965 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/CodecFactory.cpp xbmc/xbmc/cores/paplayer/CodecFactory.cpp
--- xbmcfrodo/xbmc/cores/paplayer/CodecFactory.cpp	2013-02-25 18:48:14.197719386 +0000
+++ xbmc/xbmc/cores/paplayer/CodecFactory.cpp	2013-03-06 22:06:34.902980890 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -150,7 +150,7 @@
   else if (strContent.Equals("audio/flac") || strContent.Equals("audio/x-flac") || strContent.Equals("application/x-flac"))
     return new FLACCodec();
 
-  if (urlFile.GetProtocol() == "lastfm" || urlFile.GetProtocol() == "shout")
+  if (urlFile.GetProtocol() == "shout")
   {
     return new MP3Codec(); // if we got this far with internet radio - content-type was wrong. gamble on mp3.
   }
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/CodecFactory.h xbmc/xbmc/cores/paplayer/CodecFactory.h
--- xbmcfrodo/xbmc/cores/paplayer/CodecFactory.h	2013-02-16 18:48:38.674387685 +0000
+++ xbmc/xbmc/cores/paplayer/CodecFactory.h	2013-02-10 14:23:18.786509965 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/DVDPlayerCodec.cpp xbmc/xbmc/cores/paplayer/DVDPlayerCodec.cpp
--- xbmcfrodo/xbmc/cores/paplayer/DVDPlayerCodec.cpp	2013-02-16 18:48:38.674387685 +0000
+++ xbmc/xbmc/cores/paplayer/DVDPlayerCodec.cpp	2013-02-10 14:23:18.786509965 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/DVDPlayerCodec.h xbmc/xbmc/cores/paplayer/DVDPlayerCodec.h
--- xbmcfrodo/xbmc/cores/paplayer/DVDPlayerCodec.h	2013-02-16 18:48:38.674387685 +0000
+++ xbmc/xbmc/cores/paplayer/DVDPlayerCodec.h	2013-02-10 14:23:18.786509965 +0000
@@ -2,7 +2,7 @@
 #define DVDPLAYER_CODEC_H_
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/FLACcodec.cpp xbmc/xbmc/cores/paplayer/FLACcodec.cpp
--- xbmcfrodo/xbmc/cores/paplayer/FLACcodec.cpp	2013-02-16 18:48:38.674387685 +0000
+++ xbmc/xbmc/cores/paplayer/FLACcodec.cpp	2013-02-10 14:23:18.786509965 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/FLACcodec.h xbmc/xbmc/cores/paplayer/FLACcodec.h
--- xbmcfrodo/xbmc/cores/paplayer/FLACcodec.h	2013-02-16 18:48:38.674387685 +0000
+++ xbmc/xbmc/cores/paplayer/FLACcodec.h	2013-02-10 14:23:18.796509771 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/ICodec.h xbmc/xbmc/cores/paplayer/ICodec.h
--- xbmcfrodo/xbmc/cores/paplayer/ICodec.h	2013-02-16 18:48:38.684387486 +0000
+++ xbmc/xbmc/cores/paplayer/ICodec.h	2013-02-10 14:23:18.796509771 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/MP3codec.cpp xbmc/xbmc/cores/paplayer/MP3codec.cpp
--- xbmcfrodo/xbmc/cores/paplayer/MP3codec.cpp	2013-02-16 18:48:38.684387486 +0000
+++ xbmc/xbmc/cores/paplayer/MP3codec.cpp	2013-04-05 11:38:44.026812641 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -174,7 +174,7 @@
   length = m_file.GetLength();
   if (length != 0)
   {
-    CTagLoaderTagLib tagLoaderTagLib; //opens the file so needs to be after m_file.Open or lastfm radio breaks.
+    CTagLoaderTagLib tagLoaderTagLib; //opens the file so needs to be after m_file.Open 
     bTags = tagLoaderTagLib.Load(strFile, m_tag);
 
     if (bTags)
@@ -276,8 +276,6 @@
   // Decode data if we have some to decode
   if ( m_InputBufferPos || m_CallAgainWithSameBuffer || (m_eof && m_Decoding) )
   {
-    int result;
-
     m_Decoding = true;
 
     if ( size )
@@ -306,7 +304,7 @@
       }
 
       // Now decode data into the vacant frame buffer.
-      result = Decode(&outputsize);
+      int result = Decode(&outputsize);
       if ( result != DECODING_ERROR)
       {
         if (init)
@@ -771,7 +769,7 @@
   //find lame/xing info
   int frequency = 0, bitrate = 0, bittable = 0;
   int frame_count = 0;
-  double tpf = 0.0, bpf = 0.0;
+  double tpf = 0.0;
   for (int i = 0; i < iScanSize; i++)
   {
     unsigned long mpegheader = (unsigned long)(
@@ -886,23 +884,6 @@
       int freqindex = (mpegheader & 0x0C00) >> 10;
       bitrate = bitrate_table[bittable][layer][bitindex];
 
-      /* Calculate bytes per frame, calculation depends on layer */
-      switch (layer)
-      {
-        case 1:
-          bpf = bitrate;
-          bpf *= 48000;
-          bpf /= freqtab[version][freqindex] << (version - 1);
-          break;
-        case 2:
-        case 3:
-          bpf = bitrate;
-          bpf *= 144000;
-          bpf /= freqtab[version][freqindex] << (version - 1);
-          break;
-        default:
-          bpf = 1;
-      }
       double tpfbs[] = { 0, 384.0f, 1152.0f, 1152.0f };
       frequency = freqtab[version][freqindex];
       tpf = tpfbs[layer] / (double) frequency;
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/MP3codec.h xbmc/xbmc/cores/paplayer/MP3codec.h
--- xbmcfrodo/xbmc/cores/paplayer/MP3codec.h	2013-02-16 18:48:38.694387288 +0000
+++ xbmc/xbmc/cores/paplayer/MP3codec.h	2013-04-05 11:38:44.026812641 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -68,7 +68,7 @@
   static unsigned int IsID3v2Header(unsigned char* pBuf, size_t bufLen);
   virtual int         ReadDuration();
   bool                ReadLAMETagInfo(unsigned char *p);
-  int                 IsMp3FrameHeader(unsigned long head);
+  static int                 IsMp3FrameHeader(unsigned long head);
   int64_t             GetByteOffset(float fTime);
   int64_t             GetTimeOffset(int64_t iBytes);
   void                SetOffsets(int iSeekOffsets, const float *offsets);
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/ModplugCodec.cpp xbmc/xbmc/cores/paplayer/ModplugCodec.cpp
--- xbmcfrodo/xbmc/cores/paplayer/ModplugCodec.cpp	2013-02-16 18:48:38.694387288 +0000
+++ xbmc/xbmc/cores/paplayer/ModplugCodec.cpp	2013-02-10 14:23:18.796509771 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2009-2012 Team XBMC
+ *      Copyright (C) 2009-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/ModplugCodec.h xbmc/xbmc/cores/paplayer/ModplugCodec.h
--- xbmcfrodo/xbmc/cores/paplayer/ModplugCodec.h	2013-02-16 18:48:38.694387288 +0000
+++ xbmc/xbmc/cores/paplayer/ModplugCodec.h	2013-02-10 14:23:18.796509771 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2009-2012 Team XBMC
+ *      Copyright (C) 2009-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/NSFCodec.cpp xbmc/xbmc/cores/paplayer/NSFCodec.cpp
--- xbmcfrodo/xbmc/cores/paplayer/NSFCodec.cpp	2013-02-16 18:48:38.694387288 +0000
+++ xbmc/xbmc/cores/paplayer/NSFCodec.cpp	2013-02-10 14:23:18.806509578 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/NSFCodec.h xbmc/xbmc/cores/paplayer/NSFCodec.h
--- xbmcfrodo/xbmc/cores/paplayer/NSFCodec.h	2013-02-16 18:48:38.694387288 +0000
+++ xbmc/xbmc/cores/paplayer/NSFCodec.h	2013-02-10 14:23:18.806509578 +0000
@@ -2,7 +2,7 @@
 #define NSF_CODEC_H_
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/OGGcodec.cpp xbmc/xbmc/cores/paplayer/OGGcodec.cpp
--- xbmcfrodo/xbmc/cores/paplayer/OGGcodec.cpp	2013-02-16 18:48:38.694387288 +0000
+++ xbmc/xbmc/cores/paplayer/OGGcodec.cpp	2013-02-10 14:23:18.806509578 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/OGGcodec.h xbmc/xbmc/cores/paplayer/OGGcodec.h
--- xbmcfrodo/xbmc/cores/paplayer/OGGcodec.h	2013-02-16 18:48:38.704387091 +0000
+++ xbmc/xbmc/cores/paplayer/OGGcodec.h	2013-02-10 14:23:18.806509578 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/OggCallback.cpp xbmc/xbmc/cores/paplayer/OggCallback.cpp
--- xbmcfrodo/xbmc/cores/paplayer/OggCallback.cpp	2013-02-16 18:48:38.704387091 +0000
+++ xbmc/xbmc/cores/paplayer/OggCallback.cpp	2013-02-10 14:23:18.806509578 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/OggCallback.h xbmc/xbmc/cores/paplayer/OggCallback.h
--- xbmcfrodo/xbmc/cores/paplayer/OggCallback.h	2013-02-16 18:48:38.704387091 +0000
+++ xbmc/xbmc/cores/paplayer/OggCallback.h	2013-04-05 11:38:44.026812641 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -28,7 +28,7 @@
 public:
   COggCallback(XFILE::CFile& file);
 
-  ov_callbacks Get(const CStdString& strFile);
+  static ov_callbacks Get(const CStdString& strFile);
 
   static size_t ReadCallback(void *ptr, size_t size, size_t nmemb, void *datasource);
   static int    SeekCallback(void *datasource, ogg_int64_t offset, int whence);
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/PAPlayer.cpp xbmc/xbmc/cores/paplayer/PAPlayer.cpp
--- xbmcfrodo/xbmc/cores/paplayer/PAPlayer.cpp	2013-02-19 17:48:55.471699631 +0000
+++ xbmc/xbmc/cores/paplayer/PAPlayer.cpp	2013-03-09 14:45:49.566125267 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -66,12 +66,7 @@
 
 PAPlayer::~PAPlayer()
 {
-  if (!m_isPaused)
-    SoftStop(true, true);
-  CloseAllStreams(false);
-
-  /* wait for the thread to terminate */
-  StopThread(true);//true - wait for end of thread
+  CloseFile();
   delete m_FileItem;
 }
 
@@ -96,8 +91,8 @@
     if (si->m_fadeOutTriggered)
       continue;
 
-    si->m_stream->FadeVolume(0.0f, 1.0f, FAST_XFADE_TIME);
     si->m_stream->Resume();
+    si->m_stream->FadeVolume(0.0f, 1.0f, FAST_XFADE_TIME);
   }
   
   if (wait)
@@ -234,6 +229,7 @@
   if (m_streams.size() > 1 || !m_defaultCrossfadeMS || m_isPaused)
   {
     CloseAllStreams(!m_isPaused);
+    StopThread();
     m_isPaused = false; // Make sure to reset the pause state
   }
 
@@ -447,7 +443,12 @@
 
 bool PAPlayer::CloseFile()
 {
-  m_callback.OnPlayBackStopped();
+  if (!m_isPaused)
+    SoftStop(true, true);
+  CloseAllStreams(false);
+
+  /* wait for the thread to terminate */
+  StopThread(true);//true - wait for end of thread
   return true;
 }
 
@@ -490,6 +491,11 @@
 
     GetTimeInternal(); //update for GUI
   }
+
+  if(m_isFinished && !m_bStop)
+    m_callback.OnPlayBackEnded();
+  else
+    m_callback.OnPlayBackStopped();
 }
 
 inline void PAPlayer::ProcessStreams(double &delay, double &buffer)
@@ -499,7 +505,6 @@
   {
     m_isPlaying = false;
     delay       = 0;
-    m_callback.OnPlayBackEnded();
     return;
   }
 
@@ -819,11 +824,6 @@
   return m_playerGUIData.m_cacheLevel;
 }
 
-int PAPlayer::GetChannels()
-{
-  return m_playerGUIData.m_channelCount;
-}
-
 int PAPlayer::GetBitsPerSample()
 {
   return m_playerGUIData.m_bitsPerSample;
@@ -834,14 +834,11 @@
   return m_playerGUIData.m_sampleRate;
 }
 
-CStdString PAPlayer::GetAudioCodecName()
-{
-  return m_playerGUIData.m_codec;
-}
-
-int PAPlayer::GetAudioBitrate()
+void PAPlayer::GetAudioStreamInfo(int index, SPlayerAudioStreamInfo &info)
 {
-  return m_playerGUIData.m_audioBitrate;
+  info.bitrate = m_playerGUIData.m_audioBitrate;
+  info.channels = m_playerGUIData.m_channelCount;
+  info.audioCodecName = m_playerGUIData.m_codec;
 }
 
 bool PAPlayer::CanSeek()
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/PAPlayer.h xbmc/xbmc/cores/paplayer/PAPlayer.h
--- xbmcfrodo/xbmc/cores/paplayer/PAPlayer.h	2013-02-16 18:48:38.704387091 +0000
+++ xbmc/xbmc/cores/paplayer/PAPlayer.h	2013-03-02 12:30:08.678239105 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -63,11 +63,9 @@
   virtual void ToFFRW(int iSpeed = 0);
   virtual int GetCacheLevel() const;
   virtual int64_t GetTotalTime();
-  virtual int GetAudioBitrate();
-  virtual int GetChannels();
+  virtual void GetAudioStreamInfo(int index, SPlayerAudioStreamInfo &info);
   virtual int GetBitsPerSample();
   virtual int GetSampleRate();
-  virtual CStdString GetAudioCodecName();
   virtual int64_t GetTime();
   virtual void SeekTime(int64_t iTime = 0);
   virtual bool SkipNext();
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/PCMCodec.cpp xbmc/xbmc/cores/paplayer/PCMCodec.cpp
--- xbmcfrodo/xbmc/cores/paplayer/PCMCodec.cpp	2013-03-11 02:09:46.470993426 +0000
+++ xbmc/xbmc/cores/paplayer/PCMCodec.cpp	2013-02-10 14:23:18.816509384 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/PCMCodec.h xbmc/xbmc/cores/paplayer/PCMCodec.h
--- xbmcfrodo/xbmc/cores/paplayer/PCMCodec.h	2013-02-16 18:48:38.704387091 +0000
+++ xbmc/xbmc/cores/paplayer/PCMCodec.h	2013-02-10 14:23:18.816509384 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2011-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/SIDCodec.cpp xbmc/xbmc/cores/paplayer/SIDCodec.cpp
--- xbmcfrodo/xbmc/cores/paplayer/SIDCodec.cpp	2013-02-16 18:48:38.714386893 +0000
+++ xbmc/xbmc/cores/paplayer/SIDCodec.cpp	2013-02-10 14:23:18.816509384 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/SIDCodec.h xbmc/xbmc/cores/paplayer/SIDCodec.h
--- xbmcfrodo/xbmc/cores/paplayer/SIDCodec.h	2013-02-16 18:48:38.714386893 +0000
+++ xbmc/xbmc/cores/paplayer/SIDCodec.h	2013-02-10 14:23:18.816509384 +0000
@@ -2,7 +2,7 @@
 #define SID_CODEC_H_
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/SPCCodec.cpp xbmc/xbmc/cores/paplayer/SPCCodec.cpp
--- xbmcfrodo/xbmc/cores/paplayer/SPCCodec.cpp	2013-02-16 18:48:38.714386893 +0000
+++ xbmc/xbmc/cores/paplayer/SPCCodec.cpp	2013-02-10 14:23:18.816509384 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/SPCCodec.h xbmc/xbmc/cores/paplayer/SPCCodec.h
--- xbmcfrodo/xbmc/cores/paplayer/SPCCodec.h	2013-02-16 18:48:38.714386893 +0000
+++ xbmc/xbmc/cores/paplayer/SPCCodec.h	2013-02-10 14:23:18.816509384 +0000
@@ -2,7 +2,7 @@
 #define SPC_CODEC_H_
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/TimidityCodec.cpp xbmc/xbmc/cores/paplayer/TimidityCodec.cpp
--- xbmcfrodo/xbmc/cores/paplayer/TimidityCodec.cpp	2013-02-16 18:48:38.714386893 +0000
+++ xbmc/xbmc/cores/paplayer/TimidityCodec.cpp	2013-02-10 14:23:18.816509384 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/TimidityCodec.h xbmc/xbmc/cores/paplayer/TimidityCodec.h
--- xbmcfrodo/xbmc/cores/paplayer/TimidityCodec.h	2013-02-16 18:48:38.714386893 +0000
+++ xbmc/xbmc/cores/paplayer/TimidityCodec.h	2013-02-10 14:23:18.826509189 +0000
@@ -2,7 +2,7 @@
 #define Timidity_CODEC_H_
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/VGMCodec.cpp xbmc/xbmc/cores/paplayer/VGMCodec.cpp
--- xbmcfrodo/xbmc/cores/paplayer/VGMCodec.cpp	2013-02-16 18:48:38.724386694 +0000
+++ xbmc/xbmc/cores/paplayer/VGMCodec.cpp	2013-04-05 11:38:44.036812460 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -201,7 +201,6 @@
       strExt == "rwsd" ||
       strExt == "rwav" ||
       strExt == "rws" ||
-      strExt == "rwsd" ||
       strExt == "rwx" ||
       strExt == "rxw" ||
       strExt == "sad" ||
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/VGMCodec.h xbmc/xbmc/cores/paplayer/VGMCodec.h
--- xbmcfrodo/xbmc/cores/paplayer/VGMCodec.h	2013-02-16 18:48:38.724386694 +0000
+++ xbmc/xbmc/cores/paplayer/VGMCodec.h	2013-02-10 14:23:18.826509189 +0000
@@ -2,7 +2,7 @@
 #define CUBE_CODEC_H_
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/WAVcodec.cpp xbmc/xbmc/cores/paplayer/WAVcodec.cpp
--- xbmcfrodo/xbmc/cores/paplayer/WAVcodec.cpp	2013-02-16 18:48:38.724386694 +0000
+++ xbmc/xbmc/cores/paplayer/WAVcodec.cpp	2013-02-10 14:23:18.826509189 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/WAVcodec.h xbmc/xbmc/cores/paplayer/WAVcodec.h
--- xbmcfrodo/xbmc/cores/paplayer/WAVcodec.h	2013-02-16 18:48:38.724386694 +0000
+++ xbmc/xbmc/cores/paplayer/WAVcodec.h	2013-02-10 14:23:18.826509189 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/YMCodec.cpp xbmc/xbmc/cores/paplayer/YMCodec.cpp
--- xbmcfrodo/xbmc/cores/paplayer/YMCodec.cpp	2013-02-16 18:48:38.724386694 +0000
+++ xbmc/xbmc/cores/paplayer/YMCodec.cpp	2013-02-10 14:23:18.826509189 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/paplayer/YMCodec.h xbmc/xbmc/cores/paplayer/YMCodec.h
--- xbmcfrodo/xbmc/cores/paplayer/YMCodec.h	2013-02-16 18:48:38.724386694 +0000
+++ xbmc/xbmc/cores/paplayer/YMCodec.h	2013-02-10 14:23:18.826509189 +0000
@@ -2,7 +2,7 @@
 #define YM_CODEC_H_
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff -ENwbur xbmcfrodo/xbmc/cores/playercorefactory/PlayerCoreConfig.h xbmc/xbmc/cores/playercorefactory/PlayerCoreConfig.h
--- xbmcfrodo/xbmc/cores/playercorefactory/PlayerCoreConfig.h	2013-02-16 18:48:38.724386694 +0000
+++ xbmc/xbmc/cores/playercorefactory/PlayerCoreConfig.h	2013-02-10 14:23:18.836508994 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -31,6 +31,9 @@
 #include "cores/omxplayer/OMXPlayer.h"
 #endif
 #include "cores/ExternalPlayer/ExternalPlayer.h"
+#ifdef HAS_UPNP
+#include "network/upnp/UPnPPlayer.h"
+#endif
 #include "utils/log.h"
 
 class CPlayerCoreConfig
@@ -38,9 +41,10 @@
 friend class CPlayerCoreFactory;
 
 public:
-  CPlayerCoreConfig(CStdString name, const EPLAYERCORES eCore, const TiXmlElement* pConfig)
+  CPlayerCoreConfig(CStdString name, const EPLAYERCORES eCore, const TiXmlElement* pConfig, const CStdString& id = "")
   {
     m_name = name;
+    m_id = id;
     m_eCore = eCore;
     m_bPlaysAudio = false;
     m_bPlaysVideo = false;
@@ -70,6 +74,16 @@
     return m_name;
   }
 
+  const CStdString& GetId() const
+  {
+    return m_id;
+  }
+
+  const EPLAYERCORES& GetType() const
+  {
+    return m_eCore;
+  }
+
   IPlayer* CreatePlayer(IPlayerCallback& callback) const
   {
     IPlayer* pPlayer;
@@ -97,6 +111,9 @@
 #if defined(HAS_OMXPLAYER)
       case EPC_OMXPLAYER: pPlayer = new COMXPlayer(callback); break;
 #endif
+#if defined(HAS_UPNP)
+      case EPC_UPNPPLAYER: pPlayer = new UPNP::CUPnPPlayer(callback, m_id.c_str()); break;
+#endif
       default: return NULL;
     }
 
@@ -113,6 +130,7 @@
 
 private:
   CStdString m_name;
+  CStdString m_id;
   bool m_bPlaysAudio;
   bool m_bPlaysVideo;
   EPLAYERCORES m_eCore;
diff -ENwbur xbmcfrodo/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp xbmc/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp
--- xbmcfrodo/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp	2013-02-16 18:48:38.724386694 +0000
+++ xbmc/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp	2013-04-05 11:38:44.036812460 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -29,6 +29,7 @@
 #include "settings/GUISettings.h"
 #include "URL.h"
 #include "FileItem.h"
+#include "profiles/ProfilesManager.h"
 #include "settings/AdvancedSettings.h"
 #include "utils/AutoPtrHandle.h"
 #include "cores/ExternalPlayer/ExternalPlayer.h"
@@ -36,21 +37,33 @@
 #include "PlayerSelectionRule.h"
 #include "guilib/LocalizeStrings.h"
 
-using namespace AUTOPTR;
+#define PLAYERCOREFACTORY_XML "playercorefactory.xml"
 
-std::vector<CPlayerCoreConfig *> CPlayerCoreFactory::s_vecCoreConfigs;
-std::vector<CPlayerSelectionRule *> CPlayerCoreFactory::s_vecCoreSelectionRules;
+using namespace AUTOPTR;
 
 CPlayerCoreFactory::CPlayerCoreFactory()
 {}
+
 CPlayerCoreFactory::~CPlayerCoreFactory()
 {
-  for(std::vector<CPlayerCoreConfig *>::iterator it = s_vecCoreConfigs.begin(); it != s_vecCoreConfigs.end(); it++)
+  for(std::vector<CPlayerCoreConfig *>::iterator it = m_vecCoreConfigs.begin(); it != m_vecCoreConfigs.end(); ++it)
     delete *it;
-  for(std::vector<CPlayerSelectionRule *>::iterator it = s_vecCoreSelectionRules.begin(); it != s_vecCoreSelectionRules.end(); it++)
+  for(std::vector<CPlayerSelectionRule *>::iterator it = m_vecCoreSelectionRules.begin(); it != m_vecCoreSelectionRules.end(); ++it)
     delete *it;
 }
 
+CPlayerCoreFactory& CPlayerCoreFactory::Get()
+{
+  static CPlayerCoreFactory sPlayerCoreFactory;
+  return sPlayerCoreFactory;
+}
+
+void CPlayerCoreFactory::OnSettingsLoaded()
+{
+  LoadConfiguration("special://xbmc/system/" PLAYERCOREFACTORY_XML, true);
+  LoadConfiguration(CProfilesManager::Get().GetUserDataItem(PLAYERCOREFACTORY_XML), false);
+}
+
 /* generic function to make a vector unique, removes later duplicates */
 template<typename T> void unique (T &con)
 {
@@ -70,16 +83,18 @@
   return CreatePlayer( GetPlayerCore(strCore), callback );
 }
 
-IPlayer* CPlayerCoreFactory::CreatePlayer(const PLAYERCOREID eCore, IPlayerCallback& callback)
+IPlayer* CPlayerCoreFactory::CreatePlayer(const PLAYERCOREID eCore, IPlayerCallback& callback) const
 {
-  if (!s_vecCoreConfigs.size() || eCore-1 > s_vecCoreConfigs.size()-1)
+  CSingleLock lock(m_section);
+  if (m_vecCoreConfigs.empty() || eCore-1 > m_vecCoreConfigs.size()-1)
     return NULL;
 
-  return s_vecCoreConfigs[eCore-1]->CreatePlayer(callback);
+  return m_vecCoreConfigs[eCore-1]->CreatePlayer(callback);
 }
 
-PLAYERCOREID CPlayerCoreFactory::GetPlayerCore(const CStdString& strCoreName)
+PLAYERCOREID CPlayerCoreFactory::GetPlayerCore(const CStdString& strCoreName) const
 {
+  CSingleLock lock(m_section);
   if (!strCoreName.empty())
   {
     // Dereference "*default*player" aliases
@@ -89,9 +104,9 @@
     else if (strCoreName.Equals("videodefaultdvdplayer", false)) strRealCoreName = g_advancedSettings.m_videoDefaultDVDPlayer;
     else strRealCoreName = strCoreName;
 
-    for(PLAYERCOREID i = 0; i < s_vecCoreConfigs.size(); i++)
+    for(PLAYERCOREID i = 0; i < m_vecCoreConfigs.size(); i++)
     {
-      if (s_vecCoreConfigs[i]->GetName().Equals(strRealCoreName, false))
+      if (m_vecCoreConfigs[i]->GetName().Equals(strRealCoreName, false))
         return i+1;
     }
     CLog::Log(LOGWARNING, "CPlayerCoreFactory::GetPlayerCore(%s): no such core: %s", strCoreName.c_str(), strRealCoreName.c_str());
@@ -99,48 +114,58 @@
   return EPC_NONE;
 }
 
-CStdString CPlayerCoreFactory::GetPlayerName(const PLAYERCOREID eCore)
+CStdString CPlayerCoreFactory::GetPlayerName(const PLAYERCOREID eCore) const
 {
-  return s_vecCoreConfigs[eCore-1]->GetName();
+  CSingleLock lock(m_section);
+  return m_vecCoreConfigs[eCore-1]->GetName();
 }
 
-CPlayerCoreConfig* CPlayerCoreFactory::GetPlayerConfig(const CStdString& strCoreName)
+CPlayerCoreConfig* CPlayerCoreFactory::GetPlayerConfig(const CStdString& strCoreName) const
 {
+  CSingleLock lock(m_section);
   PLAYERCOREID id = GetPlayerCore(strCoreName);
-  if (id != EPC_NONE) return s_vecCoreConfigs[id-1];
+  if (id != EPC_NONE) return m_vecCoreConfigs[id-1];
   else return NULL;
 }
 
-void CPlayerCoreFactory::GetPlayers( VECPLAYERCORES &vecCores )
+void CPlayerCoreFactory::GetPlayers( VECPLAYERCORES &vecCores ) const
 {
-  for(unsigned int i = 0; i < s_vecCoreConfigs.size(); i++)
-    if (s_vecCoreConfigs[i]->m_bPlaysAudio || s_vecCoreConfigs[i]->m_bPlaysVideo)
+  CSingleLock lock(m_section);
+  for(unsigned int i = 0; i < m_vecCoreConfigs.size(); i++)
+  {
+    if(m_vecCoreConfigs[i]->m_eCore == EPC_NONE)
+      continue;
+    if (m_vecCoreConfigs[i]->m_bPlaysAudio || m_vecCoreConfigs[i]->m_bPlaysVideo)
       vecCores.push_back(i+1);
 }
+}
 
-void CPlayerCoreFactory::GetPlayers( VECPLAYERCORES &vecCores, const bool audio, const bool video )
+void CPlayerCoreFactory::GetPlayers( VECPLAYERCORES &vecCores, const bool audio, const bool video ) const
 {
+  CSingleLock lock(m_section);
   CLog::Log(LOGDEBUG, "CPlayerCoreFactory::GetPlayers: for video=%d, audio=%d", video, audio);
 
-  for(unsigned int i = 0; i < s_vecCoreConfigs.size(); i++)
+  for(unsigned int i = 0; i < m_vecCoreConfigs.size(); i++)
   {
-    if (audio == s_vecCoreConfigs[i]->m_bPlaysAudio && video == s_vecCoreConfigs[i]->m_bPlaysVideo)
+    if(m_vecCoreConfigs[i]->m_eCore == EPC_NONE)
+      continue;
+    if (audio == m_vecCoreConfigs[i]->m_bPlaysAudio && video == m_vecCoreConfigs[i]->m_bPlaysVideo)
     {
-      CLog::Log(LOGDEBUG, "CPlayerCoreFactory::GetPlayers: adding player: %s (%d)", s_vecCoreConfigs[i]->m_name.c_str(), i+1);
+      CLog::Log(LOGDEBUG, "CPlayerCoreFactory::GetPlayers: adding player: %s (%d)", m_vecCoreConfigs[i]->m_name.c_str(), i+1);
       vecCores.push_back(i+1);
     }
   }
 }
 
-void CPlayerCoreFactory::GetPlayers( const CFileItem& item, VECPLAYERCORES &vecCores)
+void CPlayerCoreFactory::GetPlayers( const CFileItem& item, VECPLAYERCORES &vecCores) const
 {
   CURL url(item.GetPath());
 
   CLog::Log(LOGDEBUG, "CPlayerCoreFactory::GetPlayers(%s)", item.GetPath().c_str());
 
   // Process rules
-  for(unsigned int i = 0; i < s_vecCoreSelectionRules.size(); i++)
-    s_vecCoreSelectionRules[i]->GetPlayers(item, vecCores);
+  for(unsigned int i = 0; i < m_vecCoreSelectionRules.size(); i++)
+    m_vecCoreSelectionRules[i]->GetPlayers(item, vecCores);
 
   CLog::Log(LOGDEBUG, "CPlayerCoreFactory::GetPlayers: matched %"PRIuS" rules with players", vecCores.size());
 
@@ -218,18 +243,29 @@
   CLog::Log(LOGDEBUG, "CPlayerCoreFactory::GetPlayers: added %"PRIuS" players", vecCores.size());
 }
 
-PLAYERCOREID CPlayerCoreFactory::GetDefaultPlayer( const CFileItem& item )
+void CPlayerCoreFactory::GetRemotePlayers( VECPLAYERCORES &vecCores ) const
+{
+  CSingleLock lock(m_section);
+  for(unsigned int i = 0; i < m_vecCoreConfigs.size(); i++)
+  {
+    if(m_vecCoreConfigs[i]->m_eCore != EPC_UPNPPLAYER)
+      continue;
+    vecCores.push_back(i+1);
+  }
+}
+
+PLAYERCOREID CPlayerCoreFactory::GetDefaultPlayer( const CFileItem& item ) const
 {
   VECPLAYERCORES vecCores;
   GetPlayers(item, vecCores);
 
   //If we have any players return the first one
-  if( vecCores.size() > 0 ) return vecCores.at(0);
+  if( !vecCores.empty() ) return vecCores.at(0);
 
   return EPC_NONE;
 }
 
-PLAYERCOREID CPlayerCoreFactory::SelectPlayerDialog(VECPLAYERCORES &vecCores, float posX, float posY)
+PLAYERCOREID CPlayerCoreFactory::SelectPlayerDialog(VECPLAYERCORES &vecCores, float posX, float posY) const
 {
   CContextButtons choices;
   if (vecCores.size())
@@ -252,50 +288,72 @@
   return EPC_NONE;
 }
 
-PLAYERCOREID CPlayerCoreFactory::SelectPlayerDialog(float posX, float posY)
+PLAYERCOREID CPlayerCoreFactory::SelectPlayerDialog(float posX, float posY) const
 {
   VECPLAYERCORES vecCores;
   GetPlayers(vecCores);
   return SelectPlayerDialog(vecCores, posX, posY);
 }
 
-bool CPlayerCoreFactory::LoadConfiguration(TiXmlElement* pConfig, bool clear)
+bool CPlayerCoreFactory::LoadConfiguration(const std::string &file, bool clear)
+{
+  CSingleLock lock(m_section);
+  CLog::Log(LOGNOTICE, "Loading player core factory settings from %s.", file.c_str());
+  if (!XFILE::CFile::Exists(file))
+  { // tell the user it doesn't exist
+    CLog::Log(LOGNOTICE, "%s does not exist. Skipping.", file.c_str());
+    return false;
+  }
+
+  CXBMCTinyXML playerCoreFactoryXML;
+  if (!playerCoreFactoryXML.LoadFile(file))
 {
+    CLog::Log(LOGERROR, "Error loading %s, Line %d (%s)", file.c_str(), playerCoreFactoryXML.ErrorRow(), playerCoreFactoryXML.ErrorDesc());
+    return false;
+  }
+
+  TiXmlElement *pConfig = playerCoreFactoryXML.RootElement();
+  if (pConfig == NULL)
+  {
+      CLog::Log(LOGERROR, "Error loading %s, Bad structure", file.c_str());
+      return false;
+  }
+
   if (clear)
   {
-    for(std::vector<CPlayerCoreConfig *>::iterator it = s_vecCoreConfigs.begin(); it != s_vecCoreConfigs.end(); it++)
+    for(std::vector<CPlayerCoreConfig *>::iterator it = m_vecCoreConfigs.begin(); it != m_vecCoreConfigs.end(); ++it)
       delete *it;
-    s_vecCoreConfigs.clear();
+    m_vecCoreConfigs.clear();
     // Builtin players; hard-coded because re-ordering them would break scripts
     CPlayerCoreConfig* dvdplayer = new CPlayerCoreConfig("DVDPlayer", EPC_DVDPLAYER, NULL);
     dvdplayer->m_bPlaysAudio = dvdplayer->m_bPlaysVideo = true;
-    s_vecCoreConfigs.push_back(dvdplayer);
+    m_vecCoreConfigs.push_back(dvdplayer);
 
      // Don't remove this, its a placeholder for the old MPlayer core, it would break scripts
     CPlayerCoreConfig* mplayer = new CPlayerCoreConfig("oldmplayercore", EPC_DVDPLAYER, NULL);
-    s_vecCoreConfigs.push_back(mplayer);
+    m_vecCoreConfigs.push_back(mplayer);
 
     CPlayerCoreConfig* paplayer = new CPlayerCoreConfig("PAPlayer", EPC_PAPLAYER, NULL);
     paplayer->m_bPlaysAudio = true;
-    s_vecCoreConfigs.push_back(paplayer);
+    m_vecCoreConfigs.push_back(paplayer);
 
 #if defined(HAS_AMLPLAYER)
     CPlayerCoreConfig* amlplayer = new CPlayerCoreConfig("AMLPlayer", EPC_AMLPLAYER, NULL);
     amlplayer->m_bPlaysAudio = true;
     amlplayer->m_bPlaysVideo = true;
-    s_vecCoreConfigs.push_back(amlplayer);
+    m_vecCoreConfigs.push_back(amlplayer);
 #endif
 
 #if defined(HAS_OMXPLAYER)
     CPlayerCoreConfig* omxplayer = new CPlayerCoreConfig("OMXPlayer", EPC_OMXPLAYER, NULL);
     omxplayer->m_bPlaysAudio = true;
     omxplayer->m_bPlaysVideo = true;
-    s_vecCoreConfigs.push_back(omxplayer);
+    m_vecCoreConfigs.push_back(omxplayer);
 #endif
 
-    for(std::vector<CPlayerSelectionRule *>::iterator it = s_vecCoreSelectionRules.begin(); it != s_vecCoreSelectionRules.end(); it++)
+    for(std::vector<CPlayerSelectionRule *>::iterator it = m_vecCoreSelectionRules.begin(); it != m_vecCoreSelectionRules.end(); ++it)
       delete *it;
-    s_vecCoreSelectionRules.clear();
+    m_vecCoreSelectionRules.clear();
   }
 
   if (!pConfig || strcmpi(pConfig->Value(),"playercorefactory") != 0)
@@ -322,7 +380,7 @@
 
       if (eCore != EPC_NONE)
       {
-        s_vecCoreConfigs.push_back(new CPlayerCoreConfig(name, eCore, pPlayer));
+        m_vecCoreConfigs.push_back(new CPlayerCoreConfig(name, eCore, pPlayer));
       }
 
       pPlayer = pPlayer->NextSiblingElement("player");
@@ -337,21 +395,21 @@
     {
       if (stricmp(szAction, "append") == 0)
       {
-        s_vecCoreSelectionRules.push_back(new CPlayerSelectionRule(pRule));
+        m_vecCoreSelectionRules.push_back(new CPlayerSelectionRule(pRule));
       }
       else if (stricmp(szAction, "prepend") == 0)
       {
-        s_vecCoreSelectionRules.insert(s_vecCoreSelectionRules.begin(), 1, new CPlayerSelectionRule(pRule));
+        m_vecCoreSelectionRules.insert(m_vecCoreSelectionRules.begin(), 1, new CPlayerSelectionRule(pRule));
       }
       else
       {
-        s_vecCoreSelectionRules.clear();
-        s_vecCoreSelectionRules.push_back(new CPlayerSelectionRule(pRule));
+        m_vecCoreSelectionRules.clear();
+        m_vecCoreSelectionRules.push_back(new CPlayerSelectionRule(pRule));
       }
     }
     else
     {
-      s_vecCoreSelectionRules.push_back(new CPlayerSelectionRule(pRule));
+      m_vecCoreSelectionRules.push_back(new CPlayerSelectionRule(pRule));
     }
 
     pRule = pRule->NextSiblingElement("rules");
@@ -362,3 +420,38 @@
 
   return true;
 }
+
+void CPlayerCoreFactory::OnPlayerDiscovered(const CStdString& id, const CStdString& name, EPLAYERCORES core)
+{
+  CSingleLock lock(m_section);
+  std::vector<CPlayerCoreConfig *>::iterator it;
+  for(it  = m_vecCoreConfigs.begin();
+      it != m_vecCoreConfigs.end();
+      ++it)
+  {
+    if ((*it)->GetId() == id)
+    {
+      (*it)->m_name  = name;
+      (*it)->m_eCore = core;
+      return;
+    }
+  }
+
+  CPlayerCoreConfig* player = new CPlayerCoreConfig(name, core, NULL, id);
+  player->m_bPlaysAudio = true;
+  player->m_bPlaysVideo = true;
+  m_vecCoreConfigs.push_back(player);
+}
+
+void CPlayerCoreFactory::OnPlayerRemoved(const CStdString& id)
+{
+  CSingleLock lock(m_section);
+  std::vector<CPlayerCoreConfig *>::iterator it;
+  for(it  = m_vecCoreConfigs.begin();
+      it != m_vecCoreConfigs.end();
+      ++it)
+  {
+    if ((*it)->GetId() == id)
+      (*it)->m_eCore = EPC_NONE;
+  }
+}
diff -ENwbur xbmcfrodo/xbmc/cores/playercorefactory/PlayerCoreFactory.h xbmc/xbmc/cores/playercorefactory/PlayerCoreFactory.h
--- xbmcfrodo/xbmc/cores/playercorefactory/PlayerCoreFactory.h	2013-02-16 18:48:38.724386694 +0000
+++ xbmc/xbmc/cores/playercorefactory/PlayerCoreFactory.h	2013-04-05 11:38:44.036812460 +0000
@@ -1,7 +1,7 @@
 #pragma once
 
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -20,14 +20,23 @@
  *
  */
 
-#include "../IPlayer.h"
+#include "system.h"
+
+#include "cores/IPlayerCallback.h"
+#include "settings/ISettingsHandler.h"
+#include "threads/CriticalSection.h"
+#include "utils/StdString.h"
+
+#include <vector>
 
 /*----------------------------------------------------------------------
 |   forward references
 +---------------------------------------------------------------------*/
 class TiXmlElement;
+class CFileItem;
 class CPlayerCoreConfig;
 class CPlayerSelectionRule;
+class IPlayer;
 
 // do not remove mplayer - will break scripts
 enum EPLAYERCORES
@@ -42,7 +51,8 @@
 #if defined(HAS_OMXPLAYER)
   EPC_OMXPLAYER,
 #endif
-  EPC_EXTPLAYER
+  EPC_EXTPLAYER,
+  EPC_UPNPPLAYER,
 };
 
 typedef unsigned int PLAYERCOREID;
@@ -58,31 +68,43 @@
 const PLAYERCOREID PCID_OMXPLAYER = EPC_OMXPLAYER;
 #endif
 
-class CPlayerCoreFactory
+class CPlayerCoreFactory : public ISettingsHandler
 {
 public:
-  CPlayerCoreFactory();
-  virtual ~CPlayerCoreFactory();
+  static CPlayerCoreFactory& Get();
+
+  virtual void OnSettingsLoaded();
 
+  PLAYERCOREID GetPlayerCore(const CStdString& strCoreName) const;
+  CPlayerCoreConfig* GetPlayerConfig(const CStdString& strCoreName) const;
+  CStdString GetPlayerName(const PLAYERCOREID eCore) const;
+
+  IPlayer* CreatePlayer(const PLAYERCOREID eCore, IPlayerCallback& callback) const;
   IPlayer* CreatePlayer(const CStdString& strCore, IPlayerCallback& callback) const;
+  void GetPlayers( const CFileItem& item, VECPLAYERCORES &vecCores) const;   //Players supporting the specified file
+  void GetPlayers( VECPLAYERCORES &vecCores, bool audio, bool video ) const; //All audio players and/or video players
+  void GetPlayers( VECPLAYERCORES &vecCores ) const;                         //All players
 
-  static PLAYERCOREID GetPlayerCore(const CStdString& strCoreName);
-  static CPlayerCoreConfig* GetPlayerConfig(const CStdString& strCoreName);
-  static CStdString GetPlayerName(const PLAYERCOREID eCore);
+  void GetRemotePlayers( VECPLAYERCORES &vecCores ) const;                   //All remote players we can attach to
 
-  static IPlayer* CreatePlayer(const PLAYERCOREID eCore, IPlayerCallback& callback);
-  static void GetPlayers( const CFileItem& item, VECPLAYERCORES &vecCores);   //Players supporting the specified file
-  static void GetPlayers( VECPLAYERCORES &vecCores, bool audio, bool video ); //All audio players and/or video players
-  static void GetPlayers( VECPLAYERCORES &vecCores );                         //All players
+  PLAYERCOREID GetDefaultPlayer( const CFileItem& item ) const;
 
-  static PLAYERCOREID GetDefaultPlayer( const CFileItem& item );
+  PLAYERCOREID SelectPlayerDialog(VECPLAYERCORES &vecCores, float posX = 0, float posY = 0) const;
+  PLAYERCOREID SelectPlayerDialog(float posX, float posY) const;
 
-  static PLAYERCOREID SelectPlayerDialog(VECPLAYERCORES &vecCores, float posX = 0, float posY = 0);
-  static PLAYERCOREID SelectPlayerDialog(float posX, float posY);
+  void OnPlayerDiscovered(const CStdString& id, const CStdString& name, EPLAYERCORES core);
+  void OnPlayerRemoved(const CStdString& id);
 
-  static bool LoadConfiguration(TiXmlElement* pConfig, bool clear);
+protected:
+  CPlayerCoreFactory();
+  CPlayerCoreFactory(const CPlayerCoreFactory&);
+  CPlayerCoreFactory& operator=(CPlayerCoreFactory const&);
+  virtual ~CPlayerCoreFactory();
 
 private:
-  static std::vector<CPlayerCoreConfig *> s_vecCoreConfigs;
-  static std::vector<CPlayerSelectionRule *> s_vecCoreSelectionRules;
+  bool LoadConfiguration(const std::string &file, bool clear);
+
+  std::vector<CPlayerCoreConfig *> m_vecCoreConfigs;
+  std::vector<CPlayerSelectionRule *> m_vecCoreSelectionRules;
+  CCriticalSection m_section;
 };
diff -ENwbur xbmcfrodo/xbmc/cores/playercorefactory/PlayerSelectionRule.cpp xbmc/xbmc/cores/playercorefactory/PlayerSelectionRule.cpp
--- xbmcfrodo/xbmc/cores/playercorefactory/PlayerSelectionRule.cpp	2013-03-17 17:48:06.466775815 +0000
+++ xbmc/xbmc/cores/playercorefactory/PlayerSelectionRule.cpp	2013-04-05 11:38:44.036812460 +0000
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -83,7 +83,7 @@
   }
 }
 
-int CPlayerSelectionRule::GetTristate(const char* szValue) const
+int CPlayerSelectionRule::GetTristate(const char* szValue)
 {
   if (szValue)
   {
@@ -93,12 +93,12 @@
   return -1;
 }
 
-bool CPlayerSelectionRule::CompileRegExp(const CStdString& str, CRegExp& regExp) const
+bool CPlayerSelectionRule::CompileRegExp(const CStdString& str, CRegExp& regExp)
 {
   return str.length() > 0 && regExp.RegComp(str.c_str());
 }
 
-bool CPlayerSelectionRule::MatchesRegExp(const CStdString& str, CRegExp& regExp) const
+bool CPlayerSelectionRule::MatchesRegExp(const CStdString& str, CRegExp& regExp)
 {
   return regExp.RegFind(str, 0) == 0;
 }
@@ -108,15 +108,15 @@
   CLog::Log(LOGDEBUG, "CPlayerSelectionRule::GetPlayers: considering rule: %s", m_name.c_str());
 
   if (m_bStreamDetails && !item.HasVideoInfoTag()) return;
-  if (m_tAudio >= 0 && (m_tAudio > 0) != item.IsAudio()) return;
-  if (m_tVideo >= 0 && (m_tVideo > 0) != item.IsVideo()) return;
-  if (m_tInternetStream >= 0 && (m_tInternetStream > 0) != item.IsInternetStream()) return;
-  if (m_tRemote >= 0 && (m_tRemote > 0) != item.IsRemote()) return;
-
-  if (m_tBD >= 0 && (m_tBD > 0) != (item.IsBDFile() && item.IsOnDVD())) return;
-  if (m_tDVD >= 0 && (m_tDVD > 0) != item.IsDVD()) return;
-  if (m_tDVDFile >= 0 && (m_tDVDFile > 0) != item.IsDVDFile()) return;
-  if (m_tDVDImage >= 0 && (m_tDVDImage > 0) != item.IsDVDImage()) return;
+  if ((m_tAudio > 0) != item.IsAudio()) return;
+  if ((m_tVideo > 0) != item.IsVideo()) return;
+  if ((m_tInternetStream > 0) != item.IsInternetStream()) return;
+  if ((m_tRemote > 0) != item.IsRemote()) return;
+
+  if ((m_tBD > 0) != (item.IsBDFile() && item.IsOnDVD())) return;
+  if ((m_tDVD > 0) != item.IsDVD()) return;
+  if ((m_tDVDFile > 0) != item.IsDVDFile()) return;
+  if ((m_tDVDImage > 0) != item.IsDVDImage()) return;
 
   CRegExp regExp;
 
@@ -174,7 +174,7 @@
 {
   if (!m_playerCoreId)
   {
-    m_playerCoreId = CPlayerCoreFactory::GetPlayerCore(m_playerName);
+    m_playerCoreId = CPlayerCoreFactory::Get().GetPlayerCore(m_playerName);
   }
   return m_playerCoreId;
 }
diff -ENwbur xbmcfrodo/xbmc/cores/playercorefactory/PlayerSelectionRule.h xbmc/xbmc/cores/playercorefactory/PlayerSelectionRule.h
--- xbmcfrodo/xbmc/cores/playercorefactory/PlayerSelectionRule.h	2013-03-05 19:37:56.582328697 +0000
+++ xbmc/xbmc/cores/playercorefactory/PlayerSelectionRule.h	2013-04-05 11:38:44.036812460 +0000
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2005-2012 Team XBMC
+ *      Copyright (C) 2005-2013 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -36,9 +36,9 @@
   void GetPlayers(const CFileItem& item, VECPLAYERCORES &vecCores);
 
 private:
-  int GetTristate(const char* szValue) const;
-  bool CompileRegExp(const CStdString& str, CRegExp& regExp) const;
-  bool MatchesRegExp(const CStdString& str, CRegExp& regExp) const;
+  static int GetTristate(const char* szValue);
+  static bool CompileRegExp(const CStdString& str, CRegExp& regExp);
+  static bool MatchesRegExp(const CStdString& str, CRegExp& regExp);
   void Initialize(TiXmlElement* pRule);
   PLAYERCOREID GetPlayerCore();
 
