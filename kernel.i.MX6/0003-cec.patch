From c3a8313a97dc40a18f809ad1154c606c6b29d65f Mon Sep 17 00:00:00 2001
From: Matus Kral <matuskral@me.com>
Date: Thu, 24 Apr 2014 14:52:09 +0200
Subject: [PATCH] updated CEC driver for Solidrun Cubox-i

(update to libcec is also needed https://github.com/mk01/libcec/commit/40ac7550fe22a9fed665eec0aec1882498f838d6)
---
 drivers/mxc/hdmi-cec/mxc_hdmi-cec.c | 168 ++++++++++++++++++++----------------
 drivers/mxc/hdmi-cec/mxc_hdmi-cec.h |   9 ++
 drivers/video/mxc/mxc_edid.c        |   6 +-
 drivers/video/mxc/mxc_hdmi.c        |  14 ++-
 4 files changed, 115 insertions(+), 82 deletions(-)

diff --git a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
index d0113ee..8752786 100644
--- a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
+++ b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
@@ -46,21 +46,12 @@
 
 #include "mxc_hdmi-cec.h"
 
-
-#define MAX_MESSAGE_LEN		17
-
-#define MESSAGE_TYPE_RECEIVE_SUCCESS		1
-#define MESSAGE_TYPE_NOACK		2
-#define MESSAGE_TYPE_DISCONNECTED		3
-#define MESSAGE_TYPE_CONNECTED		4
-#define MESSAGE_TYPE_SEND_SUCCESS		5
-
-
 struct hdmi_cec_priv {
 	int  receive_error;
 	int  send_error;
 	u8 Logical_address;
 	bool cec_state;
+	bool write_busy;
 	u8 last_msg[MAX_MESSAGE_LEN];
 	u8 msg_len;
 	u8 latest_cec_stat;
@@ -89,6 +80,7 @@ static irqreturn_t mxc_hdmi_cec_isr(int irq, void *data)
 	struct hdmi_cec_priv *hdmi_cec = data;
 	u8 cec_stat = 0;
 	unsigned long flags;
+	irqreturn_t ret = IRQ_HANDLED;
 
 	spin_lock_irqsave(&hdmi_cec->irq_lock, flags);
 
@@ -100,18 +92,19 @@ static irqreturn_t mxc_hdmi_cec_isr(int irq, void *data)
 	if ((cec_stat & (HDMI_IH_CEC_STAT0_ERROR_INIT | \
 		HDMI_IH_CEC_STAT0_NACK | HDMI_IH_CEC_STAT0_EOM | \
 		HDMI_IH_CEC_STAT0_DONE)) == 0) {
-		spin_unlock_irqrestore(&hdmi_cec->irq_lock, flags);
-		return IRQ_HANDLED;
-	}
 
-	pr_debug("HDMI CEC interrupt received\n");
-	hdmi_cec->latest_cec_stat = cec_stat;
+		hdmi_cec->latest_cec_stat = 0;
+		ret = IRQ_NONE;
+	} else {
+		pr_debug("HDMI CEC interrupt received\n");
+		hdmi_cec->latest_cec_stat = cec_stat;
+	}
 
 	schedule_delayed_work(&(hdmi_cec->hdmi_cec_work), msecs_to_jiffies(20));
 
 	spin_unlock_irqrestore(&hdmi_cec->irq_lock, flags);
 
-	return IRQ_HANDLED;
+	return ret;
 }
 
 void mxc_hdmi_cec_handle(u16 cec_stat)
@@ -267,7 +260,9 @@ static void mxc_hdmi_cec_worker(struct work_struct *work)
 {
 	u8 val;
 
-	mxc_hdmi_cec_handle(hdmi_cec_data.latest_cec_stat);
+	if (hdmi_cec_data.latest_cec_stat)
+		mxc_hdmi_cec_handle(hdmi_cec_data.latest_cec_stat);
+
 	val = HDMI_IH_CEC_STAT0_WAKEUP | HDMI_IH_CEC_STAT0_ERROR_FOLL |
 			HDMI_IH_CEC_STAT0_ARB_LOST;
 	hdmi_writeb(val, HDMI_IH_MUTE_CEC_STAT0);
@@ -298,42 +293,47 @@ static int hdmi_cec_open(struct inode *inode, struct file *filp)
 static ssize_t hdmi_cec_read(struct file *file, char __user *buf, size_t count,
 			    loff_t *ppos)
 {
-	struct hdmi_cec_event *event = NULL;
+	struct hdmi_cec_priv *hdmi_cec = file->private_data;
+	int ret = 0;
 
 	pr_debug("function : %s\n", __func__);
 	if (!open_count)
 		return -ENODEV;
 
-	mutex_lock(&hdmi_cec_data.lock);
-	if (false == hdmi_cec_data.cec_state) {
-		mutex_unlock(&hdmi_cec_data.lock);
-		return -EACCES;
-	}
-	mutex_unlock(&hdmi_cec_data.lock);
+	if (count > (sizeof(struct hdmi_cec_event) - sizeof(struct list_head)))
+		count = (sizeof(struct hdmi_cec_event) - sizeof(struct list_head));
 
-	/* delete from list */
-	mutex_lock(&hdmi_cec_data.lock);
-	if (list_empty(&head)) {
-		mutex_unlock(&hdmi_cec_data.lock);
-		return -EACCES;
-	}
-	event = list_first_entry(&head, struct hdmi_cec_event, list);
-	list_del(&event->list);
-	mutex_unlock(&hdmi_cec_data.lock);
+	do {
+		unsigned long flags;    
+		struct hdmi_cec_event *event = NULL;
 
-	if (copy_to_user(buf, event,
-			sizeof(struct hdmi_cec_event) - sizeof(struct list_head))) {
-		vfree(event);
-		return -EFAULT;
-	}
-	vfree(event);
+		spin_lock_irqsave(&hdmi_cec->irq_lock, flags);
+		if (!list_empty(&head)) {
+			event = list_first_entry(&head, struct hdmi_cec_event, list);
+			list_del(&event->list);
+		}
+		spin_unlock_irqrestore(&hdmi_cec->irq_lock, flags);
+		wake_up(&hdmi_cec_queue);
 
-	return sizeof(struct hdmi_cec_event);
+		if (event) {
+			ret = copy_to_user(buf, event, count) ? -EFAULT : count;
+			vfree(event);
+		}
+		else if (file->f_flags & O_NONBLOCK) {
+			ret = -EAGAIN;
+		}
+		else if (wait_event_interruptible(hdmi_cec_queue, (!list_empty(&head)))) {
+			ret = -ERESTARTSYS;
+		}
+	} while(!ret);
+
+	return ret;
 }
 
 static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 			     size_t count, loff_t *ppos)
 {
+	struct hdmi_cec_priv *hdmi_cec = file->private_data;
 	int ret = 0 , i = 0;
 	u8 msg[MAX_MESSAGE_LEN];
 	u8 msg_len = 0, val = 0;
@@ -342,25 +342,29 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 	if (!open_count)
 		return -ENODEV;
 
-	mutex_lock(&hdmi_cec_data.lock);
-	if (false == hdmi_cec_data.cec_state) {
-		mutex_unlock(&hdmi_cec_data.lock);
-		return -EACCES;
-	}
-	mutex_unlock(&hdmi_cec_data.lock);
-
 	if (count > MAX_MESSAGE_LEN)
-		return -EINVAL;
+		return -E2BIG;
 
-	mutex_lock(&hdmi_cec_data.lock);
-	hdmi_cec_data.send_error = 0;
 	memset(&msg, 0, MAX_MESSAGE_LEN);
-	ret = copy_from_user(&msg, buf, count);
-	if (ret) {
+	if (copy_from_user(&msg, buf, count))
+		return -EFAULT;
+
+	if (file->f_flags & O_NONBLOCK) {
+		if (hdmi_cec->write_busy)
+			return -EAGAIN;
+	} else {
+		if (wait_event_interruptible(hdmi_cec_queue, (!hdmi_cec->write_busy)))
+			return -ERESTARTSYS;
+	}
+
+	mutex_lock(&hdmi_cec->lock);
+	hdmi_cec->write_busy = true;
+	if (false == hdmi_cec->cec_state) {
 		ret = -EACCES;
 		goto end;
 	}
 
+	hdmi_cec->send_error = 0;
 	msg_len = count;
 	hdmi_writeb(msg_len, HDMI_CEC_TX_CNT);
 	for (i = 0; i < msg_len; i++) {
@@ -370,24 +374,24 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 	val = hdmi_readb(HDMI_CEC_CTRL);
 	val |= 0x01;
 	hdmi_writeb(val, HDMI_CEC_CTRL);
-	memcpy(hdmi_cec_data.last_msg, msg, msg_len);
-	hdmi_cec_data.msg_len = msg_len;
+	memcpy(hdmi_cec->last_msg, msg, msg_len);
+	hdmi_cec->msg_len = msg_len;
 
 	i = 0;
-	val = hdmi_readb(HDMI_CEC_CTRL);
-	while ((val & 0x01) == 0x1) {
-		msleep(50);
-		i++;
-		if (i > 3) {
-			ret = -EIO;
-			goto end;
-		}
+	do {
+		if (i)
+			msleep(100);
 		val = hdmi_readb(HDMI_CEC_CTRL);
-	}
+	} while (val & 0x01 && i++ < 3);
 
-end:
-	mutex_unlock(&hdmi_cec_data.lock);
+	if (val & 0x01)
+		ret = -EIO;
+	else
+		ret = msg_len;
 
+end:
+	hdmi_cec->write_busy = false;
+	mutex_unlock(&hdmi_cec->lock);
 	return ret;
 }
 
@@ -399,7 +403,7 @@ end:
 static long hdmi_cec_ioctl(struct file *filp, u_int cmd,
 		     u_long arg)
 {
-	int ret = 0, status = 0;
+	int ret = 0;
 	u8 val = 0, msg = 0;
 	struct mxc_edid_cfg hdmi_edid_cfg;
 
@@ -491,11 +495,9 @@ static long hdmi_cec_ioctl(struct file *filp, u_int cmd,
 
 	case HDMICEC_IOC_GETPHYADDRESS:
 		hdmi_get_edid_cfg(&hdmi_edid_cfg);
-		status = copy_to_user((void __user *)arg,
+		ret = copy_to_user((void __user *)arg,
 					 &hdmi_edid_cfg.physical_address,
-					 4*sizeof(u8));
-		if (status)
-			ret = -EFAULT;
+					 4*sizeof(u8))?-EFAULT:0;
 		break;
 
 	default:
@@ -512,12 +514,25 @@ static long hdmi_cec_ioctl(struct file *filp, u_int cmd,
 */
 static int hdmi_cec_release(struct inode *inode, struct file *filp)
 {
+
+	pr_debug("function : %s\n", __func__);
+
 	mutex_lock(&hdmi_cec_data.lock);
 
 	if (open_count) {
 		open_count = 0;
+		wait_event_timeout(hdmi_cec_queue, !hdmi_cec_data.write_busy, msecs_to_jiffies(500));
 		hdmi_cec_data.cec_state = false;
 		hdmi_cec_data.Logical_address = 15;
+		hdmi_cec_data.write_busy = false;
+
+		while (!list_empty(&head)) {
+			struct hdmi_cec_event *event;
+
+			event = list_first_entry(&head, struct hdmi_cec_event, list);
+			list_del(&event->list);
+			vfree(event);
+		}
 	}
 
 	mutex_unlock(&hdmi_cec_data.lock);
@@ -531,16 +546,14 @@ static unsigned int hdmi_cec_poll(struct file *file, poll_table *wait)
 
 	pr_debug("function : %s\n", __func__);
 
-	if (!open_count)
-		return -ENODEV;
-
-	if (false == hdmi_cec_data.cec_state)
-		return -EACCES;
-
 	poll_wait(file, &hdmi_cec_queue, wait);
 
+	mutex_lock(&hdmi_cec_data.lock);
+	if (!hdmi_cec_data.write_busy) 
+		mask = (POLLOUT | POLLWRNORM);
 	if (!list_empty(&head))
 		mask |= (POLLIN | POLLRDNORM);
+	mutex_unlock(&hdmi_cec_data.lock);
 
 	return mask;
 }
@@ -631,6 +644,9 @@ out:
 
 static int hdmi_cec_dev_remove(struct platform_device *pdev)
 {
+	if (hdmi_cec_data.cec_state)
+		hdmi_cec_ioctl(0, HDMICEC_IOC_STOPDEVICE, 0);
+
 	if (hdmi_cec_major > 0) {
 		device_destroy(hdmi_cec_class, MKDEV(hdmi_cec_major, 0));
 		class_destroy(hdmi_cec_class);
diff --git a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.h b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.h
index 4437057..297f628 100644
--- a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.h
+++ b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.h
@@ -35,4 +35,13 @@
 #define HDMICEC_IOC_GETPHYADDRESS	\
 				_IOR(HDMICEC_IOC_MAGIC, 4, unsigned char[4])
 
+#define MAX_MESSAGE_LEN                         16
+
+#define MESSAGE_TYPE_RECEIVE_SUCCESS            1
+#define MESSAGE_TYPE_NOACK                      2
+#define MESSAGE_TYPE_DISCONNECTED               3
+#define MESSAGE_TYPE_CONNECTED                  4
+#define MESSAGE_TYPE_SEND_SUCCESS               5
+
 #endif				/* !_HDMICEC_H_ */
+
diff --git a/drivers/video/mxc/mxc_edid.c b/drivers/video/mxc/mxc_edid.c
index 88b5268..85b19f5 100644
--- a/drivers/video/mxc/mxc_edid.c
+++ b/drivers/video/mxc/mxc_edid.c
@@ -348,10 +348,8 @@ int mxc_edid_parse_ext_blk(unsigned char *edid,
 					IEEE_reg_iden[0] = edid[index+1];
 					IEEE_reg_iden[1] = edid[index+2];
 					IEEE_reg_iden[2] = edid[index+3];
-					cfg->physical_address[0] = (edid[index+4] & 0xf0) >> 4;
-					cfg->physical_address[1] = (edid[index+4] & 0x0f);
-					cfg->physical_address[2] = (edid[index+5] & 0xf0) >> 4;
-					cfg->physical_address[3] = (edid[index+5] & 0x0f);
+					cfg->physical_address[0] = edid[index+5];
+					cfg->physical_address[1] = edid[index+4];
 
 					if ((IEEE_reg_iden[0] == 0x03) &&
 							(IEEE_reg_iden[1] == 0x0c) &&
diff --git a/drivers/video/mxc/mxc_hdmi.c b/drivers/video/mxc/mxc_hdmi.c
index 160db29..07d0bfd 100644
--- a/drivers/video/mxc/mxc_hdmi.c
+++ b/drivers/video/mxc/mxc_hdmi.c
@@ -1704,8 +1704,12 @@ static void mxc_hdmi_enable_video_path(struct mxc_hdmi *hdmi)
 	hdmi_writeb(0x16, HDMI_FC_CH1PREAM);
 	hdmi_writeb(0x21, HDMI_FC_CH2PREAM);
 
+	/* Save CEC clock */
+	clkdis = hdmi_readb(HDMI_MC_CLKDIS) & HDMI_MC_CLKDIS_CECCLK_DISABLE;
+	clkdis |= ~HDMI_MC_CLKDIS_CECCLK_DISABLE;
+
 	/* Enable pixel clock and tmds data path */
-	clkdis = 0x7F;
+	clkdis = 0x7F & clkdis;
 	clkdis &= ~HDMI_MC_CLKDIS_PIXELCLK_DISABLE;
 	hdmi_writeb(clkdis, HDMI_MC_CLKDIS);
 
@@ -1985,10 +1989,16 @@ static void mxc_hdmi_power_off(struct mxc_dispdrv_handle *disp)
 
 static void mxc_hdmi_cable_disconnected(struct mxc_hdmi *hdmi)
 {
+	u8 clkdis;
+
 	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
 
+	/* Save CEC clock */
+	clkdis = hdmi_readb(HDMI_MC_CLKDIS) & HDMI_MC_CLKDIS_CECCLK_DISABLE;
+	clkdis |= ~HDMI_MC_CLKDIS_CECCLK_DISABLE;
+
 	/* Disable All HDMI clock */
-	hdmi_writeb(0xff, HDMI_MC_CLKDIS);
+	hdmi_writeb(0xff & clkdis, HDMI_MC_CLKDIS);
 
 	mxc_hdmi_phy_disable(hdmi);
 
-- 
1.8.4.2

From 9db4c234e7733c8c8c608d3f6b9c22cbf1e655b0 Mon Sep 17 00:00:00 2001
From: Matus Kral <matuskral@me.com>
Date: Sat, 3 May 2014 09:12:04 +0200
Subject: [PATCH] removed unnecessary code

---
 drivers/mxc/hdmi-cec/mxc_hdmi-cec.c | 168 ++++++++++++++----------------------
 1 file changed, 65 insertions(+), 103 deletions(-)

diff --git a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
index 8752786..c1680a4 100644
--- a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
+++ b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
@@ -101,7 +101,6 @@ static irqreturn_t mxc_hdmi_cec_isr(int irq, void *data)
 	}
 
 	schedule_delayed_work(&(hdmi_cec->hdmi_cec_work), msecs_to_jiffies(20));
-
 	spin_unlock_irqrestore(&hdmi_cec->irq_lock, flags);
 
 	return ret;
@@ -112,20 +111,30 @@ void mxc_hdmi_cec_handle(u16 cec_stat)
 	u8 val = 0, i = 0;
 	struct hdmi_cec_event *event = NULL;
 
-	/* The current transmission is successful (for initiator only). */
+	pr_debug("function: %s \n", __func__);
 	if (!open_count)
 		return;
 
-	if (cec_stat & HDMI_IH_CEC_STAT0_DONE) {
+	/* The current transmission is successful (for initiator only). */
+	/* A frame is not acknowledged in a directly addressed message.
+	 * Or a frame is negatively acknowledged in
+	 * a broadcast message (for initiator only).
+	 */
+	if (cec_stat & (HDMI_IH_CEC_STAT0_DONE | HDMI_IH_CEC_STAT0_NACK)) {
 
 		event = vmalloc(sizeof(struct hdmi_cec_event));
 		if (NULL == event) {
 			pr_err("%s: Not enough memory!\n", __func__);
 			return;
 		}
-
 		memset(event, 0, sizeof(struct hdmi_cec_event));
-		event->event_type = MESSAGE_TYPE_SEND_SUCCESS;
+
+		event->msg_len = min((int)hdmi_cec_data.msg_len, 2);
+		for (i = 0; i < event->msg_len; i++)
+			event->msg[i] = hdmi_cec_data.last_msg[i];
+
+		event->event_type = (cec_stat & HDMI_IH_CEC_STAT0_DONE) ? 
+			MESSAGE_TYPE_SEND_SUCCESS : MESSAGE_TYPE_NOACK;
 
 		mutex_lock(&hdmi_cec_data.lock);
 		list_add_tail(&event->list, &head);
@@ -191,26 +200,6 @@ void mxc_hdmi_cec_handle(u16 cec_stat)
 		mutex_unlock(&hdmi_cec_data.lock);
 	}
 
-	/* A frame is not acknowledged in a directly addressed message.
-	 * Or a frame is negatively acknowledged in
-	 * a broadcast message (for initiator only).
-	 */
-	if (cec_stat & HDMI_IH_CEC_STAT0_NACK) {
-		event = vmalloc(sizeof(struct hdmi_cec_event));
-		if (NULL == event) {
-			pr_err("%s: Not enough memory\n", __func__);
-			return;
-		}
-		memset(event, 0, sizeof(struct hdmi_cec_event));
-		event->event_type = MESSAGE_TYPE_NOACK;
-
-		mutex_lock(&hdmi_cec_data.lock);
-		list_add_tail(&event->list, &head);
-		mutex_unlock(&hdmi_cec_data.lock);
-
-		wake_up(&hdmi_cec_queue);
-	}
-
 	/* An error is notified by a follower.
 	 * Abnormal logic data bit error (for follower).
 	 */
@@ -219,31 +208,16 @@ void mxc_hdmi_cec_handle(u16 cec_stat)
 	}
 
 	/* HDMI cable connected */
-	if (cec_stat & 0x80) {
-		event = vmalloc(sizeof(struct hdmi_cec_event));
-		if (NULL == event) {
-			pr_err("%s: Not enough memory\n", __func__);
-			return;
-		}
-		memset(event, 0, sizeof(struct hdmi_cec_event));
-		event->event_type = MESSAGE_TYPE_CONNECTED;
-
-		mutex_lock(&hdmi_cec_data.lock);
-		list_add_tail(&event->list, &head);
-		mutex_unlock(&hdmi_cec_data.lock);
-
-		wake_up(&hdmi_cec_queue);
-	}
-
 	/* HDMI cable disconnected */
-	if (cec_stat & 0x100) {
+	if (cec_stat & (0x80 | 0x100)) {
 		event = vmalloc(sizeof(struct hdmi_cec_event));
 		if (NULL == event) {
 			pr_err("%s: Not enough memory!\n", __func__);
 			return;
 		}
 		memset(event, 0, sizeof(struct hdmi_cec_event));
-		event->event_type = MESSAGE_TYPE_DISCONNECTED;
+		event->event_type = (cec_stat & 0x80) ? 
+			MESSAGE_TYPE_CONNECTED : MESSAGE_TYPE_DISCONNECTED;
 
 		mutex_lock(&hdmi_cec_data.lock);
 		list_add_tail(&event->list, &head);
@@ -300,8 +274,7 @@ static ssize_t hdmi_cec_read(struct file *file, char __user *buf, size_t count,
 	if (!open_count)
 		return -ENODEV;
 
-	if (count > (sizeof(struct hdmi_cec_event) - sizeof(struct list_head)))
-		count = (sizeof(struct hdmi_cec_event) - sizeof(struct list_head));
+	count = min(count, sizeof(struct hdmi_cec_event) - sizeof(struct list_head));
 
 	do {
 		unsigned long flags;    
@@ -336,7 +309,7 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 	struct hdmi_cec_priv *hdmi_cec = file->private_data;
 	int ret = 0 , i = 0;
 	u8 msg[MAX_MESSAGE_LEN];
-	u8 msg_len = 0, val = 0;
+	u8 val = 0;
 
 	pr_debug("function : %s\n", __func__);
 	if (!open_count)
@@ -349,49 +322,42 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 	if (copy_from_user(&msg, buf, count))
 		return -EFAULT;
 
-	if (file->f_flags & O_NONBLOCK) {
-		if (hdmi_cec->write_busy)
-			return -EAGAIN;
-	} else {
-		if (wait_event_interruptible(hdmi_cec_queue, (!hdmi_cec->write_busy)))
-			return -ERESTARTSYS;
-	}
-
-	mutex_lock(&hdmi_cec->lock);
-	hdmi_cec->write_busy = true;
-	if (false == hdmi_cec->cec_state) {
-		ret = -EACCES;
-		goto end;
-	}
-
-	hdmi_cec->send_error = 0;
-	msg_len = count;
-	hdmi_writeb(msg_len, HDMI_CEC_TX_CNT);
-	for (i = 0; i < msg_len; i++) {
-		hdmi_writeb(msg[i], HDMI_CEC_TX_DATA0+i);
-	}
-
-	val = hdmi_readb(HDMI_CEC_CTRL);
-	val |= 0x01;
-	hdmi_writeb(val, HDMI_CEC_CTRL);
-	memcpy(hdmi_cec->last_msg, msg, msg_len);
-	hdmi_cec->msg_len = msg_len;
-
-	i = 0;
 	do {
-		if (i)
-			msleep(100);
+		if (file->f_flags & O_NONBLOCK) {
+			if (hdmi_cec->write_busy)
+				ret = -EAGAIN;
+		} else if (wait_event_interruptible(hdmi_cec_queue, (!hdmi_cec->write_busy))) {
+				ret = -ERESTARTSYS;
+		}
+		if (ret)
+			break;
+		
+		mutex_lock(&hdmi_cec->lock);
+		hdmi_cec->write_busy = true;
+
+		hdmi_cec->send_error = 0;
+		hdmi_writeb(count, HDMI_CEC_TX_CNT);
+		for (i = 0; i < count; i++) {
+			hdmi_writeb(msg[i], HDMI_CEC_TX_DATA0+i);
+		}
+
 		val = hdmi_readb(HDMI_CEC_CTRL);
-	} while (val & 0x01 && i++ < 3);
+		val |= 0x01;
+		hdmi_writeb(val, HDMI_CEC_CTRL);
+		memcpy(hdmi_cec->last_msg, msg, count);
+		hdmi_cec->msg_len = count;
 
-	if (val & 0x01)
-		ret = -EIO;
-	else
-		ret = msg_len;
+		mutex_unlock(&hdmi_cec->lock);
+
+		if (!(wait_event_timeout(hdmi_cec_queue, (!(hdmi_readb(HDMI_CEC_CTRL) & 0x01)), msecs_to_jiffies(500)))) {
+			hdmi_cec->msg_len = 0;
+			ret = -EIO;
+		} else {
+			ret = count;
+		}
+	} while(!ret);
 
-end:
 	hdmi_cec->write_busy = false;
-	mutex_unlock(&hdmi_cec->lock);
 	return ret;
 }
 
@@ -425,8 +391,7 @@ static long hdmi_cec_ioctl(struct file *filp, u_int cmd,
 			val = 1 << hdmi_cec_data.Logical_address;
 			hdmi_writeb(val, HDMI_CEC_ADDR_L);
 			hdmi_writeb(0, HDMI_CEC_ADDR_H);
-		} else if (hdmi_cec_data.Logical_address > 7 &&
-					hdmi_cec_data.Logical_address <= 15) {
+		} else if (hdmi_cec_data.Logical_address <= 15) {
 			val = 1 << (hdmi_cec_data.Logical_address - 8);
 			hdmi_writeb(val, HDMI_CEC_ADDR_H);
 			hdmi_writeb(0, HDMI_CEC_ADDR_L);
@@ -447,7 +412,6 @@ static long hdmi_cec_ioctl(struct file *filp, u_int cmd,
 			val |= 0x01;
 			hdmi_writeb(val, HDMI_CEC_CTRL);
 		}
-
 		mutex_unlock(&hdmi_cec_data.lock);
 		break;
 
@@ -473,6 +437,9 @@ static long hdmi_cec_ioctl(struct file *filp, u_int cmd,
 		break;
 
 	case HDMICEC_IOC_STOPDEVICE:
+		mutex_lock(&hdmi_cec_data.lock);
+		hdmi_cec_data.cec_state = false;
+		mutex_unlock(&hdmi_cec_data.lock);
 		hdmi_writeb(0x10, HDMI_CEC_CTRL);
 
 		val = HDMI_IH_CEC_STAT0_WAKEUP | HDMI_IH_CEC_STAT0_ERROR_FOLL |
@@ -487,10 +454,6 @@ static long hdmi_cec_ioctl(struct file *filp, u_int cmd,
 		val = hdmi_readb(HDMI_MC_CLKDIS);
 		val |= HDMI_MC_CLKDIS_CECCLK_DISABLE;
 		hdmi_writeb(val, HDMI_MC_CLKDIS);
-
-		mutex_lock(&hdmi_cec_data.lock);
-		hdmi_cec_data.cec_state = false;
-		mutex_unlock(&hdmi_cec_data.lock);
 		break;
 
 	case HDMICEC_IOC_GETPHYADDRESS:
@@ -514,18 +477,19 @@ static long hdmi_cec_ioctl(struct file *filp, u_int cmd,
 */
 static int hdmi_cec_release(struct inode *inode, struct file *filp)
 {
+	struct hdmi_cec_priv *hdmi_cec = filp->private_data;
 
 	pr_debug("function : %s\n", __func__);
 
-	mutex_lock(&hdmi_cec_data.lock);
-
 	if (open_count) {
-		open_count = 0;
-		wait_event_timeout(hdmi_cec_queue, !hdmi_cec_data.write_busy, msecs_to_jiffies(500));
-		hdmi_cec_data.cec_state = false;
-		hdmi_cec_data.Logical_address = 15;
-		hdmi_cec_data.write_busy = false;
+		if (hdmi_cec->cec_state)
+			hdmi_cec_ioctl(filp, HDMICEC_IOC_STOPDEVICE, 0);
+
+		mutex_lock(&hdmi_cec->lock);
+		if (!(wait_event_timeout(hdmi_cec_queue, !hdmi_cec->write_busy, msecs_to_jiffies(500))))
+			hdmi_cec->write_busy = false;
 
+		open_count = 0;
 		while (!list_empty(&head)) {
 			struct hdmi_cec_event *event;
 
@@ -533,10 +497,8 @@ static int hdmi_cec_release(struct inode *inode, struct file *filp)
 			list_del(&event->list);
 			vfree(event);
 		}
+		mutex_unlock(&hdmi_cec->lock);
 	}
-
-	mutex_unlock(&hdmi_cec_data.lock);
-
 	return 0;
 }
 
@@ -644,8 +606,8 @@ out:
 
 static int hdmi_cec_dev_remove(struct platform_device *pdev)
 {
-	if (hdmi_cec_data.cec_state)
-		hdmi_cec_ioctl(0, HDMICEC_IOC_STOPDEVICE, 0);
+	if (open_count)
+		hdmi_cec_release(0, 0);
 
 	if (hdmi_cec_major > 0) {
 		device_destroy(hdmi_cec_class, MKDEV(hdmi_cec_major, 0));
-- 
1.8.4.2

From 58309413c13ad0176d0dd2daec07a068c23c15fa Mon Sep 17 00:00:00 2001
From: Matus Kral <matuskral@me.com>
Date: Thu, 8 May 2014 07:58:55 +0200
Subject: [PATCH] PA calc back in libcec (revert of mxc_edid.c)

---
 drivers/mxc/hdmi-cec/mxc_hdmi-cec.c | 9 +++------
 drivers/video/mxc/mxc_edid.c        | 6 ++++++
 2 files changed, 9 insertions(+), 6 deletions(-)

diff --git a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
index c1680a4..305b792 100644
--- a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
+++ b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
@@ -286,7 +286,6 @@ static ssize_t hdmi_cec_read(struct file *file, char __user *buf, size_t count,
 			list_del(&event->list);
 		}
 		spin_unlock_irqrestore(&hdmi_cec->irq_lock, flags);
-		wake_up(&hdmi_cec_queue);
 
 		if (event) {
 			ret = copy_to_user(buf, event, count) ? -EFAULT : count;
@@ -347,9 +346,8 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 		memcpy(hdmi_cec->last_msg, msg, count);
 		hdmi_cec->msg_len = count;
 
-		mutex_unlock(&hdmi_cec->lock);
-
-		if (!(wait_event_timeout(hdmi_cec_queue, (!(hdmi_readb(HDMI_CEC_CTRL) & 0x01)), msecs_to_jiffies(500)))) {
+		for (i = 0; i++ < 6 && (hdmi_readb(HDMI_CEC_CTRL) & 0x01); msleep(50));
+		if (hdmi_readb(HDMI_CEC_CTRL) & 0x01) {
 			hdmi_cec->msg_len = 0;
 			ret = -EIO;
 		} else {
@@ -358,6 +356,7 @@ static ssize_t hdmi_cec_write(struct file *file, const char __user *buf,
 	} while(!ret);
 
 	hdmi_cec->write_busy = false;
+	mutex_unlock(&hdmi_cec->lock);
 	return ret;
 }
 
@@ -510,12 +509,10 @@ static unsigned int hdmi_cec_poll(struct file *file, poll_table *wait)
 
 	poll_wait(file, &hdmi_cec_queue, wait);
 
-	mutex_lock(&hdmi_cec_data.lock);
 	if (!hdmi_cec_data.write_busy) 
 		mask = (POLLOUT | POLLWRNORM);
 	if (!list_empty(&head))
 		mask |= (POLLIN | POLLRDNORM);
-	mutex_unlock(&hdmi_cec_data.lock);
 
 	return mask;
 }
diff --git a/drivers/video/mxc/mxc_edid.c b/drivers/video/mxc/mxc_edid.c
index 85b19f5..df29a38 100644
--- a/drivers/video/mxc/mxc_edid.c
+++ b/drivers/video/mxc/mxc_edid.c
@@ -348,8 +348,14 @@ int mxc_edid_parse_ext_blk(unsigned char *edid,
 					IEEE_reg_iden[0] = edid[index+1];
 					IEEE_reg_iden[1] = edid[index+2];
 					IEEE_reg_iden[2] = edid[index+3];
+/* MK
 					cfg->physical_address[0] = edid[index+5];
 					cfg->physical_address[1] = edid[index+4];
+*/
+					cfg->physical_address[0] = (edid[index+4] & 0xf0) >> 4;
+					cfg->physical_address[1] = (edid[index+4] & 0x0f);
+					cfg->physical_address[2] = (edid[index+5] & 0xf0) >> 4;
+					cfg->physical_address[3] = (edid[index+5] & 0x0f);
 
 					if ((IEEE_reg_iden[0] == 0x03) &&
 							(IEEE_reg_iden[1] == 0x0c) &&
-- 
1.8.4.2

